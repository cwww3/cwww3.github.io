<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cwww3&#39;s Blog</title>
  
  <subtitle>Record what you think</subtitle>
  <link href="https://cwww3.github.io/atom.xml" rel="self"/>
  
  <link href="https://cwww3.github.io/"/>
  <updated>2021-09-02T03:13:20.027Z</updated>
  <id>https://cwww3.github.io/</id>
  
  <author>
    <name>Cwww3</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://cwww3.github.io/2021/09/02/linux-command/"/>
    <id>https://cwww3.github.io/2021/09/02/linux-command/</id>
    <published>2021-09-02T03:12:40.000Z</published>
    <updated>2021-09-02T03:13:20.027Z</updated>
    
    <content type="html"><![CDATA[<ul><li>find</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 只在当前目录下搜索 符合条件的文件</span></span><br><span class="line">find . -maxdepth 1 -name 表达式</span><br><span class="line">-type f/d 指定类型</span><br><span class="line">-perm xxx 指定权限</span><br><span class="line">-a 与</span><br><span class="line">-o 或</span><br><span class="line">! -not 非</span><br></pre></td></tr></table></figure><span id="more"></span><ul><li>xargs</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> xargs命令的作用，是将标准输入转为命令行参数。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> 不接受标准输入作为参数 只能直接在命令行输入参数 无法用管道命令传递参数 不会有输出</span> </span><br><span class="line">echo &quot;hello world&quot; | echo </span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出 hello world</span></span><br><span class="line">echo &quot;hello world&quot; | xargs echo</span><br></pre></td></tr></table></figure><ul><li>grep</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 当前目录下查找内容</span></span><br><span class="line">grep -r &quot;要查找的内容&quot; .</span><br></pre></td></tr></table></figure><ul><li>tee</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不退出vim保存没权限的文件</span></span><br><span class="line">:w !sudo tee %</span><br><span class="line"><span class="comment"># w 保存文件内容</span></span><br><span class="line"><span class="comment"># !sudo 使用sudo权限 </span></span><br><span class="line"><span class="comment"># tee 将w输出的内容重定向到%</span></span><br><span class="line"><span class="comment"># % 当前文件</span></span><br></pre></td></tr></table></figure><ul><li>sed</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 替换文件内容</span></span><br><span class="line">sed -i <span class="string">&quot;s/原字符串/替换字符串/g&quot;</span> filename</span><br><span class="line"><span class="comment"># s 表示替换</span></span><br><span class="line"><span class="comment"># g 表示全部替换</span></span><br><span class="line"><span class="comment"># -i 修改文件  -e 将修改后的内容输出到标准输出，不修改文件</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;find&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 只在当前目录下搜索 符合条件的文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;find . -maxdepth 1 -name 表达式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-type f/d 指定类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-perm xxx 指定权限&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-a 与&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-o 或&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;! -not 非&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://cwww3.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Mutex</title>
    <link href="https://cwww3.github.io/2021/08/20/Mutex/"/>
    <id>https://cwww3.github.io/2021/08/20/Mutex/</id>
    <published>2021-08-19T17:23:49.000Z</published>
    <updated>2021-08-19T17:26:37.558Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mutex解析"><a href="#Mutex解析" class="headerlink" title="Mutex解析"></a>Mutex解析</h2><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210820004216764.png" alt="image-20210820004216764" style="zoom:50%;" /><span id="more"></span><h3 id="初版的-Mutex"><a href="#初版的-Mutex" class="headerlink" title="初版的 Mutex"></a>初版的 Mutex</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    key <span class="keyword">int32</span>;</span><br><span class="line">    sema <span class="keyword">int32</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">xadd</span><span class="params">(val *<span class="keyword">int32</span>, delta <span class="keyword">int32</span>)</span> <span class="params">(<span class="built_in">new</span> <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        v := *val;</span><br><span class="line">        <span class="keyword">if</span> cas(val, v, v+delta) &#123;</span><br><span class="line">            <span class="keyword">return</span> v+delta;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;unreached&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> xadd(&amp;m.key, <span class="number">1</span>) == <span class="number">1</span> &#123;</span><br><span class="line">      <span class="comment">// changed from 0 to 1; we hold lock</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sys.semacquire(&amp;m.sema);</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">     <span class="keyword">if</span> xadd(&amp;m.key, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">       <span class="comment">// changed from 1 to 0; no contention</span></span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     sys.semrelease(&amp;m.sema);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以看到，这简单几行就可以实现一个排外锁。通过<code>cas</code>对 <code>key</code> 进行加一, 如果<code>key</code>的值是从<code>0</code>加到<code>1</code>, 则直接获得了锁。否则通过<code>semacquire</code>进行sleep, 被唤醒的时候就获得了锁。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>互斥锁有两种状态：正常状态和饥饿状态。</p><p>在正常状态下，所有等待锁的goroutine按照<strong>FIFO</strong>顺序等待。唤醒的goroutine不会直接拥有锁，而是会和新请求锁的goroutine竞争锁的拥有。新请求锁的goroutine具有优势：它正在CPU上执行，而且可能有好几个，所以刚刚唤醒的goroutine有很大可能在锁竞争中失败。在这种情况下，这个被唤醒的goroutine会加入到等待队列的前面。 如果一个等待的goroutine超过1ms没有获取锁，那么它将会把锁转变为饥饿模式。</p><p>在饥饿模式下，锁的所有权将从unlock的gorutine直接交给交给等待队列中的第一个。新来的goroutine将不会尝试去获得锁，即使锁看起来是unlock状态, 也不会去尝试自旋操作，而是放在等待队列的尾部。</p><p>如果一个等待的goroutine获取了锁，并且满足一以下其中的任何一个条件：(1)它是队列中的最后一个；(2)它等待的时候小于1ms。它会将锁的状态转换为正常状态。</p><p>正常状态有很好的性能表现，饥饿模式也是非常重要的，因为它能阻止尾部延迟的现象。</p><p> 我们要从多线程(goroutine)的并发场景去理解为什么实现中有很多的分支。</p><p>当一个goroutine获取这个锁的时候， 有可能这个锁根本没有竞争者， 那么这个goroutine轻轻松松获取了这个锁。而如果这个锁已经被别的goroutine拥有， 就需要考虑怎么处理当前的期望获取锁的goroutine。同时， 当并发goroutine很多的时候，有可能会有多个竞争者， 而且还会有通过信号量唤醒的等待者。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    state <span class="keyword">int32</span></span><br><span class="line">    sema  <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>state</code>是一个共用的字段， <strong>第0个</strong> bit 标记这个<code>mutex</code>是否已被某个goroutine所拥有， 下面为了描述方便称之为<code>state</code>已加锁，或者<code>mutex</code>已加锁。 如果<strong>第0个</strong> bit为0, 下文称之为<code>state</code>未被锁, 此mutex目前没有被某个goroutine所拥有。</p><p><strong>第1个</strong> bit 标记这个<code>mutex</code>是否已唤醒, 也就是有某个唤醒的<code>goroutine</code>要尝试获取锁。</p><p><strong>第2个</strong> bit 标记这个<code>mutex</code>状态， 值为1表明此锁已处于饥饿状态。</p><p>其余bit用于记录等待得到锁的goroutine数</p><p>同时，尝试获取锁的goroutine也有状态，有可能它是新来的goroutine，也有可能是被唤醒的goroutine, 可能是处于正常状态的goroutine, 也有可能是处于饥饿状态的goroutine。</p><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果mutext的state没有被锁，也没有等待/唤醒的goroutine, 锁处于正常状态，那么获得锁，返回.</span></span><br><span class="line">    <span class="comment">// 比如锁第一次被goroutine请求时，就是这种状态。或者锁处于空闲的时候，也是这种状态。</span></span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记本goroutine的等待时间</span></span><br><span class="line">    <span class="keyword">var</span> waitStartTime <span class="keyword">int64</span></span><br><span class="line">    <span class="comment">// 本goroutine是否已经处于饥饿状态</span></span><br><span class="line">    starving := <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 本goroutine是否已唤醒</span></span><br><span class="line">    awoke := <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自旋次数</span></span><br><span class="line">    iter := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制锁的当前状态</span></span><br><span class="line">    old := m.state</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 第一个条件是state已被锁，但是不是饥饿状态。如果是饥饿状态，自旋时没有用的，锁的拥有权直接交给了等待队列的第一个。</span></span><br><span class="line">        <span class="comment">// 第二个条件是还可以自旋，多核、压力不大并且在一定次数内可以自旋， 具体的条件可以参考`sync_runtime_canSpin`的实现。</span></span><br><span class="line">        <span class="comment">// 如果满足这两个条件，不断自旋来等待锁被释放、或者进入饥饿状态、或者不能再自旋。</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">            <span class="comment">// 自旋的过程中如果发现state还没有设置woken标识，则设置它的woken标识， 并标记自己为被唤醒。</span></span><br><span class="line">            <span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">                awoke = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            runtime_doSpin()</span><br><span class="line">            iter++</span><br><span class="line">            old = m.state</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 到了这一步， state的状态可能是：</span></span><br><span class="line">        <span class="comment">// 1. 锁还没有被释放，锁处于正常状态</span></span><br><span class="line">        <span class="comment">// 2. 锁还没有被释放， 锁处于饥饿状态</span></span><br><span class="line">        <span class="comment">// 3. 锁已经被释放， 锁处于正常状态</span></span><br><span class="line">        <span class="comment">// 4. 锁已经被释放， 锁处于饥饿状态</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 并且本gorutine的 awoke可能是true, 也可能是false (其它goutine已经设置了state的woken标识)</span></span><br><span class="line">        <span class="comment">// new 复制 state的当前状态， 用来设置新的状态</span></span><br><span class="line">        <span class="comment">// old 是锁当前的状态</span></span><br><span class="line">        <span class="built_in">new</span> := old</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果old state状态不是饥饿状态, new state 设置锁， 尝试通过CAS获取锁,</span></span><br><span class="line">        <span class="comment">// 如果old state状态是饥饿状态, 则不设置new state的锁，因为饥饿状态下锁直接转给等待队列的第一个.</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">new</span> |= mutexLocked</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将等待队列的等待者的数量加1</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前goroutine已经处于饥饿状态， 并且old state的已被加锁,</span></span><br><span class="line">        <span class="comment">// 将new state的状态标记为饥饿状态, 将锁转变为饥饿状态.</span></span><br><span class="line">        <span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">new</span> |= mutexStarving</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果本goroutine已经设置为唤醒状态, 需要清除new state的唤醒标记, 因为本goroutine要么获得了锁，要么进入休眠，</span></span><br><span class="line">        <span class="comment">// 总之state的新状态不再是woken状态.</span></span><br><span class="line">        <span class="keyword">if</span> awoke &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过CAS设置new state值.</span></span><br><span class="line">        <span class="comment">// 注意new的锁标记不一定是true, 也可能只是标记一下锁的state是饥饿状态.</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果old state的状态是未被锁状态，并且锁不处于饥饿状态,</span></span><br><span class="line">            <span class="comment">// 那么当前goroutine已经获取了锁的拥有权，返回</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 设置/计算本goroutine的等待时间</span></span><br><span class="line">            queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">                waitStartTime = runtime_nanotime()</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 既然未能获取到锁， 那么就使用sleep原语阻塞本goroutine</span></span><br><span class="line">            <span class="comment">// 如果是新来的goroutine,queueLifo=false, 加入到等待队列的尾部，耐心等待</span></span><br><span class="line">            <span class="comment">// 如果是唤醒的goroutine, queueLifo=true, 加入到等待队列的头部</span></span><br><span class="line">            runtime_SemacquireMutex(&amp;m.sema, queueLifo)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// sleep之后，此goroutine被唤醒</span></span><br><span class="line">            <span class="comment">// 计算当前goroutine是否已经处于饥饿状态.</span></span><br><span class="line">            starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">            <span class="comment">// 得到当前的锁状态</span></span><br><span class="line">            old = m.state</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果当前的state已经是饥饿状态</span></span><br><span class="line">            <span class="comment">// 那么锁应该处于Unlock状态，那么应该是锁被直接交给了本goroutine</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123; </span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果当前的state已被锁，或者已标记为唤醒， 或者等待的队列中不为空,</span></span><br><span class="line">                <span class="comment">// 那么state是一个非法状态</span></span><br><span class="line">                <span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">                    throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 当前goroutine用来设置锁，并将等待的goroutine数减1.</span></span><br><span class="line">                delta := <span class="keyword">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果本goroutine是最后一个等待者，或者它并不处于饥饿状态，</span></span><br><span class="line">                <span class="comment">// 那么我们需要把锁的state状态设置为正常模式.</span></span><br><span class="line">                <span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">                    <span class="comment">// 退出饥饿模式</span></span><br><span class="line">                    delta -= mutexStarving</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 设置新state, 因为已经获得了锁，退出、返回</span></span><br><span class="line">                atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果当前的锁是正常模式，本goroutine被唤醒，自旋次数清零，从for循环开始处重新开始</span></span><br><span class="line">            awoke = <span class="literal">true</span></span><br><span class="line">            iter = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果CAS不成功，重新获取锁的state, 从for循环开始处重新开始</span></span><br><span class="line">            old = m.state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Unlock"><a href="#Unlock" class="headerlink" title="Unlock"></a>Unlock</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果state不是处于锁的状态, 那么就是Unlock根本没有加锁的mutex, panic</span></span><br><span class="line">    <span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放了锁，还得需要通知其它等待者</span></span><br><span class="line">    <span class="comment">// 锁如果处于饥饿状态，直接交给等待队列的第一个, 唤醒它，让它去获取锁</span></span><br><span class="line">    <span class="comment">// 锁如果处于正常状态，</span></span><br><span class="line">    <span class="comment">// new state如果是正常状态</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">        old := <span class="built_in">new</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有等待的goroutine, 或者锁不处于空闲的状态，直接返回.</span></span><br><span class="line">            <span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将等待的goroutine数减一，并设置woken标识</span></span><br><span class="line">            <span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">            <span class="comment">// 设置新的state, 这里通过信号量会唤醒一个阻塞的goroutine去获取锁.</span></span><br><span class="line">            <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">                runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            old = m.state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 饥饿模式下， 直接将锁的拥有权传给等待队列中的第一个.</span></span><br><span class="line">        <span class="comment">// 注意此时state的mutexLocked还没有加锁，唤醒的goroutine会设置它。</span></span><br><span class="line">        <span class="comment">// 在此期间，如果有新的goroutine来请求锁， 因为mutex处于饥饿状态， mutex还是被认为处于锁状态，</span></span><br><span class="line">        <span class="comment">// 新来的goroutine不会把锁抢过去.</span></span><br><span class="line">        runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据<code>Unlock</code>的代码分析，下面的哪个答案正确?</p><p>如果一个goroutine <code>g1</code> 通过<code>Lock</code>获取了锁， 在持有锁的期间， 另外一个goroutine <code>g2</code> 调用<code>Unlock</code>释放这个锁， 会出现什么现象？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        mu.Lock()</span><br><span class="line">        time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">        mu.Unlock()</span><br><span class="line">    &#125;()</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    mu.Unlock()</span><br><span class="line">    <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁被另一个goroutine解了，再次解锁时会panic</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Mutex解析&quot;&gt;&lt;a href=&quot;#Mutex解析&quot; class=&quot;headerlink&quot; title=&quot;Mutex解析&quot;&gt;&lt;/a&gt;Mutex解析&lt;/h2&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210820004216764.png&quot; alt=&quot;image-20210820004216764&quot; style=&quot;zoom:50%;&quot; /&gt;</summary>
    
    
    
    
    <category term="go 源码" scheme="https://cwww3.github.io/tags/go-%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>WaitGroup</title>
    <link href="https://cwww3.github.io/2021/08/19/WaitGroup/"/>
    <id>https://cwww3.github.io/2021/08/19/WaitGroup/</id>
    <published>2021-08-19T12:57:52.000Z</published>
    <updated>2021-08-19T12:59:49.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WaitGroup介绍"><a href="#WaitGroup介绍" class="headerlink" title="WaitGroup介绍"></a>WaitGroup介绍</h2><p>WaitGroup 提供了三个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><span id="more"></span><ul><li>Add，用来设置 WaitGroup 的计数值；</li><li>Done，用来将 WaitGroup 的计数值减 1，其实就是调用了 Add(-1)；</li><li>Wait，调用这个方法的 goroutine 会一直阻塞，直到 WaitGroup 的计数值变为 0。</li></ul><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> noCopy <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 避免复制使用的一个技巧，可以告诉vet工具违反了复制使用的规则</span></span><br><span class="line">noCopy noCopy</span><br><span class="line"><span class="comment">// 一个复合值，用来表示waiter数、计数值、信号量</span></span><br><span class="line">state1 [<span class="number">3</span>]<span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取state的地址和信号量的地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">state</span><span class="params">()</span> <span class="params">(statep *<span class="keyword">uint64</span>, semap *<span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;wg.state1))%<span class="number">8</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 如果地址是64bit对齐的，数组前两个元素做state，后一个元素做信号量</span></span><br><span class="line"><span class="keyword">return</span> (*<span class="keyword">uint64</span>)(unsafe.Pointer(&amp;wg.state1)), &amp;wg.state1[<span class="number">2</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果地址是32bit对齐的，数组后两个元素用来做state，它可以用来做64bit的原子操作，第一个元素32bit用来做信号量</span></span><br><span class="line"><span class="keyword">return</span> (*<span class="keyword">uint64</span>)(unsafe.Pointer(&amp;wg.state1[<span class="number">1</span>])), &amp;wg.state1[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WaitGroup中state方法的内存对齐"><a href="#WaitGroup中state方法的内存对齐" class="headerlink" title="WaitGroup中state方法的内存对齐"></a>WaitGroup中state方法的内存对齐</h3><p><code>noCopy</code>是一个空的结构体，大小为0，不需要做内存对齐，所以可以忽略这个字段。</p><p>使用了<code>uint32</code>的数组来构造<code>state1</code>字段，然后根据系统的位数的不同构造不同的返回值，下面说说怎么通过sate1这个字段构建waiter数、计数值、信号量的。</p><h3 id="state1状态和信号量处理"><a href="#state1状态和信号量处理" class="headerlink" title="state1状态和信号量处理"></a><code>state1</code>状态和信号量处理</h3><p><code>state1</code>这里总共被分配了<code>12</code>个字节，这里被设计了三种状态：</p><ul><li>其中对齐的<code>8</code>个字节作为状态，高<code>32</code>位为计数的数量，低<code>32</code>位为等待的<code>goroutine</code>数量</li><li>其中的<code>4</code>个字节作为信号量存储</li></ul><p>提供了<code>(wg *WaitGroup) state() (statep *uint64, semap *uint32)</code>从<code>state1</code>字段中取出他的状态和信号量。</p><p>首先<code>unsafe.Pointer</code>来获取state1的地址值然后转换成uintptr类型的，然后判断一下这个地址值是否能被8整除，这里通过地址 mod 8的方式来判断地址是否是64位对齐。</p><p>因为有内存对齐的存在，在64位架构里面WaitGroup结构体state1起始的位置肯定是64位对齐的，所以在64位架构上用state1前两个元素并成uint64来表示statep，state1最后一个元素表示semap；</p><p>但是在32位架构里面，一个字长是4bytes，要操作64位的数据分布在<strong>两个数据块</strong>中，需要两次操作才能完成访问。如果两次操作中间有可能别其他操作修改，不能保证原子性。</p><p>同理32位架构想要原子性的操作8bytes，需要由调用方保证其数据地址是64位对齐的，否则原子访问会有异常。</p><p>在32位架构中，WaitGroup在初始化的时候，分配内存地址的时候是随机的，所以WaitGroup结构体state1起始的位置不一定是64位对齐，可能会是：<code>uintptr(unsafe.Pointer(&amp;wg.state1))%8 = 4</code>，如果出现这样的情况，那么就需要用state1的第一个元素做padding，用state1的后两个元素合并成uint64来表示statep。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210819203755697.png" alt="image-20210819203755697" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210819204844516.png" alt="image-20210819204844516" style="zoom:50%;" /><h3 id="Add-方法"><a href="#Add-方法" class="headerlink" title="Add 方法"></a>Add 方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取状态值</span></span><br><span class="line">statep, semap := wg.state()</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 高32bit是计数值v，所以把delta左移32，增加到计数上</span></span><br><span class="line">state := atomic.AddUint64(statep, <span class="keyword">uint64</span>(delta)&lt;&lt;<span class="number">32</span>)</span><br><span class="line"><span class="comment">// 获取计数器的值</span></span><br><span class="line">v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line"><span class="comment">// 获取waiter的值</span></span><br><span class="line">w := <span class="keyword">uint32</span>(state)</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 任务计数器不能为负数</span></span><br><span class="line"><span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;sync: negative WaitGroup counter&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// wait不等于0说明已经执行了Wait，此时不容许Add(正数)</span></span><br><span class="line"><span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; delta &gt; <span class="number">0</span> &amp;&amp; v == <span class="keyword">int32</span>(delta) &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计数器的值大于或者没有waiter在等待,直接返回</span></span><br><span class="line"><span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> *statep != state &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 根据上面的条件 此时v等于0且w&gt;0</span></span><br><span class="line">  <span class="comment">// statep清零 可以在Wait()阻塞之后可以重用</span></span><br><span class="line">*statep = <span class="number">0</span></span><br><span class="line">  <span class="comment">// w一般等于1，一般是main函数执行了一次Wait()方法</span></span><br><span class="line"><span class="keyword">for</span> ; w != <span class="number">0</span>; w-- &#123;</span><br><span class="line">    <span class="comment">//释放信号量，执行一次释放一个，唤醒一个等待者，一般是唤醒main(goroutine)</span></span><br><span class="line">runtime_Semrelease(semap, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Wait方法"><a href="#Wait方法" class="headerlink" title="Wait方法"></a>Wait方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">statep, semap := wg.state()</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">state := atomic.LoadUint64(statep)</span><br><span class="line"><span class="comment">// 获取counter</span></span><br><span class="line">v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line"><span class="comment">// 获取waiter</span></span><br><span class="line">w := <span class="keyword">uint32</span>(state)</span><br><span class="line"><span class="comment">// counter为零,不需要等待直接返回</span></span><br><span class="line"><span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用CAS将waiter加1  执行一次Wait方法，wait值就加一，通过循环保证一定能加上</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class="number">1</span>) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 挂起等待唤醒  等待Add方法中runtime_Semrelease唤醒</span></span><br><span class="line">runtime_Semacquire(semap)</span><br><span class="line">      <span class="comment">// 唤醒之后statep应该是清零的 如果不为零,表示WaitGroup又被重复使用,这会panic</span></span><br><span class="line">      <span class="comment">// 在全部调用Wait的goroutine都被唤醒后wg才能再次使用</span></span><br><span class="line"><span class="keyword">if</span> *statep != <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup is reused before previous Wait has returned&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">         <span class="comment">// 直接返回   </span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><p>写个例子去debug一下，看一下个状态下w，v的值，就会清晰很多</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;WaitGroup介绍&quot;&gt;&lt;a href=&quot;#WaitGroup介绍&quot; class=&quot;headerlink&quot; title=&quot;WaitGroup介绍&quot;&gt;&lt;/a&gt;WaitGroup介绍&lt;/h2&gt;&lt;p&gt;WaitGroup 提供了三个方法：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(wg *WaitGroup)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(delta &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(wg *WaitGroup)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(wg *WaitGroup)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="go 源码" scheme="https://cwww3.github.io/tags/go-%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>pprof</title>
    <link href="https://cwww3.github.io/2021/07/19/pprof/"/>
    <id>https://cwww3.github.io/2021/07/19/pprof/</id>
    <published>2021-07-19T05:11:46.000Z</published>
    <updated>2021-07-19T05:12:14.518Z</updated>
    
    <content type="html"><![CDATA[<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><ul><li>web程序 </li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_ <span class="string">&quot;net/http/pprof&quot;</span> <span class="comment">// 引入 pprof 包</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  ...</span><br><span class="line">  fmt.Println(http.ListenAndServe(<span class="string">&quot;localhost:port&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于非web程序 </li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过启动一个goroutine监听端口</span></span><br><span class="line">main() &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(http.ListenAndServe(<span class="string">&quot;localhost:port&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;()</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 或者使用runtime/pprof包 并从程序中获取相关信息</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_ <span class="string">&quot;runtime/pprof&quot;</span> <span class="comment">// 引入 pprof 包</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="采集信息"><a href="#采集信息" class="headerlink" title="采集信息"></a>采集信息</h3><ul><li>接口获取</li></ul><p>通过访问 <code>http://localhost:port/debug/pprof/</code>采集数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 对 CPU 的信息采集三秒，然后输出到 cpu.pprof 文件中</span></span><br><span class="line">curl http://localhost:port/debug/pprof/profile?seconds=3 -o cpu.pprof</span><br><span class="line"><span class="meta">#</span><span class="bash"> 等价</span></span><br><span class="line">curl http://localhost:port/debug/pprof/profile?seconds=3 &gt; cpu.pprof</span><br></pre></td></tr></table></figure><ul><li>程序中获取</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 trace 信息</span></span><br><span class="line">f, err := os.Create(<span class="string">&quot;trace.out&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = trace.Start(f)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 CPU 的信息</span></span><br><span class="line"><span class="keyword">var</span> cpuprofile = flag.String(<span class="string">&quot;cpuprofile&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;write cpu profile to `file`&quot;</span>)</span><br><span class="line">flag.Parse()</span><br><span class="line"><span class="keyword">if</span> *cpuprofile != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    f, err := os.Create(*cpuprofile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;could not create CPU profile: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    <span class="keyword">if</span> err := pprof.StartCPUProfile(f); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;could not start CPU profile: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> pprof.StopCPUProfile()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取内存信息</span></span><br><span class="line"><span class="keyword">var</span> memprofile = flag.String(<span class="string">&quot;memprofile&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;write memory profile to `file`&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> *memprofile != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    f, err := os.Create(*memprofile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;could not create memory profile: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close() </span><br><span class="line">    runtime.GC() </span><br><span class="line">    <span class="keyword">if</span> err := pprof.WriteHeapProfile(f); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;could not write memory profile: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="可视化分析"><a href="#可视化分析" class="headerlink" title="可视化分析"></a>可视化分析</h3><p><code>go tool pprof</code> 既可以对采集到的离线数据进行分析，也可以是结合上面的 pprof http 接口，直接在线上进行分析</p><ul><li>在线分析</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 交互式界面</span></span><br><span class="line">go tool pprof http://localhost:port/debug/pprof/heap</span><br></pre></td></tr></table></figure><ul><li>离线分析</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 交互式界面</span></span><br><span class="line">go tool pprof memory.prof</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以web形式打开</span></span><br><span class="line">go tool pprof -http=:port memory.prof</span><br></pre></td></tr></table></figure><p><code>go tool trace</code>  无法在线上完成，只能通过线下的方式完成</p><ul><li>离线分析</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool trace trace.out</span><br></pre></td></tr></table></figure><h3 id="压测工具"><a href="#压测工具" class="headerlink" title="压测工具"></a>压测工具</h3><ul><li><a href="https://github.com/wg/wrk">wrk地址</a> </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/wg/wrk</span><br><span class="line">cd wrk</span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认情况下wrk会使用自带的LuaJIT和OpenSSL，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果你想使用系统已安装的版本，可以使用WITH_LUAJIT和WITH_OPENSSL这两个选项来指定它们的路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make WITH_LUAJIT=/usr WITH_OPENSSL=/usr</span></span><br><span class="line">make</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在当前目录生成wrk二进制文件 可以将其拷贝到<span class="variable">$PATH</span>目录下</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用方法: wrk &lt;选项&gt; &lt;被测HTTP服务的URL&gt;</span>                            </span><br><span class="line">  Options:                                            </span><br><span class="line">    -c, --connections &lt;N&gt;  跟服务器建立并保持的TCP连接数量  </span><br><span class="line">    -d, --duration    &lt;T&gt;  压测时间           </span><br><span class="line">    -t, --threads     &lt;N&gt;  使用多少个线程进行压测   </span><br><span class="line">                                                      </span><br><span class="line">    -s, --script      &lt;S&gt;  指定Lua脚本路径       </span><br><span class="line">    -H, --header      &lt;H&gt;  为每一个HTTP请求添加HTTP头      </span><br><span class="line">        --latency          在压测结束后，打印延迟统计信息   </span><br><span class="line">        --timeout     &lt;T&gt;  超时时间     </span><br><span class="line">    -v, --version          打印正在使用的wrk的详细版本信息</span><br><span class="line">                                                      </span><br><span class="line">  &lt;N&gt;代表数字参数，支持国际单位 (1k, 1M, 1G)</span><br><span class="line">  &lt;T&gt;代表时间参数，支持时间单位 (2s, 2m, 2h)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用8个线程200个连接，对bing首页进行了30秒的压测，并要求在压测结果中输出响应延迟信息</span></span><br><span class="line">wrk -t8 -c200 -d30s --latency  &quot;http://www.bing.com&quot;  </span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/rakyll/hey">hey地址</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;部署&quot;&gt;&lt;a href=&quot;#部署&quot; class=&quot;headerlink&quot; title=&quot;部署&quot;&gt;&lt;/a&gt;部署&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;web程序 &lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	_ &lt;span class=&quot;string&quot;&gt;&amp;quot;net/http/pprof&amp;quot;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// 引入 pprof 包&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="pprof" scheme="https://cwww3.github.io/tags/pprof/"/>
    
  </entry>
  
  <entry>
    <title>mq</title>
    <link href="https://cwww3.github.io/2021/07/14/mq/"/>
    <id>https://cwww3.github.io/2021/07/14/mq/</id>
    <published>2021-07-14T10:12:29.000Z</published>
    <updated>2021-07-14T10:14:54.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ul><li>解耦</li><li>异步</li><li>流量削峰</li></ul><span id="more"></span><h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><p>AMQP的全称为：Advanced Message Queuing Protocol（高级消息队列协议）。</p><p>相比JMS：</p><ol><li>JMS定义的是API规范，而AMQP定义了线路层的协议。即JMS实现所发送的消息不能保证被另外不同的JMS实现使用；而AMQP的线路层协议规范了消息的格式，这样不仅能跨AMQP实现，还能跨语言和跨平台。</li><li>AMQP具有更加灵活和透明的消息模型。JMS中只有点对点和发布-订阅两种模式；而AMQP通过将消息生产者与消息队列解耦实现多种方式来发送消息。</li></ol><p>JMS：(ActiveMQ)</p><ul><li>消息生产者 </li><li>消息消费者</li><li>消息通道</li></ul><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210713101139876.png" alt="image-20210713101139876" style="zoom:50%;" /><p>消息生产者将消息发送到通道中，消费者从通道中取出数据消费。</p><p>通道具有双重责任： </p><ol><li>解耦消息的生产者与消费者；</li><li>传递数据以及确定消息发送地方。</li></ol><p>AMQP：</p><p>在消息的生产者与通道之间引入了一种机制：Exchange（交换器），解耦了消息的生产者与队列。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210713101403330.png" alt="image-20210713101403330" style="zoom: 25%;" /><p>消息生产者将消息（带有一个routing key参数）发送到Exchange上，Exchange会绑定一个或多个队列上，然后Exchange根据不同的路由模式，对比队列携带的routing key参数，负责将信息发送到不同队列上。</p><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210713105130472.png" alt="image-20210713105130472" style="zoom:50%;" /><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p>消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</p><h3 id="Publisher"><a href="#Publisher" class="headerlink" title="Publisher"></a>Publisher</h3><p>消息的生产者，也是一个向交换器发布消息的客户端应用程序。</p><h3 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h3><p>Exchange称作交换器，它接收消息和路由消息，然后将消息发送给消息队列。每个交换器都有独一无二的名字。相当于一个路由表。</p><h3 id="Binding-和-Binding-Key"><a href="#Binding-和-Binding-Key" class="headerlink" title="Binding 和 Binding Key"></a>Binding 和 Binding Key</h3><p>每个Exchange都和一个特定的Queue绑定（可以是多对多的关系）。绑定的同时会指定一个binding key。</p><p>每个发送给Exchange的消息一般都有一个routing key参数；当队列与Exchange绑定的binding key与该消息的routing key参数相同的时候，该消息才会被Exchange发给特定的队列。</p><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>Queue是一个不重复，唯一，名字随机的的缓冲区，应用程序在其权限之内可以自由地创建、共享使用和消费消息队列。在RabbitMQ中，队列的名字是系统随机创建的，且当Consumer与Queue断开连接的时候，Queue会被自动删除，在下一次连接时又会自动创建。</p><h3 id="Routing-Key"><a href="#Routing-Key" class="headerlink" title="Routing Key"></a>Routing Key</h3><p>生产者在将消息发送给Exchange的时候，一般会指定一个routing key，来指定这个消息的路由规则。<br>而这个routing key需要与Exchange Type及binding key联合使用才能最终生效。<br>在Exchange Type与binding key固定的情况下，生产者就可以在发送消息给Exchange时，通过指定routing key来决定消息流向哪里。<br>RabbitMQ为routing key设定的长度限制为255 bytes。</p><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内地虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</p><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</p><h3 id="Virtual-Host"><a href="#Virtual-Host" class="headerlink" title="Virtual Host"></a>Virtual Host</h3><p>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</p><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>表示消息队列服务器实体。</p><h3 id="Exchange-Type"><a href="#Exchange-Type" class="headerlink" title="Exchange Type"></a>Exchange Type</h3><p>AMQP定义了4种不同类型的Exchange，每一种都有不同的路由算法。</p><h4 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h4><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210713102242328.png" alt="image-20210713102242328" style="zoom:50%;" /><p>生产者P发送消息到交换器X。</p><p>消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。路由键与队列名<strong>完全匹配</strong>，单播的模式。</p><p>如果消息的routing key 是 orange，则会被路由到队列Q1；<br>如果消息的routing key 是 black 或 green，则会被路由到队列Q2。</p><p>也可以实现多路绑定，即当X和Q1、Q2都绑定了black，routing key 是 black 时，两个队列都能接收到消息。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210713102542004.png" alt="image-20210713102542004" style="zoom:50%;" /><h4 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h4><p>topic 交换器通过<strong>模式匹配</strong>分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用<code>. </code>隔开。它同样也会识别两个通配符：符号<code>#</code>和符号<code>*</code>。<code>#</code>匹配0个或多个单词，<code>*</code>匹配一个单词。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210713102637590.png" alt="image-20210713102637590" style="zoom:50%;" /><h4 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a>Fanout</h4><p>每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的。</p><p>生产者（P）发送到Exchange（X）的所有消息都会路由到图中的两个Queue，并最终被两个消费者（C1与C2）消费。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210713103054848.png" alt="image-20210713103054848" style="zoom:50%;" /><h3 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h3><p>headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。与direct相似，但是效率较低。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://www.erlang.org/downloads">erlang</a>  <a href="https://www.rabbitmq.com/download.html">rabbitmq</a></p><p>mac 通过<code>brew install rabbitmq</code> 安装会自动下载erlang依赖</p><p>ARM 版 rabbitmq 路径 <code>/opt/homebrew/sbin </code>  X86 版  <code>/usr/local/Homebrew/sbin</code></p><p>添加到$PATH下</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><a href="https://github.com/cwww3/rabbitmq-go-demo">项目地址</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;消息队列&quot;&gt;&lt;a href=&quot;#消息队列&quot; class=&quot;headerlink&quot; title=&quot;消息队列&quot;&gt;&lt;/a&gt;消息队列&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;解耦&lt;/li&gt;
&lt;li&gt;异步&lt;/li&gt;
&lt;li&gt;流量削峰&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="mq" scheme="https://cwww3.github.io/tags/mq/"/>
    
  </entry>
  
  <entry>
    <title>protobuf</title>
    <link href="https://cwww3.github.io/2021/07/14/protobuf/"/>
    <id>https://cwww3.github.io/2021/07/14/protobuf/</id>
    <published>2021-07-14T10:07:27.000Z</published>
    <updated>2021-07-14T10:08:06.208Z</updated>
    
    <content type="html"><![CDATA[<h3 id="message"><a href="#message" class="headerlink" title="message"></a>message</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">int32</span> result_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><ul><li>文件后缀<code>.proto</code></li><li>第一行定义版本 默认 <code>proto2</code> </li><li>唯一的数字编号用于识别在消息二进制格式中的字段。一旦被使用，不能更改。1-15只需要一个字节进行编码，用于标识频繁使用的字段。数字编号有一定的范围，且有一些预定义的数字。</li><li><code>proto3</code> 字段默认是 <code>singular</code> 的，标识0个或1个。<code>repeated</code> 标识0个或多个</li><li>一个<code>.proto</code> 文件中可以定义多个消息类型。</li><li>可以通过<code>import</code> 引入定义在其他<code>.protocol</code> 中的消息类型</li><li>注释格式 当行<code>//</code>  多行<code>/*...*/</code></li></ul><h3 id="更新消息类型"><a href="#更新消息类型" class="headerlink" title="更新消息类型"></a>更新消息类型</h3><ul><li><p>如果因为更新删除一个字段或将其直接注释掉，这些被删掉的字段可能被重新使用，加载老版本的数据时，可能会造成数据冲突。</p></li><li><p>可以通过指定保留你删除的字段的编号或名字，这样当使用该数字编号时，编译器会报错。(JSON序列化可能会有问题)</p></li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  reserved <span class="number">2</span>, <span class="number">15</span>, <span class="number">9</span> to <span class="number">11</span>; <span class="comment">// 不能在同一个保留语句中(reserved)混合使用编号和字段名</span></span><br><span class="line">  reserved <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h3><p>当使用编译器编译<code>.proto</code> 文件时，编译器会生成你所选择的语言生成代码，对于Go,会生成一个<code>.pb.go</code>文件，里面包含<code>.proto</code>中的定义的每一个类型。</p><h3 id="类型对应"><a href="#类型对应" class="headerlink" title="类型对应"></a>类型对应</h3><table><thead><tr><th>proto类型</th><th>Go类型</th></tr></thead><tbody><tr><td>double</td><td>float64</td></tr><tr><td>float</td><td>float32</td></tr><tr><td>int32,int64 (对负数编码效率低)</td><td>int32,int64</td></tr><tr><td>sint32,sint64  (适用于对负数编码)</td><td>int32,int64</td></tr><tr><td>uint32,uint64</td><td>uint32,uint64</td></tr><tr><td>bytes</td><td>[]bytes</td></tr><tr><td>string</td><td>string</td></tr><tr><td>bool</td><td>bool</td></tr><tr><td>message</td><td>*struct  []*struct</td></tr></tbody></table><h3 id="GRPC"><a href="#GRPC" class="headerlink" title="GRPC"></a>GRPC</h3><ul><li><p>是rpc的框架</p></li><li><p>服务类型</p><ul><li>一元RPC</li><li>服务端流式RPC</li><li>客服端流式RPC</li><li>双向流式 RPC</li></ul></li><li><p>在服务器端，服务器实现服务声明的方法并运行 gRPC 服务器来处理客户端调用。gRPC 基础设施解码传入请求、执行服务方法并编码服务响应。</p></li><li><p>在客户端，客户端有一个称为<em>stub</em>的本地对象，它实现与服务相同的方法(由proto生成的文件)。然后客户端可以在本地对象上调用这些方法，将调用的参数包装在适当的协议缓冲区消息类型中 ，gRPC 负责将请求发送到服务器并返回服务器的协议缓冲区响应。</p></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><a href="https://github.com/cwww3/grpc_demo">示例代码</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;message&quot;&gt;&lt;a href=&quot;#message&quot; class=&quot;headerlink&quot; title=&quot;message&quot;&gt;&lt;/a&gt;message&lt;/h3&gt;&lt;figure class=&quot;highlight protobuf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;syntax = &lt;span class=&quot;string&quot;&gt;&amp;quot;proto3&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SearchRequest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; query = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;int32&lt;/span&gt; page_number = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;int32&lt;/span&gt; result_per_page = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="protobuf" scheme="https://cwww3.github.io/tags/protobuf/"/>
    
  </entry>
  
  <entry>
    <title>makefile</title>
    <link href="https://cwww3.github.io/2021/07/09/makefile/"/>
    <id>https://cwww3.github.io/2021/07/09/makefile/</id>
    <published>2021-07-09T08:08:08.000Z</published>
    <updated>2021-07-09T08:09:09.158Z</updated>
    
    <content type="html"><![CDATA[<p>Makefile由一条或多条规则构成。每条规则格式如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt; </span><br><span class="line">[tab]  &lt;commands&gt;</span><br></pre></td></tr></table></figure><span id="more"></span><p><code>target</code> 表示目标，即要创建的文件(可以是多个 通过空格隔开 通常是文件)，除了文件还可以是一个操作的名称，称为伪目标</p><p><code>prerequisites</code> 表示条件，即要创建target所需的文件 (可以是多个 通过空格隔开 )，也可以是伪目标</p><p><code>tab </code> 第二行要输入一个Tab键</p><p><code>commands</code> 表示能在终端执行的命令</p><p>示例</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">a.txt: b.txt c.txt</span></span><br><span class="line">    cat b.txt c.txt &gt; a.txt</span><br><span class="line"><span class="comment"># 要创建a必须要b和c </span></span><br><span class="line"><span class="comment"># Tab键后面更命令</span></span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: build</span></span><br><span class="line"><span class="section">build: b.txt c.txt</span></span><br><span class="line">    cat b.txt c.txt &gt; a.txt</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 这里的build就是一个伪目标</span></span><br><span class="line"><span class="comment"># Tab键后面更命令</span></span><br><span class="line"><span class="comment"># 为了防止正好有一个名为build的文件 导致make命令误认为build文件已存在，而不执行</span></span><br><span class="line"><span class="comment"># 可以通过 .PHONY明确声明build是一个伪目标</span></span><br></pre></td></tr></table></figure><p>make命令默认会根据当前目录的Makefile去进行编译构建，也可以通过-f指定文件。</p><p>make 默认只会执行Makefile中的第一个目标</p><p>通过 make target 执行指定规则 </p><p>正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）,可以通过命令前加@符号，取消打印。</p><p>make</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令中的注释也会被打印</span></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">    @<span class="comment"># 这是测试</span></span><br><span class="line">    @echo TODO</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Makefile由一条或多条规则构成。每条规则格式如下&lt;/p&gt;
&lt;figure class=&quot;highlight makefile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;target&amp;gt; : &amp;lt;prerequisites&amp;gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[tab]  &amp;lt;commands&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Makefile" scheme="https://cwww3.github.io/tags/Makefile/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://cwww3.github.io/2021/05/26/hello-world/"/>
    <id>https://cwww3.github.io/2021/05/26/hello-world/</id>
    <published>2021-05-26T02:22:03.000Z</published>
    <updated>2021-05-26T02:22:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><span id="more"></span><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&amp;quot;My New Post&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>背包问题</title>
    <link href="https://cwww3.github.io/2021/05/08/knapsack/"/>
    <id>https://cwww3.github.io/2021/05/08/knapsack/</id>
    <published>2021-05-08T15:27:01.000Z</published>
    <updated>2021-05-26T02:22:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210508233256021.png" alt="image-20210508233256021"></p><p>背包问题是动态规划问题。</p><span id="more"></span><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p>由上图可知，01背包的物品个数只有1，要么选，要么不选。</p><p>有N件物品和⼀个最多能被重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能⽤⼀次，求解将哪些物品装⼊背包⾥物品价值总和最⼤。</p><p>如果通过暴力解法去解，则要将所有的情况列出来，即每个物品都有两种可能，取或不去。所以有2的n次方种情况，n代表物品的件数。</p><p>时间复杂度就是O(2^n)。</p><p><strong>采用动态规划进行优化</strong></p><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><p>假设 背包最⼤重量为4，物品为：</p><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><ol><li>确定dp数组以及下标的含义</li></ol><p>定义<strong>dp[i][j]</strong> 表示从下标为 <strong>[0-i]<strong>的物品⾥任意取，放进容量为</strong>j</strong>的背包，价值总和最⼤是多少。</p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210508234909469.png" alt="image-20210508234909469" style="zoom:50%;" /><ol start="2"><li>确定递推公式</li></ol><p>有两个⽅向推出来dp[i][j]</p><ul><li><p>不选择下标为i的物品    由dp[i - 1][j]推出，  dp[i][j] = dp[i - 1][j]</p></li><li><p>选择下标为i的物品  由dp[i - 1][j - weight[i]]推出  dp[i][j] = dp[i][j] = dp[i - 1][j - weight[i]] + value[i]</p></li></ul><p>递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</p><ol start="3"><li> dp数组如何初始化</li></ol><p><strong>关于初始化，⼀定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。</strong></p><p>⾸先从dp[i][j]的定义触发，如果背包容量j为0的话，即dp[i][0]，⽆论是选取哪些物品，背包价值总和⼀定为0。如图：</p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210508235958966.png" alt="image-20210508235958966" style="zoom:50%;" /><p> i是由i-1推导的，当i为0时⼀定要初始化。</p><p>dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最⼤价值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 倒叙遍历 保证物品被使用一次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = bagWeight; j &gt;= weight[<span class="number">0</span>]; j--) &#123;</span><br><span class="line"> dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - weight[<span class="number">0</span>]] + value[<span class="number">0</span>]; <span class="comment">// 初始化i为0时候的情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正序遍历 dp[0][j - weight[0]]中可能已经加了 value[0]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = weight[<span class="number">0</span>]; j &lt;= bagWeight; j++) &#123;</span><br><span class="line"> dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - weight[<span class="number">0</span>]] + value[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dp数组初始化情况:</p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210509000854888.png" alt="image-20210509000854888" style="zoom:50%;" /><p>其他下标应该初始化多少呢？dp[i][j]在推导的时候⼀定是取价值最⼤的数，如果题⽬给的价值都是正整数那么⾮0下标都初始化为0就</p><p>可以了，因为0就是最⼩的了，不会影响取最⼤价值的结果。如果题⽬给的价值有负数，那么⾮0下标就要初始化为负⽆穷了。</p><ol start="4"><li>确定遍历顺序</li></ol><p>可以看出，有两个遍历的维度：物品与背包重量。应该先遍历哪个？其实都可以！！ 但是先遍历物品更好理解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先遍历物品</span></span><br><span class="line"><span class="comment">// weight数组的⼤⼩ 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= bagWeight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line"> <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j]; <span class="comment">// 容量不够-&gt;不选</span></span><br><span class="line"> <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先遍历背包重量</span></span><br><span class="line"><span class="comment">// weight数组的⼤⼩ 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= bagWeight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line"> <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"> <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>举例推导dp数组</li></ol><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210509002110466.png" alt="image-20210509002110466" style="zoom:50%;" /><p>最终结果就是dp[2][4]。</p><p><strong>做动态规划的题⽬，最好的过程就是⾃⼰在纸上举⼀个例⼦把对应的dp数组的数值推导⼀下，然后在动⼿写代码！</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> w = <span class="number">4</span></span><br><span class="line">weight := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">value := []<span class="keyword">int</span>&#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(weight))</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dp); i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, w+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> j := w; j &gt;= weight[<span class="number">0</span>]; j-- &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-weight[<span class="number">0</span>]] + value[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= w; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> weight[i] &gt; j &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weight[i]]+value[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(dp[<span class="built_in">len</span>(weight)<span class="number">-1</span>][w])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt;= b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一维数组-滚动数组"><a href="#一维数组-滚动数组" class="headerlink" title="一维数组(滚动数组)"></a>一维数组(滚动数组)</h4><p>对于背包问题其实状态都是可以压缩的。</p><p>在使⽤⼆维数组的时候，递推公式：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]</p><p>如果把 <strong>dp[i - 1]</strong> 那⼀层拷⻉到 <strong>dp[i]</strong> 上，表达式完全可以是：<strong>dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i])</strong> </p><p>这样就可以用一维数组表示。这就是滚动数组的由来，需要满⾜的条件是上⼀层可以重复利⽤，直接拷⻉到当前层。</p><p>动规五部曲分析如下：</p><ol><li>确定dp数组的定义</li></ol><p>在⼀维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最⼤为dp[j]。</p><ol start="2"><li>⼀维dp数组的递推公式</li></ol><p>dp[j] 表示 容量为j的背包所背的最⼤价值，那么如何推导dp[j]呢？</p><p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最⼤价值。</p><p>此时dp[j]有两个选择，⼀个是取⾃⼰dp[j]，⼀个是取dp[j - weight[i]] + value[i]，这就要看谁大了。</p><p>所以递归公式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure><ol start="3"><li>⼀维dp数组如何初始化</li></ol><p><strong>关于初始化，⼀定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。</strong></p><p>dp[j]表示：容量为j的背包，所背的物品价值可以最⼤为dp[j]。</p><p>那么dp[0]就应该是0，因为背包容量为0,所背的物品的最⼤价值就是0。</p><p>其他下标初始化。根据题目要求选择合适的值。</p><ol start="4"><li>⼀维dp数组遍历顺序</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line"> dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这⾥和⼆维dp的写法中，遍历背包的顺序是不⼀样的！</strong></p><p>⼆维dp遍历的时候，背包容量是从⼩到⼤，⽽⼀维dp遍历的时候，背包是从⼤到⼩。</p><p>⼀维<strong>dp</strong>数组的背包在遍历顺序上和⼆维其实是有很⼤差异的！，这⼀点⼀定要注意。</p><ol start="5"><li>举例推导dp数组</li></ol><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210509004924306.png" alt="image-20210509004924306" style="zoom:50%;" /><p>⼀维dp 的01背包，要⽐⼆维简洁的多！ 初始化 和 遍历顺序相对简单了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> w = <span class="number">4</span></span><br><span class="line">weight := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">value := []<span class="keyword">int</span>&#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, w+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化 dp[0]=0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := w; j &gt;= weight[i]; j-- &#123;</span><br><span class="line">dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(dp[w])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt;= b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ol><li><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">分割等和⼦集</a></li></ol><p>只要找到集合⾥能够出现 sum / 2 的⼦集总和，就算是可以分割成两个相同元素和⼦集了。</p><p><strong>转换为背包问题</strong>  </p><p>根据题目设定可知：</p><ul><li>背包的体积w为sum / 2 且不大于10000</li><li>背包要放⼊的商品（集合⾥的元素）重量为 元素的数值，价值也为元素的数值 , 即 nums=weight=value</li><li>背包<strong>正好装满</strong>，说明找到了总和为w 的⼦集。即dp[w] == w  （前提 num%2==0）</li><li>背包中每⼀个元素是不可重复放⼊。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canPartition</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">sum += num</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果是奇数 肯定不会相等</span></span><br><span class="line"><span class="keyword">if</span> sum%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w := sum / <span class="number">2</span></span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, w+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := w; j &gt;= nums[i]; j-- &#123;</span><br><span class="line">dp[j] = max(dp[j], dp[j-nums[i]]+nums[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> dp[w] == w &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt;= b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">最后⼀块⽯头的重量 <strong>II</strong></a></li></ol><p>本题其实就是<strong>尽量</strong>让⽯头分成重量相同的两堆，相撞之后剩下的⽯头最⼩，与上题类似，在最后的处理上有所不同。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lastStoneWeightII</span><span class="params">(stones []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> stones &#123;</span><br><span class="line">sum += num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w := sum / <span class="number">2</span></span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, w+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(stones); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := w; j &gt;= stones[i]; j-- &#123;</span><br><span class="line">dp[j] = max(dp[j], dp[j-stones[i]]+stones[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dp[w] &lt;= w</span></span><br><span class="line"><span class="keyword">return</span> sum - dp[w] - dp[w]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt;= b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>完全背包和<strong>01</strong>背包问题唯⼀不同的地⽅就是，每种物品有⽆限件。</p><p>01背包和完全背包唯⼀不同就是体现在<strong>遍历顺序</strong>上，所以直接针对遍历顺序经⾏分析！</p><p>我们知道01背包内嵌的循环是<strong>从⼤到⼩遍历</strong>，为了保证每个物品仅被添加⼀次。</p><p>⽽完全背包的物品是<strong>可以添加多次的，所以要从⼩到⼤去遍历</strong>，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先遍历物品，再遍历背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = weight[i]; j &lt; bagWeight ; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210509113830415.png" alt="image-20210509113830415" style="zoom:50%;" /><p><strong>为什么遍历物品在外层循环，遍历背包容量在内层循环？</strong></p><p>01背包中</p><ul><li>⼆维dp数组的两个for遍历的先后循序是可以颠倒的</li><li>⼀维dp数组的两个for循环先后循序⼀定是先遍历物品，再遍历背包容量。</li></ul><p>在完全背包中，</p><ul><li>对于⼀维<strong>dp</strong>数组来说，其实两个<strong>for</strong>循环嵌套顺序同样⽆所谓！</li></ul><p><strong>因为dp[j] 是根据 下标j之前所对应的dp[j]计算出来的。 只要保证下标j之前的dp[j]都是经过计算的就可以了。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一维数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> w = <span class="number">4</span></span><br><span class="line">weight := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">value := []<span class="keyword">int</span>&#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, w+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := weight[i]; j &lt;= w; j++ &#123;</span><br><span class="line">dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(dp[w])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> w = <span class="number">4</span></span><br><span class="line">weight := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">value := []<span class="keyword">int</span>&#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(weight))</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dp); i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, w+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正序</span></span><br><span class="line"><span class="keyword">for</span> j := weight[<span class="number">0</span>]; j &lt;= w; j++ &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = j / weight[<span class="number">0</span>] * value[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= w; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j &lt; weight[i] &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weight[i]]+value[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(dp[<span class="built_in">len</span>(weight)<span class="number">-1</span>][w])</span><br><span class="line">fmt.Println(dp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><ol><li><a href="https://leetcode-cn.com/problems/coin-change-2/">零钱兑换 <strong>II</strong></a></li></ol><p>本题和纯完全背包不⼀样，纯完全背包是能否凑成总⾦额，⽽本题是要求凑成总⾦额的个数！</p><p>注意题⽬描述中是凑成总⾦额的硬币<strong>组合数</strong> </p><p><strong>求组合数还是排列数 会影响遍历的顺序</strong></p><p>动态规划五部曲:</p><ol><li><p>确定dp数组以及下标的含义</p><p>dp[j]：凑成总⾦额j的货币组合数为dp[j]</p></li><li><p> 确定递推公式</p></li></ol><p>   由原来组合方式的基础上 加上 加入当前硬币后新增的方式</p><p>   dp[j] = dp[j] + dp[j - coins[i]]</p><ol start="3"><li>dp数组如何初始化</li></ol><p>⾸先dp[0]⼀定要为1，dp[0] = 1的含义是凑成总⾦额0的货币组合数为1。</p><ol start="4"><li> 确定遍历顺序</li></ol><p>本题中是外层for循环遍历物品（钱币），内层for遍历背包（⾦钱总额），还是外层for遍历背包（⾦钱总额），内层for循环遍历物品（钱币）呢？</p><p>上文讲过完全背包的两个for循环的先后顺序都是可以，<strong>但本题就不⾏了！</strong></p><p>因为纯完全背包求得是能否凑成总和，和<strong>凑成总和的元素有没有顺序没关系</strong>，即：有顺序也⾏，没有顺序也⾏！</p><p>⽽本题要求凑成总和的<strong>组合数</strong>，元素之间<strong>要求没有顺序</strong>。</p><p>如果先遍历物品再遍历容量，那么是在第一个物品遍历完后，再遍历另一种物品。这样能保证顺序是固定的(求组合)。</p><p>如果先遍历容量在遍历物品，那么顺序是不确定的(求排列)。</p><p><strong>建议动⼿把这两种⽅案的dp数组数值变化打印出来，对⽐看⼀看！（实践出真知）</strong></p><ol start="5"><li>举例推导dp数组</li></ol><p>输⼊: amount = 5, coins = [1, 2, 5] ，dp状态图如下：</p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210509214749962.png" alt="image-20210509214749962" style="zoom:50%;" /><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(amount <span class="keyword">int</span>, coins []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// dp[i] 表示 金额为i时 一共有几种组合方式</span></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 组合 --&gt; 要先遍历物品再遍历容量</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(coins); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j:=coins[i]; j&lt;=amount; j++ &#123;</span><br><span class="line">            <span class="comment">// 原来的组合方式数 + 加入该枚硬币后新增的组合数</span></span><br><span class="line">            dp[j] = dp[j] + dp[j-coins[i]] </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>多重背包与01背包和完全背包的区别在于，物品的是一个<strong>特定的值</strong>。</p><p>假如物品A的数量是2，把物品A当做两个独立的物品，那数量都是1，那么就转化为01背包问题了。</p><p>时间复杂度：O(m * n * k) m：物品种类个数，n背包容量，k单类物品数量</p><ol><li><p>构建一个新的weight数组和value数组</p></li><li><p>直接在2层for循环中再加一个循环</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> w = <span class="number">10</span></span><br><span class="line">weight := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">value := []<span class="keyword">int</span>&#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">nums := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, w+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化 dp[0]=0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := w; j &gt;= weight[i]; j-- &#123;</span><br><span class="line"><span class="comment">// 以上为01背包，然后加⼀个遍历个数</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="number">1</span>; k &lt;= nums[i] &amp;&amp; (j-k*weight[i]) &gt;= <span class="number">0</span>; k++ &#123; <span class="comment">//遍历个数</span></span><br><span class="line">dp[j] = max(dp[j], dp[j-k*weight[i]]+k*value[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(dp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fmt.Println(dp)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>还有那种⼆进制优化的⽅法，其实就是把每种物品的数量，打包成⼀个个独⽴的包。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210508233256021.png&quot; alt=&quot;image-20210508233256021&quot;&gt;&lt;/p&gt;
&lt;p&gt;背包问题是动态规划问题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://cwww3.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Order By 执行流程</title>
    <link href="https://cwww3.github.io/2021/05/08/mysql-order-by/"/>
    <id>https://cwww3.github.io/2021/05/08/mysql-order-by/</id>
    <published>2021-05-07T17:48:46.000Z</published>
    <updated>2021-05-26T02:22:03.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `city` varchar(16) NOT NULL,</span><br><span class="line">  `name` varchar(16) NOT NULL,</span><br><span class="line">  `age` int(11) NOT NULL,</span><br><span class="line">  `addr` varchar(128) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `city` (`city`)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select city,name,age from t where city=&#x27;杭州&#x27; order by name limit 1000  ;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h3><p>为避免全表扫描，我们需要在 city 字段加上索引。用 explain 命令来看看这个语句。</p><p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/826579b63225def812330ef6c344a303.png" alt="img"></p><p>Extra 这个字段中的“Using filesort”表示的就是需要排序，MySQL 会给每个线程分配一块内存用于排序，称为 <strong>sort_buffer</strong>。</p><p>examined_rows=4000，表示参与排序的行数是 4000 行。</p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210508003711460.png" alt="image-20210508003711460" style="zoom:50%;" /><p>从图中可以看到，满足 city=’杭州’条件的行，是从 ID_X 到 ID_(X+N) 的这些记录。</p><p>通常情况下，这个语句执行流程如下所示 ：</p><ol><li>初始化 sort_buffer，确定放入 name、city、age 这三个字段；</li><li>从索引 city 找到第一个满足 city=’杭州’条件的主键 id，也就是图中的 ID_X；</li><li>到主键 id 索引取出整行，取 name、city、age 三个字段的值，存入 sort_buffer 中；</li><li>从索引 city 取下一个记录的主键 id；</li><li>重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的 ID_Y；</li><li>对 sort_buffer 中的数据按照字段 name 做快速排序；</li><li>按照排序结果取前 1000 行返回给客户端。</li></ol><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210508003901677.png" alt="image-20210508003901677" style="zoom:50%;" /><p>图中“按 name 排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数 <strong>sort_buffer_size</strong>。</p><p>sort_buffer_size，就是 MySQL 为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。外部排序一般使用<strong>归并排序</strong>算法(多个临时文件分别排序)。</p><h3 id="rowid-排序"><a href="#rowid-排序" class="headerlink" title="rowid 排序"></a>rowid 排序</h3><p>在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在 sort_buffer 和临时文件中执行的。但这个算法有一个问题，就是如果<strong>查询要返回的字段很多</strong>的话，那么 sort_buffer 里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。</p><p><strong>如果 MySQL 认为排序的单行长度太大会怎么做呢？</strong></p><p>修改一个参数，让 MySQL 采用另外一种算法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET max_length_for_sort_data = 16;</span><br><span class="line">-- 专门控制用于排序的行数据的长度的一个参数。如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法。</span><br></pre></td></tr></table></figure><p>city、name、age 这三个字段的定义总长度是 36，把 max_length_for_sort_data 设置为 16，再来看看计算过程有什么改变。</p><p>新的算法放入 sort_buffer 的字段，只有要<strong>排序的列</strong>（即 name 字段）和<strong>主键 id</strong>。但这时，排序的结果就因为少了 city 和 age 字段的值，不能直接返回了。流程如下：</p><ol><li>初始化 sort_buffer，确定放入两个字段，即 name 和 id；</li><li>从索引 city 找到第一个满足 city=’杭州’条件的主键 id，也就是图中的 ID_X；</li><li>到主键 id 索引取出整行，取 name、id 这两个字段，存入 sort_buffer 中；</li><li>从索引 city 取下一个记录的主键 id；</li><li>重复步骤 3、4 直到不满足 city=’杭州’条件为止，也就是图中的 ID_Y；</li><li>对 sort_buffer 中的数据按照字段 name 进行排序；</li><li>遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。</li></ol><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210508005237006.png" alt="image-20210508005237006" style="zoom:50%;" /><p>对比全字段排序会发现，rowid 排序多访问了一次表 t 的主键索引，就是步骤 7。</p><p>需要说明的是，最后的“结果集”是一个<strong>逻辑概念</strong>，实际上 MySQL 服务端从排序后的 sort_buffer 中依次取出 id，然后到原表查到 city、name 和 age 这三个字段的结果，不需要在服务端再耗费内存存储结果，是直接返回给客户端的。</p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>如果 MySQL 实在是担心排序内存太小，会影响排序效率，才会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</p><p>如果 MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</p><p>体现了 MySQL 的一个设计思想：<strong>如果内存够，就要多利用内存，尽量减少磁盘访问</strong>。</p><p>对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。</p><p>其实，并不是所有的 order by 语句，都需要排序操作的。从上面分析的执行过程，我们可以看到，MySQL 之所以需要生成临时表，并且在临时表上做排序操作，<strong>其原因是原来的数据都是无序的</strong>。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>如果能够保证从 city 这个索引上取出来的行，天然就是按照 name 递增排序的话，就可以不用再排序了。</p><p>所以，可以在这个市民表上创建一个 city 和 name 的<strong>联合索引</strong>。这样整个查询过程的流程就变成了：</p><ol><li>从索引 (city,name) 找到第一个满足 city=’杭州’条件的主键 id；</li><li>到主键 id 索引取出整行，取 name、city、age 三个字段的值，作为结果集的一部分直接返回；</li><li>从索引 (city,name) 取下一个记录主键 id；</li><li>重复步骤 2、3，直到查到第 1000 条记录，或者是不满足 city=’杭州’条件时循环结束。</li></ol><p><strong>进一步优化</strong></p><p>利用覆盖索引 创建一个 city、name 和 age 的联合索引，这样就不需要再回到主键索引上去取数据。(省去步骤2)</p><p>通过explain分析</p><p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/9e40b7b8f0e3f81126a9171cc22e3423.png" alt="img"></p><p>Extra 字段里面多了“Using index”，表示的就是使用了覆盖索引，性能上会快很多。</p><p>当然，这里并不是说要为了每个查询能用上覆盖索引，就要把语句中涉及的字段都建上联合索引，毕竟索引还是有维护代价的。这是一个需要<strong>权衡</strong>的决定。</p><h3 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h3><p>场景： 在一个存储单词且有10000条记录的表中随机取出三个单词</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select word from words order by rand() limit 3;</span><br></pre></td></tr></table></figure><p>explain 命令看看这个语句的执行情况</p><p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/59a4fb0165b7ce1184e41f2d061ce350.png" alt="img"></p><p>Extra 字段显示 Using temporary，表示的是需要使用临时表；Using filesort，表示的是需要执行排序操作。</p><p><strong>对于临时内存表的排序来说，它会选择哪一种算法呢？</strong></p><p>之前的结论：对于 InnoDB 表来说，执行全字段排序会减少磁盘访问，因此会被优先选择。</p><p><strong>对于内存表，回表过程只是简单地根据数据行的位置，直接访问内存得到数据，根本不会导致多访问磁盘。</strong>优化器没有了这一层顾虑，那么它会优先考虑的，就是用于排序的行越小越好了，所以，MySQL 这时就会选择 rowid 排序。</p><p>这条语句的执行流程是这样的：</p><ol><li>创建一个临时表。这个临时表使用的是 memory 引擎，表里有两个字段，第一个字段是 double 类型，为了后面描述方便，记为字段 R，第二个字段是 varchar(64) 类型，记为字段 W。并且，这个表没有建索引。</li><li>从 words 表中，按主键顺序取出所有的 word 值。对于每一个 word 值，调用 rand() 函数生成一个大于 0 小于 1 的随机小数，并把这个随机小数和 word 分别存入临时表的 R 和 W 字段中，到此，扫描行数是 10000。</li><li>现在临时表有 10000 行数据了，接下来要在这个没有索引的内存临时表上，按照字段 R 排序。</li><li>初始化 sort_buffer。sort_buffer 中有两个字段，一个是 double 类型，另一个是整型。</li><li>从内存临时表中一行一行地取出 R 值和位置信息（后面会和你解释这里为什么是“位置信息”），分别存入 sort_buffer 中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加 10000，变成了 20000。</li><li>在 sort_buffer 中根据 R 的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫描行数。</li><li>排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出 word 值，返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了 20003。</li></ol><p>通过慢查询日志（slow log）来验证一下分析得到的扫描行数是否正确。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Query_time: 0.900376 Lock_time: 0.000347 Rows_sent: 3 Rows_examined: 20003</span><br><span class="line">SET timestamp=1541402277;</span><br><span class="line">select word from words order by rand() limit 3;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210508012334810.png" alt="image-20210508012334810" style="zoom:50%;" /><p>图中的 pos 就是位置信息，这里的“位置信息”是个什么概念？</p><p>回到一个基本概念：<strong>MySQL 的表是用什么方法来定位“一行数据”的。</strong></p><p>rowid 表示的是：每个引擎用来唯一标识数据行的信息。</p><ul><li>对于有主键的 InnoDB 表来说，这个 rowid 就是主键 ID；</li><li>对于没有主键的 InnoDB 表来说，这个 rowid 就是由系统生成的；</li><li>MEMORY 引擎不是索引组织表。在这个例子里面，可以认为它就是一个数组。因此，这个 rowid 其实就是数组的下标。</li></ul><p><strong>order by rand() 使用了内存临时表，内存临时表排序的时候使用了 rowid 排序方法。</strong></p><h3 id="磁盘临时表"><a href="#磁盘临时表" class="headerlink" title="磁盘临时表"></a>磁盘临时表</h3><p>是不是所有的临时表都是内存表呢？</p><p>tmp_table_size 这个配置限制了内存临时表的大小，默认值是 16M。如果临时表大小超过了 tmp_table_size，那么内存临时表就会转成磁盘临时表。</p><p>磁盘临时表使用的引擎默认是 InnoDB，是由参数 internal_tmp_disk_storage_engine 控制的。</p><p>为了复现这个过程，把 tmp_table_size 设置成 1024，把 sort_buffer_size 设置成 32768, 把 max_length_for_sort_data 设置成 16。</p><p>发现这个 SQL 语句的排序没有用到临时文件，原因是 MySQL 5.6 版本引入的一个新的排序算法，即：优先队列排序算法。(因为只娶了3条，没必要对所有的数据进行归并排序)</p>]]></content>
    
    
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CREATE TABLE `t` (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `id` int(11) NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `city` varchar(16) NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `name` varchar(16) NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `age` int(11) NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `addr` varchar(128) DEFAULT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  PRIMARY KEY (`id`),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  KEY `city` (`city`)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) ENGINE=InnoDB;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;select city,name,age from t where city=&amp;#x27;杭州&amp;#x27; order by name limit 1000  ;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="MySql" scheme="https://cwww3.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>索引(二)</title>
    <link href="https://cwww3.github.io/2021/05/06/mysql-index2/"/>
    <id>https://cwww3.github.io/2021/05/06/mysql-index2/</id>
    <published>2021-05-06T15:58:36.000Z</published>
    <updated>2021-05-26T02:22:03.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>对于普通索引来说，查找到满足条件的第一个记录后，需要查找下一个记录，直到碰到第一个不满足条件的记录。</p><p>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</p><span id="more"></span><p>这个不同带来的性能差距会有多少呢？答案是，微乎其微。InnoDB 的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB。</p><p>因为引擎是按页读写的，所以说，当找到满足条件的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。(如果这条记录正好是该页的最后一条记录，就需要读取下一个数据页)</p><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>为了说明普通索引和唯一索引对更新语句性能的影响这个问题，首先介绍一下 change buffer。</p><p>当需要更新一个数据页时，如果数据页在内存中就直接更新。而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些<strong>更新操作缓存在 change buffer</strong> 中，这样就不需要从磁盘中读入这个数据页了。在<strong>下次查询</strong>需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p><p>需要说明的是，虽然名字叫作 change buffer，实际上它是可以持久化的数据。也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上。</p><p>将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 <strong>merge</strong>。</p><p><strong>访问</strong>这个数据页会触发 merge 外，系统有<strong>后台线程</strong>会定期 merge。在数据库<strong>正常关闭</strong>的过程中，也会执行 merge 操作。</p><p>显然，如果能够将更新操作先记录在 change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，<strong>数据读入内存是需要占用 buffer pool 的</strong>，所以这种方式还能够避免占用内存，提高内存利用率。</p><h5 id="什么条件下可以使用-change-buffer-呢？"><a href="#什么条件下可以使用-change-buffer-呢？" class="headerlink" title="什么条件下可以使用 change buffer 呢？"></a>什么条件下可以使用 change buffer 呢？</h5><p>对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束，而且要将数据页读入内存才能判断。如果都<strong>已经读入到内存</strong>了，那直接更新内存会更快，就没必要使用 change buffer 了。因此，唯一索引的更新就不能使用 change buffer，实际上也只有<strong>普通索引</strong>可以使用。</p><p><strong>change buffer 用的是 buffer pool 里的内存</strong>，因此不能无限增大。change buffer 的大小，可以通过参数 <code>innodb_change_buffer_max_size</code> 来动态设置。</p><h5 id="InnoDB-的处理流程"><a href="#InnoDB-的处理流程" class="headerlink" title="InnoDB 的处理流程"></a>InnoDB 的处理流程</h5><p>如果记录要更新的目标页在内存中</p><ul><li>对于唯一索引来说，找到 对应的位置，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，找到 对应的位置，插入这个值，语句执行结束。</li></ul><p>如果记录要更新的目标页不在内存中</p><ul><li>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。</li></ul><p>将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p><p>change buffer 适合<strong>写多读少</strong>的场景。因为 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 merge 之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。对于写入之后马上会做查询的场景，随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。</p><h5 id="change-buffer-和-redo-log"><a href="#change-buffer-和-redo-log" class="headerlink" title="change buffer 和 redo log"></a>change buffer 和 redo log</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into t(id,k) values(id1,k1),(id2,k2);</span><br></pre></td></tr></table></figure><p>假设当前 k 索引树的状态，查找到位置后，k1 所在的数据页在内存 (InnoDB buffer pool) 中，k2 所在的数据页不在内存中。下图所示是带 change buffer 的更新状态图。</p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210506225125817.png" alt="image-20210506225125817" style="zoom:50%;" /><p>分析这条更新语句，涉及了四个部分：内存、redo log（ib_log_fileX）、 数据表空间（t.ibd）、系统表空间（ibdata1）。</p><ol><li><p>Page 1 在内存中，直接更新内存；</p></li><li><p>Page 2 没有在内存中，就在内存的 change buffer 区域，记录下“我要往 Page 2 插入一行”这个信息</p></li><li><p>将上述两个动作记入 redo log 中（图中 3 和 4）</p></li></ol><p>之后的读请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where k in (k1, k2)</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210506225600762.png" alt="image-20210506225600762" style="zoom:50%;" /><p>如果读语句发生在更新语句后不久，内存中的数据都还在，那么此时的这两个读操作就与系统表空间（ibdata1）和 redo log（ib_log_fileX）无关了。</p><ol><li>读 Page 1 的时候，直接从内存返回。</li><li>要读 Page 2 的时候，需要把 Page 2 从磁盘读入内存中，然后应用 change buffer 里面的操作日志，生成一个正确的版本并返回结果。</li></ol><p><strong>redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗。</strong></p><h3 id="字符串字段加索引"><a href="#字符串字段加索引" class="headerlink" title="字符串字段加索引"></a>字符串字段加索引</h3><p>假设，现在维护一个支持邮箱登录的系统，用户表是这么定义的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table SUser(ID bigint unsigned primary key,email varchar(64), ... )engine=innodb;</span><br></pre></td></tr></table></figure><p>由于要使用邮箱登录，所以业务代码中一定会出现类似于这样的语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select f1, f2 from SUser where email=&#x27;xxx&#x27;;</span><br></pre></td></tr></table></figure><p>如果 email 这个字段上没有索引，那么这个语句就只能做全表扫描。</p><p>MySQL 是支持<strong>前缀索引</strong>的，也就是说，你可以定义字符串的一部分作为索引。默认地，如果你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 第一个语句创建的 index1 索引里面，包含了每个记录的整个字符串；</span><br><span class="line">mysql&gt; alter table SUser add index index1(email);</span><br><span class="line">-- 第二个语句创建的 index2 索引里面，对于每个记录都是只取前 6 个字节。</span><br><span class="line">mysql&gt; alter table SUser add index index2(email(6));</span><br></pre></td></tr></table></figure><p>由于 email(6) 这个索引结构中每个邮箱字段都只取前 6 个字节，所以占用的空间会更小，这就是使用前缀索引的优势。但，这同时带来的损失是，可能会增加额外的记录扫描次数。</p><p>看看下面这个语句，在这两个索引定义下分别是怎么执行的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,name,email from SUser where email=&#x27;zhangssxyz@xxx.com&#x27;;</span><br></pre></td></tr></table></figure><p>如果使用的是 index1</p><ol><li>从 index1 索引树找到满足索引值是’<a href="mailto:&#x7a;&#x68;&#97;&#110;&#103;&#115;&#x73;&#x78;&#x79;&#x7a;&#x40;&#x78;&#120;&#120;&#46;&#99;&#111;&#109;">&#x7a;&#x68;&#97;&#110;&#103;&#115;&#x73;&#x78;&#x79;&#x7a;&#x40;&#x78;&#120;&#120;&#46;&#99;&#111;&#109;</a>’的这条记录，取得 ID2 的值；</li><li>到主键上查到主键值是 ID2 的行，判断 email 的值是正确的，将这行记录加入结果集；</li><li>取 index1 索引树上刚刚查到的位置的下一条记录，发现已经不满足 email=‘<a href="mailto:&#x7a;&#104;&#97;&#x6e;&#103;&#x73;&#115;&#120;&#x79;&#x7a;&#x40;&#120;&#120;&#120;&#46;&#99;&#x6f;&#109;">&#x7a;&#104;&#97;&#x6e;&#103;&#x73;&#115;&#120;&#x79;&#x7a;&#x40;&#120;&#120;&#120;&#46;&#99;&#x6f;&#109;</a>’的条件了，循环结束。</li></ol><p>如果使用的是 index2</p><ol><li>从 index2 索引树找到满足索引值是’zhangs’的记录，找到的第一个是 ID1；</li><li>到主键上查到主键值是 ID1 的行，判断出 email 的值不是’<a href="mailto:&#122;&#104;&#x61;&#x6e;&#x67;&#115;&#115;&#120;&#x79;&#122;&#x40;&#120;&#x78;&#120;&#x2e;&#x63;&#111;&#109;">&#122;&#104;&#x61;&#x6e;&#x67;&#115;&#115;&#120;&#x79;&#122;&#x40;&#120;&#x78;&#120;&#x2e;&#x63;&#111;&#109;</a>’，这行记录丢弃；</li><li>取 index2 上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出 ID2，再到 ID 索引上取整行然后判断，这次值对了，将这行记录加入结果集；</li><li>重复上一步，直到在 idxe2 上取到的值不是’zhangs’时，循环结束。</li></ol><p><strong>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</strong></p><p>在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。</p><p><strong>前缀索引的影响不止如此</strong>，我们再看一下另外一个场景。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,email from SUser where email=&#x27;zhangssxyz@xxx.com&#x27;;</span><br></pre></td></tr></table></figure><p>如果使用 index1，可以利用<strong>覆盖索引</strong>，从 index1 查到结果后直接就返回了，不需要回到 ID 索引再去查一次。</p><p>如果使用 index2，就不得不回到 ID 索引再去判断 email 字段的值。</p><p>即使你将 index2 的定义修改为 email(18) 的前缀索引，这时候虽然 index2 已经包含了所有的信息，但 InnoDB 还是要回到 id 索引再查一下，因为系统并不确定前缀索引的定义是否截断了完整信息。<strong>使用前缀索引就用不上覆盖索引对查询性能的优化</strong></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;唯一索引&quot;&gt;&lt;a href=&quot;#唯一索引&quot; class=&quot;headerlink&quot; title=&quot;唯一索引&quot;&gt;&lt;/a&gt;唯一索引&lt;/h3&gt;&lt;h4 id=&quot;查询&quot;&gt;&lt;a href=&quot;#查询&quot; class=&quot;headerlink&quot; title=&quot;查询&quot;&gt;&lt;/a&gt;查询&lt;/h4&gt;&lt;p&gt;对于普通索引来说，查找到满足条件的第一个记录后，需要查找下一个记录，直到碰到第一个不满足条件的记录。&lt;/p&gt;
&lt;p&gt;对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MySql" scheme="https://cwww3.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>MySql锁</title>
    <link href="https://cwww3.github.io/2021/04/29/mysql-lock/"/>
    <id>https://cwww3.github.io/2021/04/29/mysql-lock/</id>
    <published>2021-04-28T16:40:31.000Z</published>
    <updated>2021-05-26T02:22:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>数据库锁设计的初衷是处理并发问题。</p><p>根据加锁的范围，MySQL 里面的锁大致可以分成<strong>全局锁</strong>、<strong>表级锁</strong>和<strong>行锁</strong>三类。</p><span id="more"></span><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是<code> Flush tables with read lock</code> (FTWRL)。</p><p>其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p><p><strong>全局锁的典型使用场景是，做全库逻辑备份</strong>。但是让整库都只读，听上去就很危险：</p><ul><li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</li><li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。</li></ul><p>不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致的。</p><p>说到视图，其实是有一个方法能够拿到一致性视图的，在可重复读隔离级别下开启一个事务。</p><p>官方自带的逻辑备份工具是 <strong>mysqldump</strong>。当 mysqldump 使用参数–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。</p><p>有了这个功能，为什么还需要 FTWRL 呢？<strong>一致性读是好，但前提是引擎要支持这个隔离级别。</strong></p><p>既然要全库只读，为什么不使用 <code>set global readonly=true</code> 的方式呢？ 两个原因：</p><ul><li>一是，在有些系统中，readonly 的值会被用来做其他逻辑，比如用来<strong>区分是主库和备库</strong>。</li><li>二是，在<strong>异常处理机制上</strong>有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</li></ul><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p><p><strong>表锁</strong>的语法是<code> lock tables … read/write</code>。与 FTWRL 类似，可以用<code> unlock tables</code> 主动释放锁，也可以在客户端断开的时候自动释放。</p><p>需要注意，<code>lock tables</code> 语法除了会限制别的线程的读写外，也<strong>限定了本线程</strong>接下来的操作对象。</p><p>举个例子, 如果在某个线程 A 中执行 <code>lock tables t1 read, t2 write;</code> 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。</p><p>同时，线程 A 在执行<code>unlock tables</code>之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。</p><p>在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。</p><p>而对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。</p><p><strong>另一类表级的锁是 MDL（metadata lock)。</strong>MDL 不需要显式使用，在访问一个表的时候会被<strong>自动加上</strong>。</p><p>MDL 的作用是，保证读写的正确性。想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p><p>因此，在 MySQL 5.5 版本中引入了 MDL，当对一个表做<strong>增删改查</strong>操作的时候，加 MDL 读锁；当要对表做<strong>结构变更</strong>操作的时候，加 <strong>MDL 写锁</strong>。</p><ul><li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</li><li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li></ul><p>虽然 MDL 锁是系统默认会加的，但却是你<strong>不能忽略</strong>的一个机制。</p><p>给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。即使是小表，操作不慎也会出问题。</p><p>假设表 t 是一个小表。（MySql5.6）</p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210428234401353.png" alt="image-20210428234401353" style="zoom:50%;" /><p>可以看到 session A 先启动，这时候会对表 t 加一个 MDL 读锁。由于 session B 需要的也是 MDL 读锁，因此可以正常执行。</p><p>之后 session C 会被 blocked，是因为 session A 的 MDL 读锁还没有释放，而 session C 需要 MDL 写锁，因此只能被阻塞。</p><p>如果只有 session C 自己被阻塞还没什么关系，但是<strong>之后所有要在表 t 上新申请 MDL 读锁的请求也会被 session C 阻塞</strong>。</p><p>申请MDL锁的操作会形成一个<strong>队列</strong>，队列中<strong>写锁获取优先级高于读锁</strong>。一旦出现写锁等待，不但当前操作会被阻塞，同时还会阻塞后续该表的所有操作。<strong>事务一旦申请到MDL锁后，直到事务执行完才会将锁释放</strong>。</p><p>如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。</p><p>讨论一个问题，<strong>如何安全地给小表加字段</strong>？</p><p>首先我们要<strong>解决长事务</strong>，事务不提交，就会一直占着 MDL 锁。在 MySQL 的 information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。</p><p>但考虑一下这个场景。如果要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而不得不加个字段，该怎么做呢？</p><p>这时候 kill 可能未必管用，因为新的请求马上就来了。比较理想的机制是，在 alter table 语句里面<strong>设定等待时间</strong>，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。</p><p>MariaDB 已经合并了 AliSQL 的这个功能，所以这两个开源分支目前都支持 DDL NOWAIT/WAIT n 这个语法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name NOWAIT add column ...</span><br><span class="line">ALTER TABLE tbl_name WAIT N add column ... </span><br></pre></td></tr></table></figure><p>备份一般都会在备库上执行，你在用–single-transaction 方法做逻辑备份的过程中，如果主库上的一个小表做了一个 DDL，比如给一个表上加了一列。这时候，从备库上会看到什么现象呢？</p><p>假设这个 DDL 是针对表 t1 的， 这里我把备份过程中几个关键的语句列出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Q1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line">Q2:START TRANSACTION  WITH CONSISTENT SNAPSHOT；</span><br><span class="line">/* other tables */</span><br><span class="line">Q3:SAVEPOINT sp;</span><br><span class="line">/* 时刻 1 */</span><br><span class="line">Q4:show create table `t1`;</span><br><span class="line">/* 时刻 2 */</span><br><span class="line">Q5:SELECT * FROM `t1`;</span><br><span class="line">/* 时刻 3 */</span><br><span class="line">Q6:ROLLBACK TO SAVEPOINT sp;</span><br><span class="line">/* 时刻 4 */</span><br><span class="line">/* other tables */</span><br></pre></td></tr></table></figure><p>在备份开始的时候，为了确保 RR（可重复读）隔离级别，再设置一次 RR 隔离级别 (Q1);</p><p>启动事务，这里用 WITH CONSISTENT SNAPSHOT 确保这个语句执行完就可以得到一个一致性视图（Q2)；</p><p>设置一个保存点，这个很重要（Q3）；</p><p><code>show create</code> 是为了拿到表结构 (Q4)，然后正式导数据 （Q5）</p><p>回滚到 SAVEPOINT sp，在这里的作用是释放 t1 的 MDL 锁 （Q6）。</p><ol><li>如果在 Q4 语句执行之前到达，现象：没有影响，备份拿到的是 <strong>DDL 后</strong>的表结构。</li><li>如果在“时刻 2”到达，则表结构被改过，Q5 执行的时候，报 Table definition has changed, please retry transaction，现象：mysqldump <strong>终止</strong>；</li><li>如果在“时刻 2”和“时刻 3”之间到达，mysqldump 占着 t1 的 MDL 读锁，binlog 被<strong>阻塞</strong>，现象：<strong>主从延迟</strong>，直到 Q6 执行完成。</li><li>从“时刻 4”开始，mysqldump 释放了 MDL 读锁，现象：没有影响，备份拿到的是 <strong>DDL 前</strong>的表结构。</li></ol><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>MySQL 的行锁是在引擎层由各个<strong>引擎自己实现</strong>的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁。</p><p>顾名思义，行锁就是针对数据表中行记录的锁。比如事务 A 更新了一行，而这时候事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更新。</p><p>当然，数据库中还有一些没那么一目了然的概念和设计，这些概念如果理解和使用不当，容易导致程序出现非预期行为，比如<strong>两阶段锁</strong>。</p><h4 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h4><p>举个例子。假设字段 id 是表 t 的主键。在下面的操作序列中，事务 B 的 update 语句执行时会是什么现象呢？</p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210429001500100.png" alt="image-20210429001500100" style="zoom:50%;" /><p>这个问题的结论取决于事务 A 在执行完两条 update 语句后，持有哪些锁，以及在什么时候释放。</p><p>事务 A 持有的两个记录的行锁，都是在 commit 的时候才释放的。</p><p>事务 B 的 update 语句会被阻塞，直到事务 A 执行 commit 之后，事务 B 才能继续执行。</p><p><strong>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p><p><strong>如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</strong></p><p>假设负责实现一个电影票在线交易业务，顾客 A 要在影院 B 购买电影票。这个业务需要涉及到以下操作：</p><ol><li>从顾客 A 账户余额中扣除电影票价；</li><li>给影院 B 的账户余额增加这张电影票价；</li><li>记录一条交易日志。</li></ol><p>要完成这个交易，需要 update 两条记录，并 insert 一条记录。为了保证交易的原子性，我们要把这三个操作放在一个事务中。</p><p>那么，怎样安排这三个语句在事务中的顺序呢？</p><p>试想如果同时有另外一个顾客 C 要在影院 B 买票，那么这两个事务<strong>冲突的部分就是语句 2</strong> 了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。</p><p>根据两阶段锁协议，不论你怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才释放的。</p><p>所以，如果<strong>把语句 2 安排在最后</strong>，比如按照 3、1、2 这样的顺序，那么影院账户余额这一行的锁时间就最少。最大程度地<strong>减少了事务之间的锁等待，提升了并发度</strong>。</p><p>如果这个影院做活动，可以低价预售一年内所有的电影票，而且这个活动只做一天。于是在活动时间开始的时候，你的 MySQL 就挂了。登上服务器一看，CPU 消耗接近 100%，但整个数据库每秒就执行不到 100 个事务。这是什么原因呢？</p><p>这里，就要说到<strong>死锁</strong>和<strong>死锁检测</strong>了。</p><h4 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h4><p>当并发系统中不同线程出现<strong>循环资源依赖</strong>，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。    </p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210429002357084.png" alt="image-20210429002357084" style="zoom:50%;" /><p>有两种策略:</p><ul><li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数<code>innodb_lock_wait_timeout</code>来设置。</li><li>另一种策略是，发起死锁检测，发现死锁后，<strong>主动回滚死锁链条中的某一个事务</strong>，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑。</li></ul><p>正常情况下我们还是要采用死锁检测，而且<code>innodb_deadlock_detect</code>的默认值本身就是 on。</p><p>主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。</p><p>想象一下这个过程：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p><p>那如果所有事务都要更新同一行的场景呢？</p><p>每个新来的被堵住的线程，都要<strong>判断会不会由于自己的加入导致了死锁</strong>，这是一个时间复杂度是 O(n) 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。</p><p><strong>怎么解决由这种热点行更新导致的性能问题呢？</strong>问题的症结在于，死锁检测要耗费大量的 CPU 资源。</p><p><strong>一种头痛医头的方法，就是能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。</strong>但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过<strong>业务重试</strong>一般就没问题了，这是<strong>业务无损</strong>的。而关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。</p><p><strong>另一个思路是控制并发度。</strong>这个并发控制要做在<strong>数据库服务端</strong>。如果你有中间件，可以考虑在中间件实现；如果你的团队有能修改 MySQL 源码的人，也可以做在 MySQL 里面。基本思路就是，对于相同行的更新，在进入引擎之前<strong>排队</strong>。这样在 InnoDB 内部就不会有大量的死锁检测工作了。</p><p><strong>如果团队里暂时没有数据库方面的专家，不能实现这样的方案，能不能从设计上优化这个问题呢？</strong></p><p>可以考虑通过将<strong>一行改成逻辑上的多行</strong>来减少锁冲突。还是以影院账户为例，可以考虑放在多条记录上，比如 10 个记录，影院的账户总额等于这 10 个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的 1/10，可以减少锁等待个数，也就减少了死锁检测的 CPU 消耗。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;数据库锁设计的初衷是处理并发问题。&lt;/p&gt;
&lt;p&gt;根据加锁的范围，MySQL 里面的锁大致可以分成&lt;strong&gt;全局锁&lt;/strong&gt;、&lt;strong&gt;表级锁&lt;/strong&gt;和&lt;strong&gt;行锁&lt;/strong&gt;三类。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MySql" scheme="https://cwww3.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>索引(一)</title>
    <link href="https://cwww3.github.io/2021/04/28/index/"/>
    <id>https://cwww3.github.io/2021/04/28/index/</id>
    <published>2021-04-27T16:15:55.000Z</published>
    <updated>2021-05-26T02:22:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。</strong></p><p>实现索引的方式却有很多种，这里也就引入了索引模型的概念。</p><p>用于提高读写效率的数据结构很多，比较简单的数据结构分别是哈希表、有序数组和搜索树。</p><span id="more"></span><p><strong>哈希表</strong></p><p>哈希表是一种以键 - 值（key-value）存储数据的结构。不可避免地，会存在哈希冲突。</p><p>处理这种情况的一种方法是，拉出一个链表。</p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210427151555806.png" alt="image-20210427151555806" style="zoom:50%;" /><p>哈希表这种结构适用于只有<strong>等值查询</strong>的场景，比如 Memcached 及其他一些 NoSQL 引擎。如果要范围查询，就必须全部扫描一遍了。</p><p><strong>有序数组</strong></p><p>有序数组在等值查询和范围查询场景中的性能就都非常优秀(采用二分法能快速找到对应目标)</p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210427151814311.png" alt="image-20210427151814311" style="zoom:50%;" /><p>如果仅仅看<strong>查询效率</strong>，有序数组就是最好的数据结构了。但是，在需要<strong>更新数据</strong>的时候就麻烦了，往中间插入一个记录就必须得挪动后面所有的记录，成本太高。所以，有序数组索引只适用于<strong>静态存储引擎</strong>。</p><p><strong>二叉搜索树</strong></p><p>二叉搜索树的特点是：父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。</p><p>如果查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -&gt; UserC -&gt; UserF -&gt; User2 这个路径得到。时间复杂度O(log(N))。</p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210427152159214.png" alt="image-20210427152159214" style="zoom:50%;" /><p>为了维持 O(log(N)) 的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 O(log(N))。</p><p>二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，<strong>索引不止存在内存中，还要写到磁盘上</strong>。</p><p>一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数据块(最多查20次拿到结果)。</p><p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块，也就是每次查询拿到的数据块有用的信息足够多，让树的高度要尽可能小。那么，应该使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。</p><p>以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200 (由16K/(8B+6B)得到)。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到<strong>树根的数据块总是在内存中</strong>的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p><p>在 MySQL 中，<strong>索引是在存储引擎层实现的</strong>，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。</p><h3 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h3><p>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为<strong>索引组织表</strong>。InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。<strong>每一个索引在 InnoDB 里面对应一棵 B+ 树</strong>。</p><p>假设，有一个主键列为 ID 的表，表中有字段 k，并且在 k 上有索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(id int primary key, k int not null, name varchar(16),index (k))engine=InnoDB;</span><br></pre></td></tr></table></figure><p>表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下。</p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210427232638252.png" alt="image-20210427232638252" style="zoom:50%;" /><p>根据叶子节点的内容，索引类型分为<strong>主键索引</strong>和<strong>非主键索引</strong>。</p><p>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。</p><p>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。</p><p><strong>基于主键索引和普通索引的查询有什么区别？</strong></p><ul><li><p><code> select * from T where ID=500</code>，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；</p></li><li><p><code> select * from T where k=5</code>，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为<strong>回表</strong>。</p></li></ul><p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。</p><h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><p>B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。</p><p>以上面这个图为例，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。</p><p>如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。</p><p>而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。</p><p>这个过程称为<strong>页分裂</strong>。<strong>性能</strong>自然会受影响。还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体<strong>空间利用率</strong>降低大约 50%。</p><p><strong>当然有分裂就有合并</strong>。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p><p><strong>自增主键</strong></p><ul><li><p>每次插入一条新记录，都是追加操作，不会触发分裂。</p></li><li><p>主键长度小，普通索引的叶子节点小，普通索引占用的空间小。</p></li><li><p>逻辑删除能防止页合并</p></li></ul><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>在下面这个表 T 中，执行<code> select * from T where k between 3 and 5</code>，需要执行几次树的搜索操作？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T (</span><br><span class="line">  ID int primary key,</span><br><span class="line">  k int NOT NULL DEFAULT 0, </span><br><span class="line">  s varchar(16) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">  index k(k)</span><br><span class="line">)engine=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into T values(100,1, &#x27;aa&#x27;),(200,2,&#x27;bb&#x27;),(300,3,&#x27;cc&#x27;),(500,5,&#x27;ee&#x27;),(600,6,&#x27;ff&#x27;),(700,7,&#x27;gg&#x27;);</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210427233958349.png" alt="image-20210427233958349" style="zoom:50%;" /><p>这条 SQL 查询语句的执行流程：</p><ol><li>在 k 索引树上找到 k=3 的记录，取得 ID = 300；</li><li>再到 ID 索引树查到 ID=300 对应的 R3；</li><li>在 k 索引树取下一个值 k=5，取得 ID=500；</li><li>再回到 ID 索引树查到 ID=500 对应的 R4；</li><li>在 k 索引树取下一个值 k=6，不满足条件，循环结束。</li></ol><p>这个查询过程读了 k 索引树的 3 条记录（步骤 1、3 和 5），回表了两次（步骤 2 和 4）。</p><p>由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，有没有可能经过索引优化，<strong>避免回表</strong>过程呢？</p><p>如果执行的语句是<code> select ID from T where k between 3 and 5</code>，这时<strong>只需要查 ID</strong> 的值，而 ID 的值<strong>已经在 k 索引树上</strong>了，因此可以直接提供查询结果，不需要回表。</p><p>也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为<strong>覆盖索引</strong>。</p><p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tuser` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `id_card` varchar(32) DEFAULT NULL,</span><br><span class="line">  `name` varchar(32) DEFAULT NULL,</span><br><span class="line">  `age` int(11) DEFAULT NULL,</span><br><span class="line">  `ismale` tinyint(1) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `id_card` (`id_card`),</span><br><span class="line">  KEY `name_age` (`name`,`age`)</span><br><span class="line">) ENGINE=InnoDB</span><br></pre></td></tr></table></figure><p>为了直观地说明这个概念，用（name，age）这个联合索引来分析。</p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210427234541755.png" alt="image-20210427234541755" style="zoom:50%;" /><p>可以看到，索引项是按照索引定义里面出现的字段顺序排序的。</p><p>当逻辑需求是查到所有名字是“张三”的人时，可以快速定位到 ID4，然后向后遍历得到所有需要的结果。</p><p>如果你要查的是所有名字第一个字是“张”的人，你的 SQL 语句的条件是”where name like ‘张 %’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。</p><p><strong>不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。</strong></p><p><strong>在建立联合索引的时候，如何安排索引内的字段顺序?</strong></p><p><strong>评估标准是索引的复用能力</strong>，当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。</p><p>如果既有联合查询，又有基于 a、b 各自的查询呢？查询条件里面只有 b 的语句，是无法使用 (a,b) 这个联合索引的，这时候不得不维护另外一个索引，也就是说需要同时维护 (a,b)、(b) 这两个索引或者(b,a),(a)。</p><p>这时候，要考虑的原则就是<strong>空间</strong>了。字段长的只建立一次，短的建立两次。</p><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>最左前缀可以用于在索引中定位记录。那些不符合最左前缀的部分，会怎么样呢？</p><p>以上图为例，存在联合索引（name, age）。检索出表中“名字第一个字是张，而且年龄是 10 岁的所有男孩”。</p><p>那么，SQL 语句是这么写的：<code>mysql&gt; select * from tuser where name like &#39;张%&#39; and age=10 and ismale=1;</code></p><p>这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录 ID3。然后判断其他条件是否满足。</p><p>在 MySQL 5.6 之前，只能从 ID3 开始<strong>一个个回表</strong>。到主键索引上找出数据行，<strong>再对比</strong>字段值。</p><p>MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在<strong>索引遍历过程中</strong>，<strong>对索引中包含的字段先做判断</strong>，直接<strong>过滤</strong>掉不满足条件的记录，<strong>减少回表次数</strong>。</p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210427235715656.png" alt="image-20210427235715656" style="zoom:50%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实现索引的方式却有很多种，这里也就引入了索引模型的概念。&lt;/p&gt;
&lt;p&gt;用于提高读写效率的数据结构很多，比较简单的数据结构分别是哈希表、有序数组和搜索树。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MySql" scheme="https://cwww3.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>Isolation And MVCC</title>
    <link href="https://cwww3.github.io/2021/04/27/isolation-mvcc/"/>
    <id>https://cwww3.github.io/2021/04/27/isolation-mvcc/</id>
    <published>2021-04-26T17:04:16.000Z</published>
    <updated>2021-05-26T02:22:03.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。</p><ul><li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</li><li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li><li>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><span id="more"></span><p>假设数据表 T 中只有一列，其中一行的值为 1，下面是按照时间顺序执行两个事务的行为。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(c int) engine=InnoDB;</span><br><span class="line">insert into T(c) values(1);</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210426223339317.png" alt="image-20210426223339317" style="zoom:50%;" /><ul><li>读未提交  <code>v1=2</code> <code> v2=2</code>  <code>v3=2</code> A事务v1能读到未提交事务B的变动</li><li>读提交  <code>v1=1</code> <code>v2=2</code> <code>v3=2</code> A事务 v1不能读到未提交的事务B的变动</li><li>可重复读 <code>v1=1</code> <code>v2=1</code> <code>v3=2</code> A事务 v1不能读到未提交的事务B的变动 ，且在A事务中，v2的值数据没变</li><li>串行化 <code>v1=1</code> <code>v2=1</code> <code>v3=2</code>  事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。</li></ul><p>在实现上，数据库里面会创建一个<strong>视图</strong>，访问的时候<strong>以视图的逻辑结果为准</strong>。</p><p>“可重复读”隔离级别下，这个视图是在<strong>事务启动时创建</strong>的，整个事务存在期间都用这个视图。</p><p>“读提交”隔离级别下，这个视图是在每个 <strong>SQL 语句开始执行</strong>的时候创建的。</p><p>“读未提交”隔离级别下<strong>直接返回</strong>记录上的最新值，<strong>没有视图概念</strong>；</p><p>“串行化”隔离级别下直接用<strong>加锁</strong>的方式来<strong>避免</strong>并行访问。</p><p>查看数据库隔离级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;transaction_isolation&#x27;;</span><br></pre></td></tr></table></figure><h3 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h3><ol><li>显式启动事务语句，<code>begin/start transaction</code>。配套的提交语句是 <code>commit</code>，回滚语句是<code> rollback</code>。</li><li><code>set autocommit=0</code>，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。</li></ol><p><strong>注意事务的启动时机</strong></p><p><code>begin/start transaction</code> 命令并<strong>不是</strong>一个事务的<strong>起点</strong>，在执行到第一个操作 InnoDB 表的语句，事务才真正启动。</p><p>如果你想要<strong>马上启动</strong>一个事务，可以使用 <code>start transaction with consistent snapshot </code>这个命令。</p><h3 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h3><p>在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条<strong>回滚</strong>操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p><p>假设一个值从 1 被按顺序改成了 2、3、4，在<strong>回滚日志</strong>里面就会有类似下面的记录。当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。同一条记录在系统中可以存在多个版本，就是数据库的<strong>多版本并发控制</strong>（MVCC）</p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210426225401655.png" alt="image-20210426225401655" style="zoom:50%;" /><p>对于 read-view A，要得到 1，就必须将当前值(4)依次执行图中所有的回滚操作得到。</p><p>回滚日志在不需要的时候才删除。系统会判断,没有比这条回滚日志更早的 read-view 时，这条回滚日志会被删除。</p><h4 id="长事务"><a href="#长事务" class="headerlink" title="长事务"></a>长事务</h4><p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p><p>除了对回滚段的影响，长事务还<strong>占用锁资源</strong>，也可能拖垮整个库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询事务 大于 1分钟</span><br><span class="line">select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60</span><br></pre></td></tr></table></figure><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>在 MySQL 里，有两个“视图”的概念：</p><ul><li>一个是 view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样。</li><li>另一个是 InnoDB 在实现 MVCC 时用到的<strong>一致性读视图</strong>，即 consistent read view，用于支持 <strong>RC</strong>（Read Committed，读提交）和 <strong>RR</strong>（Repeatable Read，可重复读）隔离级别的实现。它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。</li></ul><h3 id="“快照”在-MVCC-里是怎么工作的？"><a href="#“快照”在-MVCC-里是怎么工作的？" class="headerlink" title="“快照”在 MVCC 里是怎么工作的？"></a>“快照”在 MVCC 里是怎么工作的？</h3><h4 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h4><p>在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于<strong>整库</strong>的。</p><p>InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按<strong>申请顺序严格递增</strong>的。</p><p>每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</p><p>也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。如图：</p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210426232909504.png" alt="image-20210426232909504" style="zoom:50%;" /><p>图中虚线框里是同一行数据的 4 个版本，当前最新版本是 V4，k 的值是 22，它是被 transaction id 为 25 的事务更新的，因此它的 row trx_id 也是 25。</p><p>语句更新会生成 undo log（回滚日志）。那么，undo log 在哪呢？实际上，图 2 中的三个虚线箭头，就是 undo log；而 V1、V2、V3 并<strong>不是物理上真实存在</strong>的，而是每次需要的时候根据当前版本和 undo log 计算出来的。比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来。</p><p>按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。</p><p>因此，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。当然，如果“上一个版本”也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数据，它自己还是要认的。</p><p>在实现上， InnoDB 为每个事务构造了一个<strong>数组</strong>，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。</p><p>数组里面事务 ID 的最小值记为<strong>低水位</strong>，当前系统里面已经创建过的事务 ID 的最大值加 1 记为<strong>高水位</strong>。</p><p>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。</p><p>而数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的。</p><p>这个视图数组把所有的 row trx_id 分成了几种不同的情况。</p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210426234705470.png" alt="image-20210426234705470" style="zoom:50%;" /><p>对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：</p><ol><li>如果在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li><li>如果在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li><li>如果落在黄色部分(低水位到高水位是最小未提交事务id和最大未提交事务id的范围，不代表这个范围内的事务都没提交)<ol><li>若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；</li><li>若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li></ol></li></ol><p>比如，对于上上图 中的数据来说，如果有一个事务，它的低水位是 18，那么当它访问这一行数据时，就会从 V4 通过 U3 计算出 V3，所以在它看来，这一行的值是 11。</p><p><strong>InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。</strong>(前面提到快照基于整库创建，这个特性避免了拷贝整个库的数据)</p><h4 id="可重复读分析"><a href="#可重复读分析" class="headerlink" title="可重复读分析"></a>可重复读分析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `k` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line">insert into t(id, k) values(1,1),(2,2);</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210426231444890.png" alt="image-20210426231444890" style="zoom:50%;" /><p>假设：</p><p>事务 A 开始前，系统里面只有一个活跃事务 ID 是 99；</p><p>事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务；</p><p>三个事务开始前，(1,1）这一行数据的 row trx_id 是 90。</p><h5 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h5><p>这样，事务 A 的视图数组就是[99,100], 事务 B 的视图数组是[99,100,101], 事务 C 的视图数组是[99,100,101,102]。</p><p>事务 A 查询逻辑有关的操作：</p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210427001400180.png" alt="image-20210427001400180" style="zoom:50%;" /><p>从图中可以看到，第一个有效更新是事务 C，把数据从 (1,1) 改成了 (1,2)。这时候，这个数据的最新版本的 row trx_id 是 102，而 90 这个版本已经成为了历史版本。</p><p>第二个有效更新是事务 B，把数据从 (1,2) 改成了 (1,3)。这时候，这个数据的最新版本（即 row trx_id）是 101，而 102 又成为了历史版本。</p><p>在事务 A 查询的时候，其实事务 B 还没有提交，但是它生成的 (1,3) 这个版本已经变成当前版本了。但这个版本对事务 A 必须是不可见的，否则就变成脏读了。</p><p>现在事务 A 要来读数据了，它的视图数组是[99,100]。当然了，<strong>读数据都是从当前版本读起的</strong>。所以，事务 A 查询语句的读数据流程是这样的：</p><ul><li>找到 (1,3) 的时候，判断出 row trx_id=101，比高水位大，处于红色区域，不可见；</li><li>接着，找到上一个历史版本，一看 row trx_id=102，比高水位大，处于红色区域，不可见；</li><li>再往前找，终于找到了（1,1)，它的 row trx_id=90，比低水位小，处于绿色区域，可见。</li></ul><p>这样执行下来，虽然期间这一行数据被修改过，但是事务 A 不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为一致性读。</p><h5 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h5><p><strong>事务 B 的 update 语句，如果按照一致性读，好像结果不对哦？</strong></p><p>如果事务 B 在更新之前查询一次数据，这个查询返回的 k 的值确实是 1。</p><p>但是，当它要去<strong>更新数据</strong>的时候，<strong>就不能再在历史版本上更新了</strong>，否则事务 C 的更新就丢失了。</p><p>因此，事务 B 此时的 set k=k+1 是在（1,2）的基础上进行的操作。</p><p>所以，这里就用到了这样一条规则：<strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）</strong>。</p><p>因此，在更新的时候，当前读拿到的数据是 (1,2)，更新后生成了新版本的数据 (1,3)，这个新版本的 row trx_id 是 101。</p><p>所以，在执行事务 B 查询语句的时候，一看自己的版本号是 101，最新数据的版本号也是 101，是自己的更新，可以直接使用，所以查询得到的 k 的值是 3。</p><p>这里我们提到了一个概念，叫作当前读。其实，除了 update 语句外，<strong>select 语句如果加锁</strong>，也是当前读。</p><p>所以，如果把事务 A 的查询语句 select * from t where id=1 修改一下，也都可以读到版本号是 101 的数据，返回的 k 的值是 3。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 读锁 共享锁</span><br><span class="line">mysql&gt; select k from t where id=1 lock in share mode; </span><br><span class="line">-- 写锁 排他锁</span><br><span class="line">mysql&gt; select k from t where id=1 for update;</span><br></pre></td></tr></table></figure><p>再往前一步，假设事务 C 不是马上提交的，而是变成了下面的事务 C’，会怎么样呢？</p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210427002632560.png" alt="image-20210427002632560" style="zoom:50%;" /><p>事务 C’的不同是，更新后并没有马上提交，在它提交前，事务 B 的更新语句先发起了。</p><p>虽然事务 C’还没提交，但是 (1,2) 这个版本也已经生成了，并且是当前的最新版本。那么，事务 B 的更新语句会怎么处理呢？</p><p>这时候，<strong>两阶段锁协议</strong>上场了。事务 C’没提交，也就是说 (1,2) 这个版本上的<strong>写锁还没释放</strong>。而事务 B 是<strong>当前读</strong>，而且必须加锁，因此就被锁住了，<strong>必须等到事务 C’释放这个锁</strong>，才能继续它的当前读。</p><h4 id="读提交分析"><a href="#读提交分析" class="headerlink" title="读提交分析"></a>读提交分析</h4><p>可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。</p><p>如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</p><p>而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：</p><ul><li>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；</li><li>在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</li></ul><p>在读提交隔离级别下，事务 A 和事务 B 的查询语句查到的 k，分别应该是多少呢？</p><h5 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h5><p>说明：<code>start transaction with consistent snapshot; </code>的意思是从这个语句开始，创建一个持续<strong>整个事务</strong>的一致性快照。</p><p>所以，在读提交隔离级别下，这个用法就<strong>没意义</strong>了，等效于普通的 start transaction。(事务C下的图，不是C’)</p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210427003316641.png" alt="image-20210427003316641" style="zoom:50%;" /><p>这时，事务 A 的查询语句的视图数组是在执行这个语句的时候创建的，时序上 (1,2)、(1,3) 的生成时间都在创建这个视图数组的时刻之前。但是，在这个时刻：</p><ul><li>(1,3) 还没提交，属于情况 1，不可见；</li><li>(1,2) 提交了，属于情况 3，可见。</li></ul><p>所以，这时候事务 A 查询语句返回的是 k=2。事务 B 查询结果 k=3。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;事务隔离级别&quot;&gt;&lt;a href=&quot;#事务隔离级别&quot; class=&quot;headerlink&quot; title=&quot;事务隔离级别&quot;&gt;&lt;/a&gt;事务隔离级别&lt;/h3&gt;&lt;p&gt;SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。&lt;/li&gt;
&lt;li&gt;读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。&lt;/li&gt;
&lt;li&gt;可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。&lt;/li&gt;
&lt;li&gt;串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="MySql" scheme="https://cwww3.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>SSH</title>
    <link href="https://cwww3.github.io/2021/04/24/ssh/"/>
    <id>https://cwww3.github.io/2021/04/24/ssh/</id>
    <published>2021-04-24T15:04:35.000Z</published>
    <updated>2021-07-22T09:54:11.884Z</updated>
    
    <content type="html"><![CDATA[<p>SSH（Secure Shell 的缩写）是一种网络协议，用于加密两台计算机之间的通信，并且支持各种身份验证机制。主要用于保证远程登录和远程通信的安全。</p><p>SSH 的软件架构是服务器-客户端模式（Server - Client）。在这个架构中，SSH 软件分成两个部分：向服务器发出请求的部分，称为客户端（client），OpenSSH 的实现为 <strong>ssh</strong>；接收客户端发出的请求的部分，称为服务器（server），OpenSSH 的实现为 <strong>sshd</strong>。</p><span id="more"></span><h3 id="客户端安装ssh"><a href="#客户端安装ssh" class="headerlink" title="客户端安装ssh"></a>客户端安装ssh</h3><p>Linux 系统一般都自带 ssh，如果没有就需要安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Ubuntu</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install openssh-client</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看版本号</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh -V</span></span><br></pre></td></tr></table></figure><h3 id="连接远程机器"><a href="#连接远程机器" class="headerlink" title="连接远程机器"></a>连接远程机器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> p 指定端口号 默认22  user为用户名 hostname为连接的主机</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh -p port user@hostname</span></span><br></pre></td></tr></table></figure><ul><li>首次登录会出现提醒。表示不认识这台机器，提醒用户确认是否需要连接。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &#x27;foo.com (192.168.121.111)&#x27; can&#x27;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:Vybt22mVXuNuB5unE++yowF7lgA/9/2bLSiO3qmYWBY.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><ul><li><p><strong>服务器指纹</strong>，指的是 SSH 服务器公钥的哈希值。每台 SSH 服务器都有唯一一对密钥，用于跟客户端通信，其中公钥的哈希值就可以用来识别服务器。</p></li><li><p>ssh 会将本机连接过的所有服务器公钥的指纹，都储存在本机的<code>~/.ssh/known_hosts</code>文件中。每次连接服务器时，通过该文件判断是否为陌生主机（陌生公钥）。</p></li><li><p>然后，客户端就会跟服务器建立连接。接着，ssh 就会要求用户输入所要登录账户的密码。用户输入并验证密码正确以后，就能登录远程服务器的 Shell 了。</p></li></ul><h3 id="客户端配置文件"><a href="#客户端配置文件" class="headerlink" title="客户端配置文件"></a>客户端配置文件</h3><p>SSH 客户端的全局配置文件是<code>/etc/ssh/ssh_config</code>，用户个人的配置文件在<code>~/.ssh/config</code>，优先级高于全局配置文件。</p><ul><li>按照不同服务器，列出各自的连接参数，从而不必每一次登录都输入重复的参数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host remoteserver</span><br><span class="line">HostName remote.example.com</span><br><span class="line">User neo</span><br><span class="line">Port 2112</span><br></pre></td></tr></table></figure><ul><li>登录<code>remote.example.com</code>时，只要执行<code>ssh remoteserver</code>命令，就会自动套用 config 文件里面指定的参数。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh remoteserver</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 等同于</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh -p 2112 neo@remote.example.com</span></span><br></pre></td></tr></table></figure><h3 id="SSH-密钥登录"><a href="#SSH-密钥登录" class="headerlink" title="SSH 密钥登录"></a>SSH 密钥登录</h3><ul><li><p>SSH 默认采用密码登录，这种方法有很多缺点，简单的密码不安全，复杂的密码不容易记忆，每次手动输入也很麻烦。密钥登录是比密码登录更好的解决方案。</p></li><li><p>密钥（key）是一个非常大的数字，通过加密算法得到。对称加密只需要一个密钥，非对称加密需要两个密钥成对使用，分为公钥（public key）和私钥（private key）。</p></li></ul><h5 id="密钥登录的过程"><a href="#密钥登录的过程" class="headerlink" title="密钥登录的过程"></a>密钥登录的过程</h5><ul><li><p>客户端通过<code>ssh-keygen</code>生成自己的公钥和私钥。</p><ul><li><code>ssh-key</code> 生成密钥</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@domain.com&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成的密钥文件默认就会是~/.ssh/id_rsa（私钥）和~/.ssh/id_rsa.pub（公钥）。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -t 指定加密算法</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -b 参数指定密钥的二进制位数。这个参数值越大，密钥就越不容易破解，但是加密解密的计算开销也会加大。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -C 参数可以为密钥文件指定新的注释，格式为username@host。</span></span><br></pre></td></tr></table></figure></li><li><p>手动将客户端的公钥放入远程服务器的指定位置。</p><ul><li>OpenSSH 规定，用户公钥保存在服务器的<code>~/.ssh/authorized_keys</code>文件。你要以哪个用户的身份登录到服务器，密钥就必须保存在该用户主目录的<code>~/.ssh/authorized_keys</code>文件。</li></ul></li><li><p> 客户端向服务器发起 SSH 登录的请求。</p></li><li><p> 服务器收到用户 SSH 登录的请求，发送一些随机数据给用户，要求用户证明自己的身份。</p></li><li><p> 客户端收到服务器发来的数据，使用私钥对数据进行签名，然后再发还给服务器。</p></li><li><p> 服务器收到客户端发来的加密签名后，使用对应的公钥解密，然后跟原始数据比较。如果一致，就允许用户登录。</p></li></ul><h3 id="服务器安装sshd"><a href="#服务器安装sshd" class="headerlink" title="服务器安装sshd"></a>服务器安装sshd</h3><p>如果没有安装 sshd，可以用下面的命令安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Ubuntu</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install openssh-server</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动  默认启动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sshd</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果提示“sshd re-exec requires execution with an absolute path”，就需要使用绝对路径来启动。这是为了防止有人出于各种目的，放置同名软件在<span class="variable">$PATH</span>变量指向的目录中，代替真正的 sshd。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> no hostkeys available —- exiting</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 需要生成ssh公钥私钥(用户也要对应，一般是root)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Missing privilege separation directory: /run/sshd 需要创建该目录</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> /usr/sbin/sshd &amp;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> &amp; 表示后台运行</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过 Systemd 管理 sshd</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start sshd.service</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl stop sshd.service</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl restart sshd.service</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 自启动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> sshd.service</span></span><br></pre></td></tr></table></figure><h3 id="sshd-配置文件"><a href="#sshd-配置文件" class="headerlink" title="sshd 配置文件"></a>sshd 配置文件</h3><ul><li>sshd 的配置文件在<code>/etc/ssh</code>目录，主配置文件是<code>sshd_config</code>。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sshd 配置项</span></span><br><span class="line">AllowUsers指定允许登录的用户，用户名之间使用空格分隔</span><br><span class="line">AllowTcpForwarding 指定是否允许端口转发</span><br><span class="line">Ciphers指定 sshd 可以接受的加密算法 多个算法之间使用逗号分隔。</span><br><span class="line">ListenAddress指定 sshd 监听的本机 IP 地址，即 sshd 启用的 IP 地址，默认是 0.0.0.0（ListenAddress 0.0.0.0）表示在本机所有网络接口启用。</span><br><span class="line">PasswordAuthentication指定是否允许密码登录</span><br><span class="line">Port指定 sshd 监听的端口，即客户端连接的端口，默认是22</span><br><span class="line">PubKeyAuthentication指定是否允许公钥登录</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改配置文件以后，可以使用下面的命令验证，配置文件是否有语法错误</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sshd -t</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新的配置文件生效，必须重启 sshd</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl restart sshd</span></span><br></pre></td></tr></table></figure><h3 id="SSH-端口转发"><a href="#SSH-端口转发" class="headerlink" title="SSH 端口转发"></a>SSH 端口转发</h3><p>SSH 除了登录服务器，还有一大用途，就是作为加密通信的中介，充当两台服务器之间的通信加密跳板，使得原本不加密的通信变成加密通信。这个功能称为端口转发（port forwarding），又称 SSH 隧道（tunnel）。</p><p><strong>端口转发有两个主要作用：</strong></p><ol><li>将不加密的数据放在 SSH 安全连接里面传输，使得原本不安全的网络服务增加了安全性，比如通过端口转发访问 Telnet、FTP 等明文服务，数据传输就都会加密。</li><li>作为数据通信的加密跳板，绕过网络防火墙。</li></ol><p><strong>端口转发有三种使用方法：动态转发，本地转发，远程转发。</strong></p><h4 id="动态转发"><a href="#动态转发" class="headerlink" title="动态转发"></a>动态转发</h4><ul><li>本机与 SSH 服务器之间创建了一个加密连接，然后本机内部针对某个端口的通信，都通过这个加密连接转发。它的一个使用场景就是，访问所有外部网站，都通过 SSH 转发。</li><li>动态转发需要把本地端口绑定到 SSH 服务器。至于 SSH 服务器要去访问哪一个网站，完全是动态的，取决于原始通信，所以叫做动态转发。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -D local-port tunnel-host -N</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -D 表示动态转发</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> local-port是本地端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tunnel-host是 SSH 服务器，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -N表示这个 SSH 连接只进行端口转发，不登录远程 Shell，不能执行远程命令，只能充当隧道。</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -D 2121 tunnel-host -N</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意，这种转发采用了 SOCKS5 协议。访问外部网站时，需要把 HTTP 请求转成 SOCKS5 协议，才能把本地端口的请求转发出去。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -x socks5://localhost:2121 http://www.example.com</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -x 指定代理服务器  通过SOCKS5协议的本地2121端口，访问http://www.example.com。</span></span><br></pre></td></tr></table></figure><h4 id="本地转发"><a href="#本地转发" class="headerlink" title="本地转发"></a>本地转发</h4><ul><li>SSH 服务器作为中介的跳板机，建立本地计算机与特定目标网站之间的加密连接。本地转发是在本地计算机的 SSH 客户端建立的转发规则。</li><li>它会指定一个本地端口（local-port），所有发向那个端口的请求，都会转发到 SSH 跳板机（tunnel-host），然后 SSH 跳板机作为中介，将收到的请求发到目标服务器（target-host）的目标端口（target-port）。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -L local-port:target-host:target-port tunnel-host</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -L参数表示本地转发</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> local-port是本地端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> target-host是你想要访问的目标服务器</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> target-port是目标服务器的端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tunnel-host是 SSH 跳板机。</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -L 2121:www.example.com:80 tunnel-host -N -f</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -f 表示 SSH 连接在后台运行</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl http://localhost:2121</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意，本地端口转发采用 HTTP 协议，不用转成 SOCKS5 协议。</span></span><br></pre></td></tr></table></figure><h4 id="远程转发"><a href="#远程转发" class="headerlink" title="远程转发"></a>远程转发</h4><ul><li>这种场景比较特殊，主要针对内网的情况。本地计算机在外网，SSH 跳板机和目标服务器都在内网，而且本地计算机无法访问内网之中的 SSH 跳板机，但是 SSH 跳板机可以访问本机计算机。</li><li>由于本机无法访问内网 SSH 跳板机，就无法从外网发起 SSH 隧道，建立端口转发。必须反过来，从 SSH 跳板机发起隧道，建立端口转发，这时就形成了远程端口转发。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -R local-port:target-host:target-port <span class="built_in">local</span> -N</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 首先需要注意，不是在本机执行的，而是在 SSH 跳板机执行的 从跳板机去连接本地计算机</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -R参数表示远程端口转发</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> local-port是本地计算机的端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> target-host和target-port是目标服务器及其端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">local</span>是本地计算机。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显然，远程端口转发要求本地计算机也安装了 SSH 服务器，这样才能接受 SSH 跳板机的远程登录。</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -R 2121:www.example.com:80 <span class="built_in">local</span> -N</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行上面的命令以后，跳板机到本地计算机的隧道已经建立了。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以从本机访问目标服务器了，即在本机执行下面的命令。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl http://localhost:2121</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;SSH（Secure Shell 的缩写）是一种网络协议，用于加密两台计算机之间的通信，并且支持各种身份验证机制。主要用于保证远程登录和远程通信的安全。&lt;/p&gt;
&lt;p&gt;SSH 的软件架构是服务器-客户端模式（Server - Client）。在这个架构中，SSH 软件分成两个部分：向服务器发出请求的部分，称为客户端（client），OpenSSH 的实现为 &lt;strong&gt;ssh&lt;/strong&gt;；接收客户端发出的请求的部分，称为服务器（server），OpenSSH 的实现为 &lt;strong&gt;sshd&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="网络" scheme="https://cwww3.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>MySql日志系统</title>
    <link href="https://cwww3.github.io/2021/04/24/mysql-log/"/>
    <id>https://cwww3.github.io/2021/04/24/mysql-log/</id>
    <published>2021-04-24T09:32:17.000Z</published>
    <updated>2021-05-26T02:22:03.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="WAl"><a href="#WAl" class="headerlink" title="WAl"></a>WAl</h4><p>WAL 的全称是 Write-Ahead Logging，它的关键点就是<strong>先写日志，再写磁盘</strong>，（先写日志 也是写入磁盘，写日志是<strong>顺序</strong>写盘，速度很快）</p><h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录<strong>写到 redo log</strong>里面，并<strong>更新内存</strong>，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录<strong>更新到磁盘</strong>里面，而这个更新往往是在系统比较空闲的时候做。</p><span id="more"></span><p>InnoDB 的 redo log 是<strong>固定大小</strong>的，比如可以配置为<strong>一组 4 个文件</strong>，每个文件的大小是 1GB，那么总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头<strong>循环</strong>写，如下面这个图所示。</p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210424175348370.png" alt="image-20210424175348370" style="zoom:50%;" /><p><strong>write pos</strong> 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。</p><p><strong>checkpoint</strong> 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p>write pos 和 checkpoint 之间的是还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示满了，不能再执行新的更新，得停下来处理掉一些记录，把 checkpoint 推进一下。</p><p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 <strong>crash-safe</strong>。本质上说，crash-safe 就是<strong>落盘处理</strong>，将数据存储到了磁盘上，断电重启也不会丢失</p><h4 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h4><p>redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。</p><p>为什么会有两份日志呢？</p><p>因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。</p><p>这两种日志有以下三点不同</p><ol><li>redo log 是 <strong>InnoDB</strong> <strong>引擎特有</strong>的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li><li>redo log 是<strong>物理日志</strong>，记录的是“在某个<strong>数据页上</strong>做了什么修改”；binlog 是<strong>逻辑日志</strong>，记录的是这个语句的原始逻辑。</li><li>redo log 是<strong>循环写</strong>的，<strong>空间固定</strong>会用完；binlog 是可以<strong>追加写入</strong>的。追加写是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol><h4 id="更新流程"><a href="#更新流程" class="headerlink" title="更新流程"></a>更新流程</h4><p>执行器和 InnoDB 引擎在执行简单 update 语句时的内部流程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure><ol><li>执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的<strong>数据页</strong>本来就<strong>在内存中</strong>，就直接返回给执行器；否则，需要先<strong>从磁盘读入内存</strong>，然后再返回。(所以对于更新操作，并不会更新某条记录就把<strong>某条记录</strong>查询到内存中对其做修改就行，而是将<strong>对应记录所在页</strong>都加载到内存中。)</li><li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，<strong>得到新的一行数据</strong>，再<strong>调用引擎接口写入</strong>这行新数据（写入内存）。</li><li><strong>引擎</strong>将这行新数据更新到内存中，同时将这个<strong>更新操作记录</strong>到 redo log 里面，此时 redo log 处于 <strong>prepare</strong> 状态。然后<strong>告知执行器</strong>执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li><li><strong>执行器调用引擎的提交事务接口</strong>，引擎把刚刚写入的 redo log 改成提交（<strong>commit</strong>）状态，更新完成。</li></ol><p>以下是 update 语句的执行流程图，浅色框表示是在 <strong>InnoDB</strong> 内部执行的，深色框表示是在<strong>执行器</strong>中执行的。</p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210424175407812.png" alt="image-20210424175407812" style="zoom:50%;" /><p>redo log 的写入拆成了两个步骤：prepare 和 commit，这就是”<strong>两阶段提交</strong>“。</p><h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><p>两阶段提交为了让两份日志之间的<strong>逻辑一致</strong>。</p><p>binlog 会记录所有的<strong>逻辑操作</strong>，并且是采用<strong>追加写</strong>的形式。备份系统中会保存最近一段时间的所有 binlog，同时系统会定期做<strong>整库备份</strong>。根据系统的重要性，可以是一天一备，也可以是一周一备。</p><p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，可以这么做：</p><ul><li>首先，找到<strong>最近</strong>的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到<strong>临时库</strong>；</li><li>然后，从备份的<strong>时间点</strong>开始，将备份的 binlog <strong>依次取出</strong>来，重放到中午误删表之前的那个<strong>时刻</strong>。</li></ul><p>这样你的临时库就跟<strong>误删之前</strong>的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。</p><p>为什么日志需要“<strong>两阶段提交</strong>”。这里不妨用<strong>反证法</strong>来进行解释。</p><p>由于 redo log 和 binlog 是两个<strong>独立</strong>的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。看看这两种方式会有什么问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure><p>假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？</p><ol><li><strong>先写 redo log 后写 binlog</strong>。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，<strong>redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来</strong>，所以恢复后这一行 c 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后<strong>备份日志的时候，存起来的 binlog 里面就没有这条语句</strong>。如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个<strong>临时库就会少</strong>了这一次<strong>更新</strong>，恢复出来的这一行 c 的值就是 0，与原库的值<strong>不同</strong>。</li><li><strong>先写 binlog 后写 redo log</strong>。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个<strong>事务无效</strong>，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后<strong>用 binlog 来恢复</strong>的时候就<strong>多了一个事务</strong>出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。</li></ol><p>可以看到，如果不使用两阶段提交，那么<strong>数据库的状态</strong>就有可能和用它的<strong>日志恢复出来的库的状态</strong>不一致。</p><p>本质上是因为 <strong>redo log 负责事务</strong>； <strong>binlog负责归档恢复</strong>； 各司其职，相互配合，才保证了现有功能的完整性；</p><p>redolog和binlog具有关联行，在恢复数据时，redolog<strong>用于恢复主机故障时的未更新的物理数据</strong>，binlog<strong>用于备份操作</strong>。每个阶段的log操作都是记录在磁盘的，在恢复数据时，redolog <strong>状态为commit则说明binlog也成功</strong>，直接恢复数据；如果redolog是prepare，则需要查询对应的binlog事务是否成功(一个完整的binlog结尾有固定的格式)，决定是回滚还是执行。</p><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><p><strong>redo log buffer 是什么？是先修改内存，还是先写 redo log 文件？</strong></p><ul><li>log 也是先记录在内存中(redo log buffer )，然后在写入磁盘。</li><li>mysql肯定是没有权限直接操作磁盘的，必须要通过OS提供的接口操作。这种情况就可能会丢数据：mysql调用OS的接口将redo log写入磁盘，OS返回true，但是<strong>实际</strong>这个页的数据还是在<strong>buffer</strong>里没有实际刷盘，此时OS崩了，那么数据也就没了。</li><li><strong>innodb_flush_log_at_trx_commit</strong> 这个参数设置成 1 ，表示每次事务的 redo log 都<strong>直接持久化</strong>到磁盘。这样可以保证 MySQL 异常重启之后数据不丢失。</li><li><strong>sync_binlog</strong> 设置成 1 ，表示每次事务的 binlog 都持久化到磁盘，可以保证 MySQL 异常重启之后 binlog 不丢失。</li></ul><p><strong>MySQL 怎么知道 binlog 是完整的?</strong></p><ul><li>row 格式的 binlog，最后会有一个 XID event。</li><li>statement 格式的 binlog，最后会有 COMMIT；</li></ul><p><strong>redo log 和 binlog 是怎么关联起来的?</strong></p><ul><li>它们有一个共同的数据字段，叫 XID。崩溃恢复的时候，会按顺序扫描 redo log：<ul><li>如果碰到既有 prepare、又有 commit 的 redo log，就直接提交；</li><li>如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务。</li></ul></li></ul><p><strong>为什么只用bin log没有crash-safe的能力</strong></p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210424175424457.png" alt="image-20210424175424457" style="zoom:50%;" /><ul><li>binlog 没有能力恢复<strong>数据页</strong> 。在图中位置发生crash，这时对数据的更新可能还停留在内存中，并未刷盘。mysql重启后。binlog2可以将事务2进行恢复。但是对于事务1来说，系统已经认为提交完成了，不会再对它做处理。这样会导致一次事务的丢失。</li><li>redo log 记录的就是更新的操作，而且没有被写入磁盘的。所以重启后redo log里所有的记录都是需要更新到磁盘的。但是binlog记录的是所有的记录，不知道那些记录被写入磁盘了。</li></ul><p><strong>数据写入后的最终落盘，是从 redo log 更新过来的还是从 buffer pool 更新过来的呢？</strong></p><ul><li>redo log 并没有记录数据页的完整数据，所以它并没有能力自己去更新磁盘数据页。</li><li>如果是正常运行的实例的话，数据页被修改以后，跟磁盘的数据页不一致，称为脏页。最终数据落盘，就是把内存中的数据页写盘。</li><li>在崩溃恢复场景中，InnoDB 如果判断到一个数据页可能在崩溃恢复的时候丢失了更新，就会将它<strong>读到内存</strong>，然后<strong>让 redo log 更新内存内容</strong>。更新完成后，内存页变成脏页，最终数据落盘。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;WAl&quot;&gt;&lt;a href=&quot;#WAl&quot; class=&quot;headerlink&quot; title=&quot;WAl&quot;&gt;&lt;/a&gt;WAl&lt;/h4&gt;&lt;p&gt;WAL 的全称是 Write-Ahead Logging，它的关键点就是&lt;strong&gt;先写日志，再写磁盘&lt;/strong&gt;，（先写日志 也是写入磁盘，写日志是&lt;strong&gt;顺序&lt;/strong&gt;写盘，速度很快）&lt;/p&gt;
&lt;h4 id=&quot;redo-log&quot;&gt;&lt;a href=&quot;#redo-log&quot; class=&quot;headerlink&quot; title=&quot;redo log&quot;&gt;&lt;/a&gt;redo log&lt;/h4&gt;&lt;p&gt;具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录&lt;strong&gt;写到 redo log&lt;/strong&gt;里面，并&lt;strong&gt;更新内存&lt;/strong&gt;，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录&lt;strong&gt;更新到磁盘&lt;/strong&gt;里面，而这个更新往往是在系统比较空闲的时候做。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MySql" scheme="https://cwww3.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>Vim 基本操作</title>
    <link href="https://cwww3.github.io/2021/04/18/vim/"/>
    <id>https://cwww3.github.io/2021/04/18/vim/</id>
    <published>2021-04-17T21:15:31.000Z</published>
    <updated>2021-05-26T02:22:03.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h3><h4 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h4><ul><li><p>到插入模式</p><ul><li><code>i</code>  (insert) 停留在光标所在字符之前</li><li><code>I</code>  在光标所在行行首停留</li><li><code>a</code>  (append) 定留在光标所在字符之后</li><li><code>A</code>  在光标所在行行尾停留</li><li><code>o</code>  (open a line) 在光标所在行下面创建一个空行，并停留在下一行 </li><li><code>O</code>  在光标所在行上面创建一个空行，并停留在上一行</li><li><code>s</code> 删除光标所在字符</li><li><code>S</code> 删除光标所在行<span id="more"></span></li></ul></li><li><p>到命令行模式</p><ul><li><code>:</code></li></ul></li><li><p>到可视化模式</p><ul><li><code>v</code> 选择光标经过的字符</li><li><code>V</code> 选择光标经过的行</li><li><code>Ctrl + v</code>  选择块</li></ul></li></ul><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><h5 id="motion"><a href="#motion" class="headerlink" title="motion"></a>motion</h5><ul><li><p><code>↑ ↓ ← →</code> 移动一个单位</p></li><li><p><code>n→</code>  向右移动n个单位</p></li><li><p><code>w</code> word 移动到下一个单词</p></li><li><p><code>b</code> back word 移动到上一个单词</p></li><li><p><code>0</code>  <code>^</code> 移动到行首</p></li><li><p><code>$</code>  移动到行尾</p></li><li><p><code>f</code> find 向右查找 </p><ul><li><code>f&lt;char&gt;</code> 从光标所在位置向右移动到第一个指定字符(光标所在行范围内有效) </li></ul></li><li><p><code>F</code> 向左查找</p></li><li><p><code>gg</code> 移动到第一行</p></li><li><p><code>nG </code> 移动到第n行</p></li><li><p><code>G</code> 移动到最后一行</p></li></ul><h5 id="operation"><a href="#operation" class="headerlink" title="operation"></a>operation</h5><ul><li><code>d</code>  delete 剪切</li><li><code>y</code>  复制 </li><li><code>p</code>  paste 粘贴</li><li><code>c</code>  change 删除并进入编辑模式</li></ul><h5 id="operation-motion"><a href="#operation-motion" class="headerlink" title="operation + motion"></a>operation + motion</h5><ul><li><code>d→</code> 删除光标定位的字符</li><li><code>d←</code> 删除光标左边的第一个字符</li><li><code>dn→</code> 删除光标右边n个字符(包括光标所在字符)</li><li><code>dn←</code> 删除光标左边n个字符(不包括光标所在字符)</li><li><code>df&lt;char&gt;</code> 删除 从光标开始到右边的第一个指定字符(包括该字符)</li><li><code>dF&lt;char&gt;</code> 删除 从光标开始到左边的第一个指定字符(包括该字符)</li><li><code>dgg</code> 删除上面所有的行（包括光标所在行）</li><li><code>dG</code> 删除下面所有的行（包括光标所在行）</li><li><code>dnG</code> 删除光标所在行到第n行</li><li><code>di)</code> 删除括号内的内容 （光标要在括号中）</li><li><code>diw</code> 删除光标所在的单词</li><li><code>dd</code> 删除光标所在行</li></ul><h5 id="search"><a href="#search" class="headerlink" title="search"></a>search</h5><ul><li><code>/&lt;string&gt;&lt;CR&gt;</code>  查找字符串</li><li><code>n</code> 移动到下一个查到的元素</li><li><code>N</code> 移动到上一个找到的元素</li><li><code>zz</code> 让光标所在行位于屏幕中央</li><li><code>nzz</code> 移动到下一处并使其处于屏幕中央</li></ul><h3 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h3><ul><li>切换到正常模式 <ul><li><code>Esc</code></li></ul></li></ul><h3 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h3><ul><li>切换到正常模式<ul><li><code>Esc</code></li></ul></li><li>操作<ul><li><code>:split</code> |  <code>:sp</code>  上下分屏</li><li><code>:vsplit</code> |  <code>:vs</code> 左右分屏</li><li><code>&lt;Ctrl&gt; + w + w</code>  按顺序切换分屏 </li><li><code>&lt;Ctrl&gt; + w + (h|l|j|k)</code> 向左|向右|向下|向上 切换分屏</li><li><code>&lt;Ctrl&gt; + w +  =  </code>  扩大分屏</li><li><code>&lt;Ctrl&gt; + w +  -  </code>  缩小分屏</li><li><code>:edit .</code> |  <code>:e .</code> 显示当前目录</li></ul></li></ul><h3 id="可视化模式-Visual-Mode"><a href="#可视化模式-Visual-Mode" class="headerlink" title="可视化模式 (Visual Mode)"></a>可视化模式 (Visual Mode)</h3><ul><li>可视化模式下可以选择一块编辑区域，然后对选中的文件内容执行插入、删除、替换、改变大小写等操作</li></ul><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ul><li>路径 <code>~/.vim/vimrc</code> 没有则创建</li></ul><h4 id="功能配置"><a href="#功能配置" class="headerlink" title="功能配置"></a>功能配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax on # 语法高亮</span><br><span class="line">set number # 显示行号</span><br><span class="line">set cursorline # 突出光标所在行</span><br><span class="line">set ignorecase # 忽略大小写</span><br><span class="line">set wildmenu # 命令模式下 输入部分单词 按TAB键 提供多个单词选择</span><br><span class="line"></span><br><span class="line">set hlsearch # 搜索结果匹配到的内容高亮显示</span><br><span class="line">set incsearch # 搜索过程中匹配的内容高亮显示</span><br></pre></td></tr></table></figure><h4 id="键盘映射"><a href="#键盘映射" class="headerlink" title="键盘映射"></a>键盘映射</h4><ul><li><p>语法 <code>map action1 action2</code> 当触发<code>action1</code>时 会被映射为<code>action2</code></p></li><li><p><code>map</code> 对应模式</p><ul><li>不带<code>nore</code>的<code>map</code> 可以被再次映射</li><li><code>map</code> <code>noremap</code>     正常模式 可视化模式 运算符模式</li><li><code>nmap</code> <code>nnoremap</code> 正常模式</li><li><code>vmap</code> <code>vnoremap</code> 可视化模式</li><li><code>omap</code> <code>onoremap</code> 运算符模式</li><li><code>map!</code> <code>noremap!</code> 插入模式 命令行模式</li><li><code>imap</code> <code>inoremap</code> 插入模式</li><li><code>cmap</code> <code>cnoremap</code> 命令行模式</li></ul></li><li><p>操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 让leader键(前缀键)为空格 默认是\</span></span><br><span class="line"><span class="bash"><span class="built_in">let</span> mapleader = <span class="string">&quot; &quot;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 s S 映射为 无效操作</span></span><br><span class="line">map s &lt;nop&gt;</span><br><span class="line">map S &lt;nop&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 W 映射为 保存</span></span><br><span class="line">map W :w&lt;CR&gt; </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 Q 映射为 保存并退出</span> </span><br><span class="line">map Q :wq&lt;CR&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 R 映射为 加载配置文件</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="variable">$MYVIMRC</span>需要配置环境变量  <span class="variable">$export</span> MYVIMRC = ~/.vim/vimrc</span></span><br><span class="line">map R :source $MYVIMRC&lt;CR&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找下一项并保持在屏幕中央</span></span><br><span class="line">map = nzz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找上一项并保持在屏幕中央</span></span><br><span class="line">map - Nzz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 让 空格+回车 关闭搜索高亮显示</span></span><br><span class="line">map &lt;leader&gt;&lt;CR&gt; :nohlsearch&lt;CR&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><ul><li><a href="https://github.com/junegunn/vim-plug">vim-plug</a></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure><ul><li><p>配置</p><ul><li><p><a href="https://github.com/vim-airline/vim-airline">vim-airline</a>  <img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210418045427861.png" alt="image-20210418045427861"></p></li><li><p><a href="https://github.com/connorholyday/vim-snazzy">vim-snazzy</a></p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210418050654704.png" alt="image-20210418050654704" style="zoom:50%;" /></li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定插件下载路径</span></span><br><span class="line">call plug#begin(&#x27;~/.vim/plugged&#x27;)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定插件路径 单引号导入</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Plug <span class="string">&#x27;https://github.com/vim-airline/vim-airline.git&#x27;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 简短版</span></span><br><span class="line">Plug &#x27;vim-airline/vim-airline&#x27;</span><br><span class="line">Plug &#x27;connorholyday/vim-snazzy&#x27;</span><br><span class="line">call plug#end()</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">配置完后重新加载配置文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash">输入</span></span><br><span class="line">:PlugInstall&lt;CR&gt; </span><br><span class="line"><span class="meta">#</span><span class="bash">进行安装</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装完成后配置文件添加</span></span><br><span class="line">colorscheme snazzy</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;正常模式&quot;&gt;&lt;a href=&quot;#正常模式&quot; class=&quot;headerlink&quot; title=&quot;正常模式&quot;&gt;&lt;/a&gt;正常模式&lt;/h3&gt;&lt;h4 id=&quot;切换&quot;&gt;&lt;a href=&quot;#切换&quot; class=&quot;headerlink&quot; title=&quot;切换&quot;&gt;&lt;/a&gt;切换&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;到插入模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt;  (insert) 停留在光标所在字符之前&lt;/li&gt;
&lt;li&gt;&lt;code&gt;I&lt;/code&gt;  在光标所在行行首停留&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt;  (append) 定留在光标所在字符之后&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt;  在光标所在行行尾停留&lt;/li&gt;
&lt;li&gt;&lt;code&gt;o&lt;/code&gt;  (open a line) 在光标所在行下面创建一个空行，并停留在下一行 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;O&lt;/code&gt;  在光标所在行上面创建一个空行，并停留在上一行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; 删除光标所在字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt; 删除光标所在行</summary>
    
    
    
    
    <category term="Vim" scheme="https://cwww3.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://cwww3.github.io/2021/04/12/regexp/"/>
    <id>https://cwww3.github.io/2021/04/12/regexp/</id>
    <published>2021-04-11T16:00:37.000Z</published>
    <updated>2021-05-26T02:22:03.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><ul><li><p><code>.</code>     匹配除换行符以外的任意字符</p></li><li><p><code>\w</code>   匹配字母或数字或下划线或汉字</p></li><li><p><code>\s</code>   匹配任意的空白符 (包括空格，制表符，换行符，中文全角空格等)</p></li><li><p><code>\d</code>   匹配数字</p></li><li><p><code>\b</code>   匹配单词的开始或结束 并不匹配这些单词分隔字符中的任何一个，它<strong>只匹配一个位置</strong></p></li><li><p><code>^</code>     匹配字符串的开始</p></li><li><p><code>$</code>     匹配字符串的结束</p><span id="more"></span><h3 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h3></li><li><p>如果想查找元字符本身的话，比如查找<code>.</code>或者<code>*</code>就出现了问题——你没办法指定它们，因为它们会被解释成别的意思。</p></li><li><p>这时你就得使用<code>\</code>来取消这些字符的特殊意义。因此，你应该使用<code>\.</code>和<code>\*</code>。当然，要查找<code>\</code>本身，你也得用<code>\\</code></p></li></ul><h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><ul><li><code>*</code> 重复零次或更多次</li><li><code>+</code> 重复一次或更多次</li><li><code>?</code> 重复零次或一次</li><li><code>&#123;n&#125;</code> 重复n次</li><li><code>&#123;n,&#125;</code> 重复n次或更多次</li><li><code>&#123;n,m&#125;</code> 重复n到m次</li></ul><h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><ul><li><code>[aeiou]</code> 匹配没有预定义元字符的字符集合</li><li><code>[0-9]</code>代表的含意与<code>\d</code>一样</li><li><code>[a-z0-9A-Z_]</code>等同于<code>\w</code></li></ul><h3 id="分枝条件"><a href="#分枝条件" class="headerlink" title="分枝条件"></a>分枝条件</h3><ul><li><code>|</code> 使用分枝条件时，要注意各个条件的顺序 会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了</li></ul><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><ul><li><code>()</code> </li><li>使用小括号指定一个子表达式后，<strong>匹配这个子表达式的文本</strong>(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个<strong>组号</strong>，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。</li><li>分组0对应整个正则表达式</li><li>实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配，因此所有命名组的组号都大于未命名的组号</li></ul><h3 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h3><ul><li><code>\W</code> 匹配任意不是字母，数字，下划线，汉字的字符</li><li><code>\S</code> 匹配任意不是空白符的字符</li><li><code>\D</code> 匹配任意非数字的字符</li><li><code>\B</code> 匹配不是单词开头或结束的位置</li><li><code>[^x]</code> 匹配除了x以外的任意字符</li><li><code>[^aeiou]</code> 匹配除了aeiou这几个字母以外的任意字符</li></ul><h3 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h3><h4 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h4><ul><li><strong>后向引用</strong>用于重复搜索前面某个分组匹配的文本。例如，<code>\1</code> 代表分组1匹配的文本。</li><li><code>\b(\w+)\b\s+\1\b</code> 可以用来匹配重复的单词，像<em>go go</em>, 或者<em>kitty kitty</em>。</li><li>也可以自己指定子表达式的<strong>组名</strong>。要指定一个子表达式的组名，使用这样的语法：<code>(?&lt;Word&gt;\w+)</code> (或者把尖括号换成’也行：<code>(?&#39;Word&#39;\w+))</code> ,这样就把\w+的组名指定为Word了。要反向引用这个分组<strong>捕获</strong>的内容，你可以使用<code>\k&lt;Word&gt;</code>, 所以可以改成这样：<code>\b(?&lt;Word&gt;\w+)\b\s+\k&lt;Word&gt;\b</code>。</li><li><code>(exp)</code> 匹配exp,并捕获文本到自动命名的组里</li><li><code>(?&lt;name&gt;exp)</code> 配exp,并捕获文本到名称为name的组里，也可以写成<code>(?&#39;name&#39;exp)</code></li><li><code>(?:exp)</code> 匹配exp,不捕获匹配的文本，也不给此分组分配组号</li></ul><h3 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h3><ul><li><p>查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)。</p></li><li><p><code>(?=exp)</code> **零宽度正预测先行断言 **  断言自身出现的位置的后面能匹配表达式exp  匹配exp前面的位置</p><ul><li><code>\b\w+(?=ing\b)</code>，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找*I’m singing while you’re dancing.*时，它会匹配sing和danc。</li></ul></li><li><p><code>(?&lt;=exp)</code> <strong>零宽度正回顾后发断言</strong> 断言自身出现的位置的前面能匹配表达式exp 匹配exp后面的位置</p><ul><li>比如<code>(?&lt;=\bre)\w+\b</code> 会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找<em>reading a book</em>时，它匹配ading。</li></ul></li></ul><h3 id="负向零宽断言"><a href="#负向零宽断言" class="headerlink" title="负向零宽断言"></a>负向零宽断言</h3><ul><li><code>(?!exp)</code> <strong>零宽度负预测先行断言</strong> 匹配后面跟的不是exp的位置 断言此位置的后面不能匹配表达式exp。<ul><li><code>\d&#123;3&#125;(?!\d)</code> 匹配三位数字，而且这三位数字的后面不能是数字；<code>\b((?!abc)\w)+\b</code> 匹配不包含连续字符串abc的单词。</li></ul></li><li><code>(?&lt;!exp)</code>  <strong>零宽度负回顾后发断言</strong> 匹配前面不是exp的位置 断言此位置的前面不能匹配表达式exp<ul><li><code>(?&lt;![a-z])\d&#123;7&#125;</code> 匹配前面不是小写字母的七位数字。</li><li><code>(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)</code>  这样如果前缀实际上是<code>&lt;b&gt;</code>的话，后缀就是<code>&lt;/b&gt;</code>了。整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)。</li></ul></li></ul><h3 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h3><ul><li><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配<strong>尽可能多</strong>的字符。</p><ul><li><code>a.*b</code>，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索<em>aabab</em>的话，它会匹配整个字符串aabab。这被称为<strong>贪婪</strong>匹配。</li></ul></li><li><p>有时，我们更需要<strong>懒惰</strong>匹配，也就是匹配<strong>尽可能少</strong>的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号<code>?</code>。这样<code>.*?</code> 就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：</p><ul><li><code>a.*?b</code> 匹配最短的，以a开始，以b结束的字符串。如果把它应用于<em>aabab</em>的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。</li></ul></li><li><p><code>*?</code> 重复任意次，但尽可能少重复</p></li><li><p><code>+?</code> 重复1次或更多次，但尽可能少重复</p></li><li><p><code>??</code> 重复0次或1次，但尽可能少重复</p></li><li><p><code>&#123;n,m&#125;?</code> 重复n到m次，但尽可能少重复</p></li><li><p><code>&#123;n,&#125;?</code> 重复n次以上，但尽可能少重复</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;元字符&quot;&gt;&lt;a href=&quot;#元字符&quot; class=&quot;headerlink&quot; title=&quot;元字符&quot;&gt;&lt;/a&gt;元字符&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;.&lt;/code&gt;     匹配除换行符以外的任意字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;\w&lt;/code&gt;   匹配字母或数字或下划线或汉字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;\s&lt;/code&gt;   匹配任意的空白符 (包括空格，制表符，换行符，中文全角空格等)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;\d&lt;/code&gt;   匹配数字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;\b&lt;/code&gt;   匹配单词的开始或结束 并不匹配这些单词分隔字符中的任何一个，它&lt;strong&gt;只匹配一个位置&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;^&lt;/code&gt;     匹配字符串的开始&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;$&lt;/code&gt;     匹配字符串的结束&lt;/p&gt;</summary>
    
    
    
    
    <category term="正则表达式" scheme="https://cwww3.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>密码学</title>
    <link href="https://cwww3.github.io/2021/04/10/Cryptography/"/>
    <id>https://cwww3.github.io/2021/04/10/Cryptography/</id>
    <published>2021-04-10T04:41:31.000Z</published>
    <updated>2021-05-26T02:22:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>把<strong>任意长度</strong>的输入通过哈希算法变换成<strong>固定长度</strong>的输出，该输出就是散列值。 这种转换是一种<strong>压缩映射。</strong>散列值又称<strong>摘要</strong>(<strong>Digest</strong>)、<strong>校验值</strong>(<strong>Checksum</strong>)、<strong>指纹</strong>(<strong>Fingerprint</strong>)</li></ul><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul><li><p>完整性校验</p></li><li><p>加密</p><span id="more"></span><h3 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h3></li><li><p>安全Hash编码法(<strong>Secure Hash Algorithm</strong>)</p><ul><li>SHA家族的五个算法，分别是SHA-1、SHA-224、SHA-256、SHA-384，和SHA-512，后四者有时并称为SHA-2。</li></ul></li><li><p> <strong>MD5</strong>(<strong>Standards for Message Digest</strong>)</p></li><li><p> 循环冗余校验 <strong>CRC-32</strong> (<strong>Cyclic redundancy check</strong>)</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">md := md5.New()</span><br><span class="line">md.Write([]<span class="keyword">byte</span>(<span class="string">&quot;msg&quot;</span>))</span><br><span class="line">sum := md.Sum(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><ul><li>一般来讲，长度越长，安全性越高，计算耗时越长。安全性高的被用作加密，安全性低的主要用来做完整性校验对称加密</li></ul><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul><li>同一个密钥可以同时用来加密和解密，这种加密方法称为对称加密，也称为单密钥加密</li></ul><h3 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h3><ul><li>加密</li></ul><h3 id="具体应用-1"><a href="#具体应用-1" class="headerlink" title="具体应用"></a>具体应用</h3><ul><li><p>DES</p><ul><li>密钥的长度必须为 8 个字符（64 位） </li></ul></li><li><p>3DES </p><ul><li> 密钥的长度必须为 24 个字符</li></ul></li><li><p>AES</p><ul><li>密钥的长度可以是 16/24/32 个字符（128/192/256 位）。</li></ul></li></ul><h3 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h3><ul><li>ECB(Electronic codebook) ： 把每一个数据块独立加密，最后拼接。解密时先拆分后解密。</li></ul><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/1609256058591-2b32cc9e-f3d4-46d0-9f8b-dc3d498fd6b5.png" alt="image.png" style="zoom:50%;" /><h3 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h3><ul><li>数据补位一般有<strong>NoPadding</strong>和<strong>PKCS7Padding</strong>(JAVA中是PKCS5Padding)填充方式，PKCS7Padding和PKCS5Padding实际只是协议不一样，根据相关资料说明：PKCS5Padding明确定义了加密块是8字节，PKCS7Padding加密快可以是1-255之间。但是封装的DES算法默认都是8字节，所以可以认为他们一样。数据补位实际是在数据不满8字节的倍数，才补充到8字节的倍数的填充过程。</li><li><strong>NoPadding填充方式</strong>：算法本身不填充，比如.NET的padding提供了有None，Zeros方式，分别为不填充和填充0的方式。</li><li><strong>PKCS7Padding（PKCS5Padding）填充方式</strong>：为.NET和JAVA的默认填充方式，对加密数据字节长度对8取余为r，如r大于0，则补8-r个字节，字节为8-r的值；如果r等于0，则补8个字节8。比如：加密字符串为为AAA，则补位为AAA55555;加密字符串为BBBBBB，则补位为BBBBBB22；加密字符串为CCCCCCCC，则补位为CCCCCCCC88888888。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AEC-ECB</span></span><br><span class="line">src := []<span class="keyword">byte</span>(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">key := []<span class="keyword">byte</span>(<span class="string">&quot;1234567890123456&quot;</span>)</span><br><span class="line">dst , _ := openssl.AesECBEncrypt(src, key, openssl.PKCS7_PADDING)</span><br><span class="line">fmt.Printf(base64.StdEncoding.EncodeToString(dst))  <span class="comment">// yXVUkR45PFz0UfpbDB8/ew==</span></span><br><span class="line"></span><br><span class="line">dst , _ = openssl.AesECBDecrypt(dst, key, openssl.PKCS7_PADDING)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(dst)) <span class="comment">// 123456</span></span><br></pre></td></tr></table></figure><ul><li>CBC(Cipher-block chaining)： 加密每一个数据块时，都会与上一个数据块之间有联系。第一个块中需要使用初始化向量。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/1609256032286-18fda154-1f9f-4fb1-8cb3-ce1e3f0b6e04.png" alt="image.png" style="zoom:50%;" />- </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AEC-CBC</span></span><br><span class="line">src := []<span class="keyword">byte</span>(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">key := []<span class="keyword">byte</span>(<span class="string">&quot;1234567890123456&quot;</span>)</span><br><span class="line">iv := []<span class="keyword">byte</span>(<span class="string">&quot;1234567890123456&quot;</span>)</span><br><span class="line">dst , _ := openssl.AesCBCEncrypt(src, key, iv, openssl.PKCS7_PADDING)</span><br><span class="line">fmt.Println(base64.StdEncoding.EncodeToString(dst)) <span class="comment">// 1jdzWuniG6UMtoa3T6uNLA==</span></span><br><span class="line"></span><br><span class="line">dst , _ = openssl.AesCBCDecrypt(dst, key, iv, openssl.PKCS7_PADDING)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(dst)) <span class="comment">// 123456</span></span><br></pre></td></tr></table></figure><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ul><li>又名<strong>公开密钥加密</strong>(<strong>public-key cryptography</strong>) 使用两个不同的密钥：加密密钥和解密密钥。这两个密钥是<strong>数学相关</strong>，用某用户加密密钥加密后所得的信息，只能用该用户的解密密钥才能解密。<strong>如果知道了其中一个，并不能计算出另外一个</strong>。因此如果公开了一对密钥中的一个，并不会危害到另外一个的秘密性质。称公开的密钥为公钥；不公开的密钥为私钥。</li></ul><h3 id="用途-2"><a href="#用途-2" class="headerlink" title="用途"></a>用途</h3><ul><li><p>加密通信(公钥加密，私钥解密)</p></li><li><p>数字签名(私钥加密，公钥解密)</p><ul><li>认证、防止抵赖、验证完整性</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/1608958332701-5b9a5d63-0019-4d62-926f-6ed273fd67fb.png" alt="image.png"></p><h3 id="具体应用-2"><a href="#具体应用-2" class="headerlink" title="具体应用"></a>具体应用</h3><ul><li><p>RSA</p><ul><li>基于整数分解</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/1608960447857-b04864b2-9aa7-40c7-ac14-e053a62432dd.png" alt="image.png"></p><ul><li><p>ECC椭圆曲线算法(效率高)</p><ul><li>基于离散对数</li></ul></li></ul><h3 id="安全性-1"><a href="#安全性-1" class="headerlink" title="安全性"></a>安全性</h3><ul><li>根据公钥运算出私钥的难度越大，越安全。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成秘钥对</span></span><br><span class="line">privateKey, err := rsa.GenerateKey(rand.Reader, <span class="number">1024</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 公钥</span></span><br><span class="line">publicKey := privateKey.PublicKey</span><br><span class="line">msg := []<span class="keyword">byte</span>(<span class="string">&quot;重要信息&quot;</span>)</span><br><span class="line">sha := sha256.New()</span><br><span class="line"><span class="comment">// 加密信息</span></span><br><span class="line">encryptedMsg, err := rsa.EncryptOAEP(sha, rand.Reader, &amp;publicKey, msg, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(encryptedMsg)</span><br><span class="line"><span class="comment">// 解密信息</span></span><br><span class="line">decryptedMsg, err := privateKey.Decrypt(<span class="literal">nil</span>, encryptedMsg, &amp;rsa.OAEPOptions&#123;Hash: crypto.SHA256&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(decryptedMsg))</span><br></pre></td></tr></table></figure><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><ul><li><p>数字签名在发送方，分两步：</p><ol><li>从内容算摘要（哈希算法）</li><li>从摘要明文到摘要密文，也称数字签名（发送方私钥+加密算法）</li></ol></li><li><p>数字签名验证在接收方，分两步：</p><ol><li>从摘要密文（数字签名）到摘要明文（发送方公钥+解密算法）</li><li> 从收到的内容当场计算摘要（哈希算法），与（1）的结果比对是否一致</li></ol></li><li><p>如果一致，可以说明两点：</p><ol><li>内容未被篡改（摘要一致）</li><li>内容只能是私钥拥方发送，不可抵赖（密文能够用对方的公钥解开）</li></ol></li></ul><p>然后单独想一下，</p><ol><li>为什么要对摘要加密后再发送？为什么不直接发摘要？摘要不可以逆向推导原文，摘要泄露了也没事……</li></ol><ul><li>答：摘要泄露是没事，但不怀好意的人的目的可能并不在想要窃听你发送了什么，而是想<strong>伪造发送的内容</strong>让你相信。通过同时替换摘要和内容，很简单就实现了。所以摘要需要经过加密，不怀好意的人没有私钥，无法完成加密。或者说你收到的东西只要能用公钥解密，你才认为这个东西确实是对应私钥持有者完成的。这叫做当事人不可抵赖，同时别人无法仿冒。（数字签名：不可抵赖+无法仿冒）</li></ul><ol start="2"><li>为什么不直接对内容加密，而是先生成摘要，对摘要加密？</li></ol><ul><li>答：可能是<strong>内容很长</strong>吧，直接加密算半天！摘要算法可以把无限长的内容输出成长度固定的摘要，再进行加密时间就是可以预估的</li></ul><h2 id="数字证书-digital-certificate"><a href="#数字证书-digital-certificate" class="headerlink" title="数字证书(digital certificate)"></a>数字证书(digital certificate)</h2><ul><li><p><strong>数字签名</strong>很完美，你用公钥能够解密，说明确实是私钥方发送的，你很放心……但有没有想过，万一这把<strong>公钥</strong>本身，就被人做了手脚？？？ <strong>为了保证“公钥”是可信的</strong>，数字证书应运而生。<strong>发送方先把自己的公钥给CA</strong>，CA用CA的私钥和CA加密算法 对其进行加密得到加密后的发送方公钥，用于生成CA的数字证书。</p></li><li><p>发送时不仅发送内容、数字签名，还包含发送方的数字证书。</p></li><li><p>接收方拿到后</p><ol><li>首先从数字证书中解密出发送方公钥（<strong>用的是CA的公钥和CA解密算法</strong>），这个公钥必然是可信的。</li><li>然后就是和前面一样的流程，拿发送方公钥去解密数字签名，得到摘要；最后比对摘要是否一致。</li></ol></li></ul><ul><li><p>一个问题：既然数字证书是为了保证发送方公钥不是别人伪造的，那怎么保证“CA”的公钥不是伪造的呢？</p></li><li><p>答：CA是第三方机构，<strong>CA公钥是公开的</strong>，接收方可以跟别人比对（比如在网上查询），因此不可能伪造。但是发送方公钥，接收方是<strong>通过通信得到</strong>的，收到后无法验证。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;哈希&quot;&gt;&lt;a href=&quot;#哈希&quot; class=&quot;headerlink&quot; title=&quot;哈希&quot;&gt;&lt;/a&gt;哈希&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;把&lt;strong&gt;任意长度&lt;/strong&gt;的输入通过哈希算法变换成&lt;strong&gt;固定长度&lt;/strong&gt;的输出，该输出就是散列值。 这种转换是一种&lt;strong&gt;压缩映射。&lt;/strong&gt;散列值又称&lt;strong&gt;摘要&lt;/strong&gt;(&lt;strong&gt;Digest&lt;/strong&gt;)、&lt;strong&gt;校验值&lt;/strong&gt;(&lt;strong&gt;Checksum&lt;/strong&gt;)、&lt;strong&gt;指纹&lt;/strong&gt;(&lt;strong&gt;Fingerprint&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;用途&quot;&gt;&lt;a href=&quot;#用途&quot; class=&quot;headerlink&quot; title=&quot;用途&quot;&gt;&lt;/a&gt;用途&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;完整性校验&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;加密&lt;/p&gt;</summary>
    
    
    
    
    <category term="密码学" scheme="https://cwww3.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>LRU</title>
    <link href="https://cwww3.github.io/2021/04/10/LRU/"/>
    <id>https://cwww3.github.io/2021/04/10/LRU/</id>
    <published>2021-04-10T04:22:08.000Z</published>
    <updated>2021-05-26T02:22:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>LRU 全称是 Least Recently Used，即<strong>最近最久未使用</strong>算法，它是页面置换算法的一种。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>LRU 算法根据数据的历史访问记录来进行淘汰数据，其核心思想是「如果数据最近被访问过，那么将来被访问的几率也更高」。</p><span id="more"></span><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p>假设内存只能容纳3个页大小，按照 7 0 1 2 0 3 0 4 的次序访问页。假设内存按照栈的方式来描述访问时间，在上面的，是最近访问的，在下面的是，最远时间访问的。</p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/1603611190062-ed91223e-ec1c-43d1-93b1-c588836963c3.png"  style="zoom:50%;" /><h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><ul><li>基于 HashMap 和 双向链表实现</li><li>设计思路：可以使用 HashMap 存储 key，这样可以做到 save 和 get key的时间都是 O(1)，而 HashMap 的 Value 指向双向链表实现的 LRU 的 Node 节点，如图所示：</li></ul><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/1603611957492-34f94f23-a41b-42df-a9b7-6d01c92b0386.png"  style="zoom:50%;" /><ul><li><p>其中 head 代表双向链表的表头，tail 代表尾部。首先预先设置 LRU 的容量，如果存储满了，可以通过 O(1) 的时间淘汰掉双向链表的尾部，每次新增和访问数据，都可以通过 O(1)的效率把新的节点增加到对头，或者把已经存在的节点移动到队头。</p></li><li><p>预设大小是 3 ，演示LRU在存储和访问过程中的变化。我们对这个LRU缓存的操作序列如下：</p></li><li><ol><li>save(key1, 7)  save(key2, 0)  save(key3, 1)  save(key4, 2)</li></ol></li><li><ol start="2"><li>get(key2)  save(key5, 3)  get(key2)  save(key6, 4)</li></ol></li><li><ol start="3"><li>LRU双向链表变化如下：</li></ol></li></ul><p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/1603612934340-7de97516-6559-4ad6-a3c7-a84ffeae8365.png"  style="zoom: 50%;" />-</p><ul><li><p>两个核心操作：</p></li><li><ol><li> save(key, value)，首先在 HashMap 找到 Key 对应的节点，如果节点存在，更新节点的值，并把这个节点移动队头。如果不存在，需要构造新的节点，并且尝试把节点塞到队头，如果LRU空间不足，则通过 tail 淘汰掉队尾的节点，同时在 HashMap 中移除 Key。</li></ol></li><li><ol start="2"><li>get(key)，通过 HashMap 找到 LRU 链表节点，因为根据LRU 原理，这个节点是最新访问的，所以要把节点插入到队头，然后返回缓存的值。</li></ol></li><li><p>代码实现</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mylru</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DLinkerNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    key       <span class="keyword">string</span></span><br><span class="line">    value     <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    pre, post *DLinkerNode</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    head, tail      *DLinkerNode</span><br><span class="line">    capacity, count <span class="keyword">int</span></span><br><span class="line">    cache           <span class="keyword">map</span>[<span class="keyword">string</span>]*DLinkerNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据key,value创建一个新节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newDLinkerNode</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">DLinkerNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;DLinkerNode&#123;</span><br><span class="line">        key:   key,</span><br><span class="line">        value: value,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个容量为capacity的LRU缓存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLRUCache</span><span class="params">(capacity <span class="keyword">int</span>)</span> *<span class="title">LRUCache</span></span> &#123;</span><br><span class="line">    lru := &amp;LRUCache&#123;</span><br><span class="line">        head:     newDLinkerNode(<span class="string">&quot;&quot;</span>, <span class="keyword">struct</span>&#123;&#125;&#123;&#125;),</span><br><span class="line">        tail:     newDLinkerNode(<span class="string">&quot;&quot;</span>, <span class="keyword">struct</span>&#123;&#125;&#123;&#125;),</span><br><span class="line">        capacity: capacity,</span><br><span class="line">        cache:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*DLinkerNode),</span><br><span class="line">    &#125;</span><br><span class="line">    lru.head.post = lru.tail</span><br><span class="line">    lru.tail.pre = lru.head</span><br><span class="line">    <span class="keyword">return</span> lru</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">根据key值查询查询LRU缓存中的元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    node, ok := lru.cache[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ok</span><br><span class="line">    &#125;</span><br><span class="line">    lru.moveToHead(node)</span><br><span class="line">    <span class="keyword">return</span> node.value, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">向LRU缓存中添加元素</span></span><br><span class="line"><span class="comment">第一个返回值代表删除的元素的value 第二个返回值表示是否添加成功</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span> <span class="title">Put</span><span class="params">(key <span class="keyword">string</span>, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    node, ok := lru.cache[key]</span><br><span class="line">    <span class="comment">// 存在-&gt;更新value值并移至头部</span></span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        node.value = value</span><br><span class="line">        lru.moveToHead(node)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不存在-&gt;创建节点,添加至头部</span></span><br><span class="line">    node = newDLinkerNode(key, value)</span><br><span class="line">    lru.addToHead(node)</span><br><span class="line">    <span class="comment">// 更新cache</span></span><br><span class="line">    lru.cache[key] = node</span><br><span class="line">    lru.count++</span><br><span class="line">    <span class="comment">// size超过限定的容量</span></span><br><span class="line">    <span class="keyword">if</span> lru.Size() &gt; lru.capacity &#123;</span><br><span class="line">        <span class="comment">//删除尾部节点</span></span><br><span class="line">        removeNode := lru.removeTail()</span><br><span class="line">        <span class="comment">//更新cache</span></span><br><span class="line">        <span class="built_in">delete</span>(lru.cache, removeNode.key)</span><br><span class="line">        lru.count--</span><br><span class="line">        <span class="keyword">return</span> removeNode.value, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">删除LRU缓存中key对应的元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span> <span class="title">Del</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    node, ok := lru.cache[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123; <span class="comment">// 不存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ok</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存在则移除该节点</span></span><br><span class="line">    lru.removeNode(node)</span><br><span class="line">    <span class="comment">// 更新cache</span></span><br><span class="line">    <span class="built_in">delete</span>(lru.cache, key)</span><br><span class="line">    lru.count--</span><br><span class="line">    <span class="keyword">return</span> node.value, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将节点移至头部</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span> <span class="title">moveToHead</span><span class="params">(node *DLinkerNode)</span></span> &#123;</span><br><span class="line">    lru.removeNode(node)</span><br><span class="line">    lru.addToHead(node)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除对应的节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span> <span class="title">removeNode</span><span class="params">(node *DLinkerNode)</span></span> &#123;</span><br><span class="line">    node.pre.post = node.post</span><br><span class="line">    node.post.pre = node.pre</span><br><span class="line">    node.pre = <span class="literal">nil</span></span><br><span class="line">    node.post = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个节点到头部</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span> <span class="title">addToHead</span><span class="params">(node *DLinkerNode)</span></span> &#123;</span><br><span class="line">    node.pre = lru.head</span><br><span class="line">    node.post = lru.head.post</span><br><span class="line">    lru.head.post.pre = node</span><br><span class="line">    lru.head.post = node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除尾部节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lru *LRUCache)</span> <span class="title">removeTail</span><span class="params">()</span> *<span class="title">DLinkerNode</span></span> &#123;</span><br><span class="line">    node := lru.tail.pre</span><br><span class="line">    lru.removeNode(node)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;LRU 全称是 Least Recently Used，即&lt;strong&gt;最近最久未使用&lt;/strong&gt;算法，它是页面置换算法的一种。&lt;/p&gt;
&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;LRU 算法根据数据的历史访问记录来进行淘汰数据，其核心思想是「如果数据最近被访问过，那么将来被访问的几率也更高」。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://cwww3.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
