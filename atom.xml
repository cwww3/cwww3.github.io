<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cwww3&#39;s Blog</title>
  
  <subtitle>Record what you think</subtitle>
  <link href="https://cwww3.github.io/atom.xml" rel="self"/>
  
  <link href="https://cwww3.github.io/"/>
  <updated>2021-11-27T12:52:54.136Z</updated>
  <id>https://cwww3.github.io/</id>
  
  <author>
    <name>Cwww3</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTPS</title>
    <link href="https://cwww3.github.io/2021/11/27/HTTPS/"/>
    <id>https://cwww3.github.io/2021/11/27/HTTPS/</id>
    <published>2021-11-27T12:52:40.000Z</published>
    <updated>2021-11-27T12:52:54.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTP 由于是明⽂传输，所以安全上存在以下三个⻛险：</p><p>窃听⻛险，⽐如通信链路上可以获取通信内容，⽤户号容易没。</p><p>篡改⻛险，⽐如强制植⼊垃圾⼴告，视觉污染，⽤户眼容易瞎。</p><p>冒充⻛险，⽐如冒充淘宝⽹站，⽤户钱容易没。</p><span id="more"></span><p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加⼊了 SSL/TLS 协议，可以很好的解决HTTP的安全问题。</p><ul><li><p>混合加密的⽅式实现信息的机密性，解决了窃听的⻛险。</p><p>在通信建⽴前采⽤⾮对称加密的⽅式交换「会话秘钥」，后续就不再使⽤⾮对称加密。</p><p>在通信过程中全部使⽤对称加密的「会话秘钥」的⽅式加密明⽂数据。</p><p>对称加密只使⽤⼀个密钥，运算速度快，密钥必须保密，⽆法做到安全的密钥交换。⾮对称加密使⽤两个密钥：公钥和私钥，公钥可以任意分发⽽私钥保密，解决了密钥交换问题但速度慢。</p><img src="https://gitee.com/captain233/picture/raw/master/image-20211127200955709.png" alt="image-20211127200955709" style="zoom:25%;" /></li><li><p>摘要算法的⽅式来实现完整性，它能够为数据⽣成独⼀⽆⼆的「指纹」，指纹⽤于校验数据的完整性，解决了篡改的⻛险。</p><p>客户端在发送明⽂之前会通过摘要算法算出明⽂的「指纹」，发送的时候把「指纹 + 明⽂」⼀同加密成密⽂后，发送给服务器，服务器解密后，⽤相同的摘要算法算出发送过来的明⽂，通过⽐较客户端携带的「指纹」和当前算出的「指纹」做⽐较，若「指纹」相同，说明数据是完整的。</p><img src="https://gitee.com/captain233/picture/raw/master/image-20211127201037389.png" alt="image-20211127201037389" style="zoom:25%;" /></li></ul><ul><li><p>数字证书，解决了冒充的⻛险。</p><p>客户端先向服务器端索要公钥，然后⽤公钥加密信息，服务器收到密⽂后，⽤⾃⼰的私钥解密。这就存在些问题，如何保证公钥不被篡改和信任度？所以这⾥就需要借助第三⽅权威机构 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。</p></li></ul><p>​                                                                        <img src="https://gitee.com/captain233/picture/raw/master/image-20211127201414160.png" alt="image-20211127201414160" style="zoom:33%;" /></p><h3 id="SSL-TLS-协议基本流程"><a href="#SSL-TLS-协议基本流程" class="headerlink" title="SSL/TLS 协议基本流程"></a>SSL/TLS 协议基本流程</h3><p>TSL四次握手</p><img src="https://gitee.com/captain233/picture/raw/master/image-20211127204231432.png" alt="image-20211127204231432" style="zoom:50%;" /><ul><li>ClientHello</li></ul><p>⾸先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。</p><p>在这⼀步，客户端主要向服务器发送以下信息：</p><p>（1）客户端⽀持的 SSL/TLS 协议版本，如 TLS 1.2 版本。</p><p>（2）客户端⽣产的随机数（ Client Random ），后⾯⽤于⽣产「会话秘钥」。</p><p>（3）客户端⽀持的密码套件列表，如 RSA 加密算法。</p><ul><li>ServerHello</li></ul><p>服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello 。服务器回应的内容有如下内容：</p><p>（1）确认 SSL/ TLS 协议版本，如果浏览器不⽀持，则关闭加密通信。</p><p>（2）服务器⽣产的随机数（ Server Random ），后⾯⽤于⽣产「会话秘钥」。</p><p>（3）确认的密码套件列表，如 RSA 加密算法。</p><p>（4）服务器的数字证书。</p><ul><li>客户端回应</li></ul><p>客户端收到服务器的回应之后，⾸先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</p><p>如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使⽤它加密报⽂，向服务器发送如下信息：</p><p>（1）⼀个随机数（ pre-master key ）。该随机数会被服务器公钥加密。</p><p>（2）加密通信算法改变通知，表示随后的信息都将⽤「会话秘钥」加密通信。</p><p>（3）客户端握⼿结束通知，表示客户端的握⼿阶段已经结束。这⼀项同时把之前所有内容的发⽣的数据做个摘要，⽤来供服务端校验。上⾯第⼀项的随机数是整个握⼿阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就⽤双⽅协商的加密算法，各⾃⽣成本次通信的「会话秘钥」。</p><ul><li>服务器的最后回应</li></ul><p>服务器收到客户端的第三个随机数（ pre-master key ）之后，通过协商的加密算法，计算出本次通信的「会话秘</p><p>钥」。然后，向客户端发⽣最后的信息：</p><p>（1）加密通信算法改变通知，表示随后的信息都将⽤「会话秘钥」加密通信。</p><p>（2）服务器握⼿结束通知，表示服务器的握⼿阶段已经结束。这⼀项同时把之前所有内容的发⽣的数据做个摘</p><p>要，⽤来供客户端校验。</p><p>⾄此，整个 SSL/TLS 的握⼿阶段全部结束。接下来，客户端与服务器进⼊加密通信，就完全是使⽤普通的 HTTP</p><p>协议，只不过⽤「会话秘钥」加密内容。</p><p>事实上，不同的密钥交换算法，TLS 的握⼿过程可能会有⼀些区别。</p><p>这⾥先简单介绍下密钥交换算法，因为考虑到性能的问题，所以双⽅在加密应⽤信息时使⽤的是对称加密密钥，⽽</p><p>对称加密密钥是不能被泄漏的，为了保证对称加密密钥的安全性，所以使⽤⾮对称加密的⽅式来保护对称加密密钥</p><p>的协商，这个⼯作就是密钥交换算法负责的。接下来，我们就以最简单的 RSA 密钥交换算法，来看看它的 TLS 握⼿过程。</p><img src="https://gitee.com/captain233/picture/raw/master/16380164319252.png" alt="16380164319252"  /><p><strong>RSA</strong> 算法的缺陷</p><p>使⽤ <strong>RSA</strong> 密钥协商算法的最⼤问题是不⽀持<strong>前向保密</strong>。因为客户端传递随机数（⽤于⽣成对称加密密钥的条件之</p><p>⼀）给服务端时使⽤的是公钥加密的，服务端收到到后，会⽤私钥解密得到随机数。所以⼀旦服务端的私钥泄漏</p><p>了，过去被第三⽅截获的所有 TLS 通讯密⽂都会被破解。</p><p>为了解决这⼀问题，于是就有了 DH 密钥协商算法，这⾥简单介绍它的⼯作流程。</p><img src="https://gitee.com/captain233/picture/raw/master/image-20211127204841502.png" alt="image-20211127204841502" style="zoom:50%;" /><p>客户端和服务端各⾃会⽣成随机数，并以此作为私钥，然后根据公开的 DH 计算公示算出各⾃的公钥，通过 TLS</p><p>握⼿双⽅交换各⾃的公钥，这样双⽅都有⾃⼰的私钥和对⽅的公钥，然后双⽅根据各⾃持有的材料算出⼀个随机</p><p>数，这个随机数的值双⽅都是⼀样的，这就可以作为后续对称加密时使⽤的密钥。</p><p> DH 密钥交换过程中，即使第三⽅截获了 <strong>TLS</strong> 握⼿阶段传递的公钥，在不知道的私钥的情况下，也是⽆法计算出</p><p>密钥的，⽽且每⼀次对称加密密钥都是实时⽣成的，实现前向保密。但因为 DH 算法的计算效率问题，后⾯出现了 ECDHE 密钥协商算法，我们现在⼤多数⽹站使⽤的正是 ECDHE 密钥协商算法。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;HTTPS&quot;&gt;&lt;a href=&quot;#HTTPS&quot; class=&quot;headerlink&quot; title=&quot;HTTPS&quot;&gt;&lt;/a&gt;HTTPS&lt;/h2&gt;&lt;p&gt;HTTP 由于是明⽂传输，所以安全上存在以下三个⻛险：&lt;/p&gt;
&lt;p&gt;窃听⻛险，⽐如通信链路上可以获取通信内容，⽤户号容易没。&lt;/p&gt;
&lt;p&gt;篡改⻛险，⽐如强制植⼊垃圾⼴告，视觉污染，⽤户眼容易瞎。&lt;/p&gt;
&lt;p&gt;冒充⻛险，⽐如冒充淘宝⽹站，⽤户钱容易没。&lt;/p&gt;</summary>
    
    
    
    
    <category term="网络" scheme="https://cwww3.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Nginx</title>
    <link href="https://cwww3.github.io/2021/11/27/Nginx/"/>
    <id>https://cwww3.github.io/2021/11/27/Nginx/</id>
    <published>2021-11-27T10:00:07.000Z</published>
    <updated>2021-11-27T12:02:32.533Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h3 id="二进制安装"><a href="#二进制安装" class="headerlink" title="二进制安装"></a>二进制安装</h3><p><a href="http://nginx.org/en/download.html">安装地址</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压nginx压缩包并进入nginx-1.20.2</span></span><br><span class="line">tar -xf nginx-1.20.2.tar.gz &amp;&amp; cd nginx-1.20.2</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装所需软件</span></span><br><span class="line">yum install -y pcre pcre-devel  #支持nginx的正则</span><br><span class="line">yum install -y openssl openssl-devel     #加密认证</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行./configure 配置环境 生成Makefile文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> prefix指定安装的路径</span></span><br><span class="line">./configure --user=nginx --group=nginx --prefix=/etc/nginx/ --with-http_stub_status_module --with-http_ssl_module --with-pcre</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译并且安装</span> </span><br><span class="line">make&amp;&amp;make install</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置PATH路径</span> </span><br><span class="line">export PAHT=$PATH:/etc/nginx/sbin</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="Nginx命令"><a href="#Nginx命令" class="headerlink" title="Nginx命令"></a>Nginx命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示nginx的版本号和编译信息</span></span><br><span class="line">nginx -V </span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查默认配置文件 /etc/nginx/conf/nginx.conf</span></span><br><span class="line">nginx -t</span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查指定配置文件</span></span><br><span class="line">nginx -t -c xxx.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新加载配置文件</span></span><br><span class="line">nginx -s reload</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭</span></span><br><span class="line">nginx -s quit</span><br></pre></td></tr></table></figure><h3 id="添加到Systemd中管理"><a href="#添加到Systemd中管理" class="headerlink" title="添加到Systemd中管理"></a>添加到Systemd中管理</h3><ul><li>Systemctl 介绍</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看版本</span></span><br><span class="line">systemctl --version </span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有可用单元（服务）</span></span><br><span class="line">systemctl list-unit-files</span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有运行中的单元</span></span><br><span class="line">systemctl list-units</span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有失败的单元</span></span><br><span class="line">systemctl --failed</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看自启动的软件</span></span><br><span class="line">systemctl list-unit-files | grep enable</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改了配置文件后，重载配置文件</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看nginx是否开机启动</span></span><br><span class="line">systemctl is-enabled nginx.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看nginx状态</span></span><br><span class="line">systemctl status nginx.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动nginx单元</span></span><br><span class="line">systemctl start nginx.service，</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启nginx单元</span></span><br><span class="line">systemctl restart nginx.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止nginx单元</span></span><br><span class="line">systemctl stop nginx.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重载nginx配置</span></span><br><span class="line">systemctl reload nginx.service，</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置开机自启动。</span></span><br><span class="line">systemctl enable nginx.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭开机自启动</span></span><br><span class="line">systemctl disable nginx.service</span><br></pre></td></tr></table></figure><ul><li>将nginx加入管理</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在系统服务目录里创建nginx.service文件</span></span><br><span class="line">vim /usr/lib/systemd/system/nginx.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 写入</span></span><br><span class="line">[Unit] # 服务的说明</span><br><span class="line">Description=nginx # 描述服务</span><br><span class="line">After=network.target # 描述服务类别</span><br><span class="line"></span><br><span class="line">[Service] # 服务运行参数的设置</span><br><span class="line">Type=forking # 后台运行的形式</span><br><span class="line"><span class="meta">#</span><span class="bash"> [Service]的启动、重启、停止命令全部要求使用绝对路径</span></span><br><span class="line">ExecStart=/etc/nginx/sbin/nginx # 服务的具体运行命令</span><br><span class="line">ExecReload=/etc/nginx/sbin/nginx -s reload # 重启命令</span><br><span class="line">ExecStop=/etc/nginx/sbin/nginx -s quit # 停止命令</span><br><span class="line">PrivateTmp=true # PrivateTmp=True表示给服务分配独立的临时空间</span><br><span class="line"></span><br><span class="line">[Install] # [Install]运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加载配置</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动nginx</span></span><br><span class="line">systemctl start nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开机自启动nginx</span></span><br><span class="line">systemctl enable nginx</span><br></pre></td></tr></table></figure><h3 id="添加Nginx模块"><a href="#添加Nginx模块" class="headerlink" title="添加Nginx模块"></a>添加Nginx模块</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建并进入目录</span></span><br><span class="line">madir -p /data/software &amp;&amp; cd /data/software</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载</span></span><br><span class="line">git clone git@github.com:arut/nginx-rtmp-module.git</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 nginx编译信息</span></span><br><span class="line">nginx -V </span><br><span class="line"></span><br><span class="line">nginx version: nginx/1.20.2</span><br><span class="line">built by gcc 8.5.0 20210514 (Red Hat 8.5.0-4) (GCC)</span><br><span class="line">built with OpenSSL 1.1.1k  FIPS 25 Mar 2021</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --user=nginx --group=nginx --prefix=/etc/nginx/ --with-http_stub_status_module --with-http_ssl_module --with-pcre</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止nginx</span></span><br><span class="line">systemctl stop nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入nginx安装目录</span></span><br><span class="line">cd /usr/local/src/nginx-1.20.2</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行 通过 --add-module添加刚才git下载的模块</span></span><br><span class="line">./configure --user=nginx --group=nginx --prefix=/etc/nginx/ --with-http_stub_status_module --with-http_ssl_module --with-pcre --add-module=/data/software/nginx-rtmp-module</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行make</span></span><br><span class="line">make       # 不需要执行make install不然会覆盖</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 替换nginx二进制文件</span></span><br><span class="line">cp /etc/nginx/sbin/nginx /etc/nginx/sbin/nginx.bak</span><br><span class="line">rm /etc/nginx/sbin/nginx</span><br><span class="line">cp ./objs/nginx /etc/nginx/sbin/nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行nginx -V 查看配置</span></span><br><span class="line">nginx version: nginx/1.20.2</span><br><span class="line">built by gcc 8.5.0 20210514 (Red Hat 8.5.0-4) (GCC)</span><br><span class="line">built with OpenSSL 1.1.1k  FIPS 25 Mar 2021</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --user=nginx --group=nginx --prefix=/etc/nginx/ --with-http_stub_status_module --with-http_ssl_module --with-pcre --add-module=/data/software/nginx-rtmp-module</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Nginx&quot;&gt;&lt;a href=&quot;#Nginx&quot; class=&quot;headerlink&quot; title=&quot;Nginx&quot;&gt;&lt;/a&gt;Nginx&lt;/h2&gt;&lt;h3 id=&quot;二进制安装&quot;&gt;&lt;a href=&quot;#二进制安装&quot; class=&quot;headerlink&quot; title=&quot;二进制安装&quot;&gt;&lt;/a&gt;二进制安装&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://nginx.org/en/download.html&quot;&gt;安装地址&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 解压nginx压缩包并进入nginx-1.20.2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tar -xf nginx-1.20.2.tar.gz &amp;amp;&amp;amp; cd nginx-1.20.2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 安装所需软件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum install -y pcre pcre-devel  #支持nginx的正则&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum install -y openssl openssl-devel     #加密认证&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 执行./configure 配置环境 生成Makefile文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; prefix指定安装的路径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;./configure --user=nginx --group=nginx --prefix=/etc/nginx/ --with-http_stub_status_module --with-http_ssl_module --with-pcre&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 编译并且安装&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;make&amp;amp;&amp;amp;make install&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 配置PATH路径&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export PAHT=$PATH:/etc/nginx/sbin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Nginx" scheme="https://cwww3.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>HTTP</title>
    <link href="https://cwww3.github.io/2021/11/27/HTTP/"/>
    <id>https://cwww3.github.io/2021/11/27/HTTP/</id>
    <published>2021-11-27T04:03:04.000Z</published>
    <updated>2021-11-27T04:45:39.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP  （HyperText Transfer Protocol）超文本传输协议</p><p><strong>HTTP</strong> 是⼀个在计算机世界⾥专⻔在「两点」之间「传输」⽂字、图⽚、⾳频、视频等「超⽂本」数据的「约定和规范」。</p><span id="more"></span><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><ul><li>1xx</li></ul><p>1xx 类状态码属于提示信息，是协议处理中的⼀种中间状态，实际⽤到的⽐较少。</p><ul><li>2xx</li></ul><p>2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。</p><p>「<strong>200 OK</strong>」是最常⻅的成功状态码，表示⼀切正常。如果是⾮ HEAD 请求，服务器返回的响应头都会有 body 数据。</p><p>「<strong>204 No Content</strong>」也是常⻅的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。「<strong>206 Partial Content</strong>」是应⽤于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，⽽是其中的⼀部分，也是服务器处理成功的状态。</p><ul><li>3xx</li></ul><p>3xx 类状态码表示客户端请求的资源发送了变动，需要客户端⽤新的 URL 重新发送请求获取资源，也就是重定向。</p><p>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改⽤新的 URL 再次访问。</p><p>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问。</p><p>301 和 302 都会在响应头⾥使⽤字段 Location ，指明后续要跳转的 URL，浏览器会⾃动重定向新的 URL。 </p><p>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲⽂件，也称缓存重定向，⽤于缓存控制。</p><ul><li>4xx</li></ul><p>4xx 类状态码表示客户端发送的报⽂有误，服务器⽆法处理，也就是错误码的含义。</p><p>「<strong>400 Bad Request</strong>」表示客户端请求的报⽂有错误，但只是个笼统的错误。</p><p>「<strong>401 Unauthorized</strong>」表示服务器需要客户端提供认证信息。</p><p>「<strong>403 Forbidden</strong>」表示服务器禁⽌访问资源，并不是客户端的请求出错。</p><p>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以⽆法提供给客户端。</p><ul><li><em>5xx</em></li></ul><p>5xx 类状态码表示客户端请求报⽂正确，但是服务器处理时内部发⽣了错误，属于服务器端的错误码。</p><p>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通⽤的错误码，服务器发⽣了什么错误，我们并不知道。</p><p>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思。</p><p>「<strong>502 Bad Gateway</strong>」通常是<strong>服务器作为⽹关或代理时</strong>返回的错误码，表示服务器⾃身⼯作正常，访问后端服务器发⽣了错误。</p><p>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时⽆法响应服务器，类似“⽹络服务正忙，请稍后重试”的意思。</p><h3 id="HTTP常⻅字段"><a href="#HTTP常⻅字段" class="headerlink" title="HTTP常⻅字段"></a>HTTP常⻅字段</h3><ul><li>HOST</li></ul><p>客户端发送请求时，⽤来指定服务器的域名。</p><ul><li><em>Content-Length</em></li></ul><p>服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据⻓度。</p><ul><li><em>Connection</em></li></ul><p>Connection 字段最常⽤于客户端要求服务器使⽤ TCP 持久连接，以便其他请求复⽤。</p><p>HTTP/1.1 版本的默认连接都是持久连接，但为了兼容⽼版本的 HTTP，需要指定 Connection ⾸部字段的值为Keep-Alive 。</p><ul><li> Accept / <em>Content-Type</em></li></ul><p>客户端请求的时候，可以使⽤ Accept 字段声明⾃⼰可以接受哪些数据格式。</p><p>Content-Type 字段⽤于服务器回应时，告诉客户端，本次数据是什么格式。</p><ul><li>Accept-Encoding / Content-Encoding</li></ul><p>Content-Encoding 字段说明数据的压缩⽅法。表示服务器返回的数据使⽤了什么压缩格式</p><p>客户端在请求时，⽤ Accept-Encoding 字段说明⾃⼰可以接受哪些压缩⽅法。</p><h3 id="HTTP-特性"><a href="#HTTP-特性" class="headerlink" title="HTTP 特性"></a><strong>HTTP</strong> 特性</h3><ul><li>简单</li></ul><p>HTTP 基本的报⽂格式就是 header + body ，头部信息也是 key-value 简单⽂本的形式，易于理解，降低了学习和使⽤的⻔槛。</p><ul><li>灵活和易于扩展</li></ul><p>HTTP协议⾥的各类请求⽅法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发⼈员⾃定义和扩充。</p><ul><li>无状态</li></ul><p>⽆状态的好处，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存⽤来对外提供服务。</p><p>⽆状态的坏处，既然服务器没有记忆能⼒，它在完成有关联性的操作时会⾮常麻烦。例如登录-&gt;添加购物⻋-&gt;下单-&gt;结算-&gt;⽀付，这系列操作都要知道⽤户的身份才⾏。但服务器不知道这些请求是有关联的，每次都要问⼀遍身份信息。</p><p>对于⽆状态的问题，解法⽅案有很多种，其中⽐较简单的⽅式⽤ <strong>Cookie</strong> 技术。</p><img src="https://gitee.com/captain233/picture/raw/master/image-20211127124400027.png" alt="image-20211127124400027" style="zoom:33%;" /><ul><li>明⽂传输</li></ul><p>明⽂意味着在传输过程中的信息，是可⽅便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接⾁眼查看，为我们调试⼯作带了极⼤的便利性。</p><ul><li>不安全</li></ul><p>通信使⽤明⽂（不加密），内容可能会被窃听。不验证通信⽅的身份，因此有可能遭遇伪装。⽆法证明报⽂的完整性，所以有可能已遭篡改。可以通过引⼊ SSL/TLS 层，使得在安全上达到了极致。</p><h3 id="HTTP性能"><a href="#HTTP性能" class="headerlink" title="HTTP性能"></a>HTTP性能</h3><p>HTTP 协议是基于 <strong>TCP/IP</strong>，并且使⽤了「请求 <strong>-</strong> 应答」的通信模式，所以性能的关键就在这两点⾥。</p><ul><li>长连接</li></ul><p>早期 HTTP/1.0 性能上的⼀个很⼤的问题，那就是每发起⼀个请求，都要新建⼀次 TCP 连接（三次握⼿），⽽且是串⾏请求，做了⽆谓的 TCP 连接建⽴和断开，增加了通信开销。为了解决上述 TCP 连接问题，HTTP/1.1 提出了⻓连接的通信⽅式，也叫持久连接。这种⽅式的好处在于减少了TCP 连接的重复建⽴和断开所造成的额外开销，减轻了服务器端的负载。持久连接的特点是，只要任意⼀端没有明确提出断开连接，则保持 TCP 连接状态。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211127111558513.png" alt="image-20211127111558513" style="zoom:33%;" /><ul><li>管道传输</li></ul><p>可在同⼀个 TCP 连接⾥⾯，客户端可以发起多个请求，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以减少整体的响应时间。但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是前⾯的回应特别慢，后⾯就会有许多请求排队等着。这称为「队头堵塞」。</p><h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><h4 id="避免发送-重复的HTTP-请求"><a href="#避免发送-重复的HTTP-请求" class="headerlink" title="避免发送 重复的HTTP 请求"></a>避免发送 重复的<strong>HTTP</strong> 请求</h4><p>通过<strong>缓存技术</strong>，对于⼀些具有重复性的 HTTP 请求，⽐如每次请求得到的数据都⼀样的，我们可以把这对「请求-响应」的数据都缓存在本地，那么下次就直接读取本地的数据，不必在通过⽹络获取服务器的响应了。</p><p>客户端会把第⼀次请求以及响应的数据保存在本地磁盘上，其中将请求的 URL 作为 key，⽽响应作为 value，两者形成映射关系。这样当后续发起相同的请求时，就可以先在本地磁盘上通过 key 查到对应的 value，也就是响应，如果找到了，就直接从本地读取该响应。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211127113034457.png" alt="image-20211127113034457" style="zoom:33%;" /><p>万⼀缓存的响应不是最新的，⽽客户端并不知情，<strong>那么该怎么办呢</strong>？</p><p>服务器在发送 HTTP 响应时，会估算⼀个过期的时间，并把这个信息放到响应头部中，这样客户端在查看响应头部的信息时，⼀旦发现缓存的响应是过期的，则就会重新发送⽹络请求。</p><p>如果客户端从第⼀次请求得到的响应头部中发现该响应过期了，客户端重新发送请求，假设服务器上的资源并没有变更，还是⽼样⼦，那么服务器的响应应该带上这个资源吗？很显然不带的话，可以提⾼ HTTP 协议的性能，<strong>那具体如何做到呢</strong>？</p><p>只需要客户端在重新发送请求时，在请求的 Etag 头部带上第⼀次请求的响应头部中的摘要，这个摘要是唯⼀标识响应的资源，当服务器收到请求后，会将本地资源的摘要与请求中的摘要做个⽐较。如果不同，那么说明客户端的缓存已经没有价值，服务器在响应中带上最新的资源。如果相同，说明客户端的缓存还是可以继续使⽤的，那么服务器仅返回不含有包体的 304 Not Modified 304 Not Modified 响应，告诉客户端仍然有效，这样就可以减少响应资源在⽹络中传输的延时。</p><img src="https://gitee.com/captain233/picture/raw/master/image-20211127124511250.png" alt="image-20211127124511250" style="zoom:25%;" /><h4 id="减少-HTTP-请求次数"><a href="#减少-HTTP-请求次数" class="headerlink" title="减少 HTTP 请求次数"></a>减少 <strong>HTTP</strong> 请求次数</h4><ul><li>减少重定向请求次数</li></ul><p>服务器上的⼀个资源可能由于迁移、维护等原因从 url1 移⾄ url2 后，⽽客户端不知情，它还是继续请求 url1，这时服务器不能粗暴地返回错误，⽽是通过 302 响应码和 Location 头部，告诉客户端该资源已经迁移⾄ url2了，于是客户端需要再发送 url2 请求以获得服务器的资源。</p><p>如果重定向请求越多，那么客户端就要多次发起 HTTP 请求，每⼀次的 HTTP 请求都得经过⽹络，这⽆疑会越降低⽹络性能。</p><p>另外，服务端这⼀⽅往往不只有⼀台服务器，⽐如源服务器上⼀级是代理服务器，然后代理服务器才与客户端通信，这时客户端重定向就会导致客户端与代理服务器之间需要 2 次消息传递。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211127114016498.png" alt="image-20211127114016498" style="zoom:33%;" /><p>如果重定向的⼯作交由代理服务器完成，就能减少 <strong>HTTP</strong> 请求次数了</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211127114045230.png" alt="image-20211127114045230" style="zoom: 33%;" /><p>⽽且当代理服务器知晓了重定向规则后，可以进⼀步减少消息传递次数</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211127114147959.png" alt="image-20211127114147959" style="zoom:33%;" /><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211127114329172.png" alt="image-20211127114329172" style="zoom:33%;" /><p>其中， 301 和 308 响应码是告诉客户端可以将重定向响应缓存到本地磁盘，之后客户端就⾃动⽤ url2 替代 url1访问服务器的资源。</p><ul><li>合并请求</li></ul><p>如果把多个访问⼩⽂件的请求合并成⼀个⼤的请求，虽然传输的总资源还是⼀样，但是减少请求，也就意味着减少了重复发送的 <strong>HTTP</strong> 头部。</p><p>另外由于 HTTP/1.1 是请求响应模型，如果第⼀个发送的请求，未收到对应的响应，那么后续的请求就不会发送，于是为了防⽌单个请求的阻塞，所以⼀般浏览器会同时发起 5-6 个请求，每⼀个请求都是不同的 TCP 连接，那么如果合并了请求，也就会减少 <strong>TCP</strong> 连接的数量，因⽽省去了 <strong>TCP</strong> 握⼿和慢启动过程耗费的时间。</p><p>有的⽹⻚会含有很多⼩图⽚、⼩图标，有多少个⼩图⽚，客户端就要发起多少次请求。那么对于这些⼩图⽚，我们可以考虑使⽤ CSS Image Sprites 技术把它们合成⼀个⼤图⽚，这样浏览器就可以⽤⼀次请求获得⼀个⼤图⽚，然后再根据 CSS 数据把⼤图⽚切割成多张⼩图⽚。</p><p>除了将⼩图⽚合并成⼤图⽚的⽅式，还有服务端使⽤ webpack 等打包⼯具将 js、css 等资源合并打包成⼤⽂件，也是能达到类似的效果。</p><p>还可以将图⽚的⼆进制数据⽤ base64 编码后，以 URL 的形式潜⼊到 HTML ⽂件，跟随 HTML ⽂件⼀并发送.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">image</span></span></span><br><span class="line"><span class="tag"><span class="attr">src</span>=<span class="string">&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPoAAAFKCAIAAAC7M9WrAAAACXBIWXMAA</span></span></span><br><span class="line"><span class="string"><span class="tag">... /&gt;</span></span></span><br></pre></td></tr></table></figure><p>但是这样的合并请求会带来新的问题，当⼤资源中的某⼀个⼩资源发⽣变化后，客户端必须重新下载整个完整的⼤资源⽂件，这显然带来了额外的⽹络消耗。</p><ul><li>延迟发送请求</li></ul><p>请求⽹⻚的时候，没必要把全部资源都获取到，⽽是只获取当前⽤户所看到的⻚⾯资源，当⽤户向下滑动⻚⾯的时候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果。</p><h4 id="减少-HTTP-响应的数据⼤⼩"><a href="#减少-HTTP-响应的数据⼤⼩" class="headerlink" title="减少 HTTP 响应的数据⼤⼩"></a>减少 <strong>HTTP</strong> 响应的数据⼤⼩</h4><p>对于 HTTP 的请求和响应，通常 HTTP 的响应的数据⼤⼩会⽐较⼤，也就是服务器返回的资源会⽐较⼤。</p><p>于是，我们可以考虑对响应的资源进⾏压缩，这样就可以减少响应的数据⼤⼩，从⽽提⾼⽹络传输的效率。压缩的⽅式⼀般分为 2 种:</p><ul><li>⽆损压缩</li></ul><p>⽆损压缩是指资源经过压缩后，信息不被破坏，还能完全恢复到压缩前的原样，适合⽤在⽂本⽂件、程序可执⾏⽂件、程序源代码。</p><p>⾸先，我们针对代码的语法规则进⾏压缩，因为通常代码⽂件都有很多换⾏符或者空格，这些是为了帮助程序员更好的阅读，但是机器执⾏时并不要这些符，把这些多余的符号给去除掉。</p><p>接下来，就是⽆损压缩了，需要对原始资源建⽴统计模型，利⽤这个统计模型，将常出现的数据⽤较短的⼆进制⽐特序列表示，将不常出现的数据⽤较⻓的⼆进制⽐特序列表示，⽣成⼆进制⽐特序列⼀般是「霍夫曼编码」算法。</p><p>gzip 就是⽐较常⻅的⽆损压缩。客户端⽀持的压缩算法，会在 HTTP 请求中通过头部中的 Accept-Encoding 字段。</p><p>gzip 的压缩效率相⽐ Google 推出的 Brotli 算法还是差点意思，所以如果可以，服务器应该选择压缩效率更⾼的 br 压缩算法。</p><ul><li>有损压缩</li></ul><p>与⽆损压缩相对的就是有损压缩，经过此⽅法压缩，解压的数据会与原始数据不同但是⾮常接近。</p><p>有损压缩主要将次要的数据舍弃，牺牲⼀些质ᰁ来减少数据ᰁ、提⾼压缩⽐，这种⽅法经常⽤于压缩多媒体数据，⽐如⾳频、视频、图⽚。</p><p>可以通过 HTTP 请求头部中的 Accept 字段⾥的「 q 质量因⼦」，告诉服务器期望的资源质量</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>audio/*; q=0.2, audio/basic</span><br></pre></td></tr></table></figure><p>关于图⽚的压缩，⽬前压缩⽐较⾼的是 Google 推出的 <strong>WebP</strong> 格式，相同质量的图片下，WebP 格式的图⽚⼤⼩都⽐ Png 格式的图⽚⼩。</p><p>关于⾳视频的压缩，⾳视频主要是动态的，每个帧都有时序的关系，通常时间连续的帧之间的变化是很⼩的。</p><p>⽐如，⼀个在看书的视频，画⾯通常只有⼈物的⼿和书桌上的书是会有变化的，⽽其他地⽅通常都是静态的，于是只需要在⼀个静态的关键帧，使⽤<strong>增量数据</strong>来表达后续的帧，这样便减少了很多数据，提⾼了⽹络传输的性能。对于视频常⻅的编码格式有 H264、H265 等，⾳频常⻅的编码格式有 AAC、AC3。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h2&gt;&lt;p&gt;HTTP  （HyperText Transfer Protocol）超文本传输协议&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP&lt;/strong&gt; 是⼀个在计算机世界⾥专⻔在「两点」之间「传输」⽂字、图⽚、⾳频、视频等「超⽂本」数据的「约定和规范」。&lt;/p&gt;</summary>
    
    
    
    
    <category term="网络" scheme="https://cwww3.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>IO</title>
    <link href="https://cwww3.github.io/2021/11/18/IO/"/>
    <id>https://cwww3.github.io/2021/11/18/IO/</id>
    <published>2021-11-18T03:22:05.000Z</published>
    <updated>2021-11-18T03:22:39.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><ul><li><p>可以进行I/O操作的内核对象</p></li><li><p>文件、管道、套接字等都是流</p></li><li><p>流的入口：文件描述符(fd)</p><span id="more"></span><h3 id="I-O操作"><a href="#I-O操作" class="headerlink" title="I/O操作"></a>I/O操作</h3></li><li><p>对流的读写操作称为I/O操作</p></li></ul><h3 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h3><ul><li>同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。</li><li>异步就是发一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时可以处理其他的请求，被调用者通常依靠事件、回调等机制来通知调用者其返回结果。</li></ul><h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><ul><li>阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。不占用CPU资源。</li><li>非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他的事情。占用CPU资源(轮询)</li></ul><h3 id="同步异步与阻塞非阻塞"><a href="#同步异步与阻塞非阻塞" class="headerlink" title="同步异步与阻塞非阻塞"></a>同步异步与阻塞非阻塞</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 老张烧开水的故事</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 老张爱喝茶，废话不说，煮开水。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同步阻塞</span></span><br><span class="line">老张把水壶放到火上，立等水开。</span><br><span class="line">老张觉得自己有点傻</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同步非阻塞</span></span><br><span class="line">老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。</span><br><span class="line">老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~的噪音。</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 异步阻塞</span></span><br><span class="line">老张把响水壶放到火上，立等水开。</span><br><span class="line">老张觉得这样傻等意义不大</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 异步非阻塞</span></span><br><span class="line">老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。</span><br><span class="line">老张觉得自己聪明了。</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 所谓同步异步，只是对于水壶而言</span></span><br><span class="line">普通水壶：同步；响水壶：异步。</span><br><span class="line">虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了，这是普通水壶所不能及的。</span><br><span class="line">同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 所谓阻塞非阻塞，仅仅对于老张而言</span></span><br><span class="line">立等的老张：阻塞；看电视的老张：非阻塞。</span><br><span class="line">虽然情况3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="阻塞IO-Blocking-IO"><a href="#阻塞IO-Blocking-IO" class="headerlink" title="阻塞IO - Blocking IO"></a>阻塞IO - Blocking IO</h3><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211118105721114.png" alt="image-20211118105721114" style="zoom:33%;" /><ul><li>一请求一应答</li><li>通常由一个独立的 <code>Acceptor</code> 线程负责监听客户端的连接。我们一般通过在 <code>while(true)</code> 循环中服务端会调用 <code>accept()</code> 方法等待客户端连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待当前连接的客户端的操作执行完成，不过可以<strong>通过多线程来支持多个客户端的连接</strong></li></ul><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211118103446987.png" alt="image-20211118103446987" style="zoom: 33%;" /><h3 id="伪异步-I-O"><a href="#伪异步-I-O" class="headerlink" title="伪异步 I/O"></a>伪异步 I/O</h3><p>当客户端并发访问量增加后<strong>阻塞IO模型</strong>会出随着并发访问量增加会导致线程数急剧膨胀可能会导致线程堆栈溢出、创建新线程失败等问题，最终导致进程宕机或者僵死，不能对外提供服务。</p><p>线程是宝贵的资源。线程的创建和销毁成本很高，线程本身占用较大内存，线程的切换成本也很高，容易造成锯齿状的系统负载。</p><ul><li>解决方案</li></ul><p>后端通过一个线程池来处理多个客户端的请求接入，设置线程的最大值，防止由于海量并发接入导致线程耗尽。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211118105303658.png" alt="image-20211118105303658" style="zoom:33%;" /><h3 id="非阻塞IO-NoneBlocking-IO"><a href="#非阻塞IO-NoneBlocking-IO" class="headerlink" title="非阻塞IO - NoneBlocking IO"></a>非阻塞IO - NoneBlocking IO</h3><p>当用户线程发起一个 IO 操作后，并不需要等待，而是马上就得到一个结果。如果结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 IO 操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。</p><p>在非阻塞IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211118110037961.png" alt="image-20211118110037961" style="zoom:33%;" /><ul><li>非阻塞式主要体现在用户进程发起recvfrom系统调用的时候,这个时候系统内核还没有接收到数据报,直接返回错误给用户进程,告诉“当前还没有数据报可达,晚点再来”</li><li>用户进程接收到信息,但是用户进程不知道什么时候数据报可达,于是就开始不断轮询(polling)向系统内核发起recvfrom的系统调用“询问数据来了没”,如果没有则继续返回错误</li><li>用户进程轮询发起recvfrom系统调用直至数据报可达,这个时候需要等待系统内核复制数据报到用户进程的缓冲区,复制完成之后将返回成功提示</li></ul><h3 id="IO多路复用-IO-multiplexing"><a href="#IO多路复用-IO-multiplexing" class="headerlink" title="IO多路复用 - IO multiplexing"></a>IO多路复用 - IO multiplexing</h3><p>所谓 I/O 多路复用机制，就是说通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。这种机制的使用需要 <code>select</code> 、 <code>poll</code> 、 <code>epoll</code> 来配合。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211118110236775.png" alt="image-20211118110236775" style="zoom:33%;" /><p>在多路复用IO模型中，会有一个内核线程不断地去轮询多个 socket 的状态，只有当真正读写事件发送时，才真正调用实际的IO读写操作。<strong>因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有真正有读写事件进行时，才会使用IO资源，所以它大大减少来资源占用</strong>。</p><ul><li>IO复用模式是使用select或者poll函数向系统内核发起调用，阻塞在这两个系统函数调用，而不是真正阻塞于实际的IO操作(recvfrom调用才是实际阻塞IO操作的系统调用)</li><li>阻塞于select函数的调用,等待数据报套接字变为可读状态</li><li>当select套接字返回可读状态的时候,就可以发起recvfrom调用把数据报复制到用户空间的缓冲区</li></ul><h3 id="信号驱动IO-signal-driven-IO"><a href="#信号驱动IO-signal-driven-IO" class="headerlink" title="信号驱动IO - signal driven IO"></a>信号驱动IO - signal driven IO</h3><p>在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。这个一般用于UDP中，对TCP套接字几乎没用，原因是该信号产生得过于频繁，并且该信号的出现并没有告诉我们发生了什么请求。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211118110908521.png" alt="image-20211118110908521" style="zoom:33%;" /><h3 id="异步IO-asynchronous-IO"><a href="#异步IO-asynchronous-IO" class="headerlink" title="异步IO - asynchronous IO"></a>异步IO - asynchronous IO</h3><p>前面四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是从内核拷贝数据到用户态的过程都会让用户线程阻塞。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211118110819248.png" alt="image-20211118110819248" style="zoom:33%;" /><ul><li>由POSIX规范定义，告知系统内核启动某个操作，并让内核在整个操作包含数据等待以及数据复制过程的完成之后通知用户进程数据已经准备完成，可以进行读取数据；</li><li>与上述的信号IO模型区分在于异步是通知我们何时IO操作完成,而信号IO是通知我们何时可以启动一个IO操作</li></ul><h3 id="IO模型对比"><a href="#IO模型对比" class="headerlink" title="IO模型对比"></a>IO模型对比</h3><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211118111021556.png" alt="image-20211118111021556" style="zoom:33%;" /><h2 id="处理多I-O请求"><a href="#处理多I-O请求" class="headerlink" title="处理多I/O请求"></a>处理多I/O请求</h2><p><strong>阻塞+多进程/多线程</strong></p><p><strong>非阻塞+轮询</strong></p><p><strong>多路复用</strong></p><ul><li>select  最多监听1024个 且不会通知具体哪个流接收到数据  需要遍历全部流，进行处理。  平台无关性。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span>() <span class="comment">//阻塞</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, in := ins &#123;</span><br><span class="line">        <span class="keyword">if</span> has &#123;</span><br><span class="line">            <span class="comment">// 处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， <strong>但是它没有最大连接数的限制</strong>，原因是它是基于链表来存储的.</p></li><li><p>epoll  监听的数量与操作系统能打开的文件数相同，且返回收到数据的流。不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。Linux操作系统的方法。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    ins = epoll() <span class="comment">//阻塞 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, in := ins &#123;</span><br><span class="line">          <span class="comment">// 处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211118111811931.png" alt="image-20211118111811931" style="zoom:33%;" /></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;I-O&quot;&gt;&lt;a href=&quot;#I-O&quot; class=&quot;headerlink&quot; title=&quot;I/O&quot;&gt;&lt;/a&gt;I/O&lt;/h2&gt;&lt;h3 id=&quot;流&quot;&gt;&lt;a href=&quot;#流&quot; class=&quot;headerlink&quot; title=&quot;流&quot;&gt;&lt;/a&gt;流&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可以进行I/O操作的内核对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文件、管道、套接字等都是流&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;流的入口：文件描述符(fd)&lt;/p&gt;</summary>
    
    
    
    
    <category term="IO" scheme="https://cwww3.github.io/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Dockerfile</title>
    <link href="https://cwww3.github.io/2021/11/05/docker-file/"/>
    <id>https://cwww3.github.io/2021/11/05/docker-file/</id>
    <published>2021-11-05T03:13:55.000Z</published>
    <updated>2021-11-05T03:14:43.393Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><ul><li>RUN</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="bash">    aufs-tools \</span></span><br><span class="line"><span class="bash">    automake \</span></span><br><span class="line"><span class="bash">    build-essential \</span></span><br><span class="line"><span class="bash">    curl \</span></span><br><span class="line"><span class="bash">    dpkg-sig \</span></span><br><span class="line"><span class="bash">    libcap-dev \</span></span><br><span class="line"><span class="bash">    libsqlite3-dev \</span></span><br><span class="line"><span class="bash">    mercurial \</span></span><br><span class="line"><span class="bash">    reprepro \</span></span><br><span class="line"><span class="bash">    ruby1.9.1 \</span></span><br><span class="line"><span class="bash">    ruby1.9.1-dev \</span></span><br><span class="line"><span class="bash">    s3cmd=1.1.* \</span></span><br><span class="line"><span class="bash"> &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure><span id="more"></span><ul><li>CMD</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多数情况下，CMD 都需要一个交互式的 shell (bash, Python, perl 等)，</span></span><br><span class="line"><span class="comment"># 例如 CMD [&quot;perl&quot;, &quot;-de0&quot;]，或者 CMD [&quot;PHP&quot;, &quot;-a&quot;]。</span></span><br><span class="line"><span class="comment"># 使用这种形式意味着，当你执行类似docker run -it python时，你会进入一个准备好的 shell 中。</span></span><br></pre></td></tr></table></figure><ul><li>ENV</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了方便新程序运行，你可以使用ENV来为容器中安装的程序更新 PATH 环境变量。</span></span><br><span class="line"><span class="comment"># 例如使用ENV PATH /usr/local/nginx/bin:$PATH来确保CMD [&quot;nginx&quot;]能正确运行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PG_MAJOR <span class="number">9.3</span></span><br><span class="line"><span class="keyword">ENV</span> PG_VERSION <span class="number">9.3</span>.<span class="number">4</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl -SL http://example.com/postgres-<span class="variable">$PG_VERSION</span>.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …ENV PATH /usr/<span class="built_in">local</span>/postgres-<span class="variable">$PG_MAJOR</span>/bin:<span class="variable">$PATH</span></span></span><br></pre></td></tr></table></figure><ul><li>ADD COPY</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一般优先使用 COPY。因为它比 ADD 更透明。</span></span><br><span class="line"><span class="comment"># ADD的最佳用例是将本地 tar 文件自动提取到镜像中</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> rootfs.tar.xz</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /usr/src/things \</span></span><br><span class="line"><span class="bash">    &amp;&amp; curl -SL http://example.com/big.tar.xz \</span></span><br><span class="line"><span class="bash">    | tar -xJC /usr/src/things \</span></span><br><span class="line"><span class="bash">    &amp;&amp; make -C /usr/src/things all</span></span><br></pre></td></tr></table></figure><ul><li>ENTRYPOINT</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最佳用处是设置镜像的主命令,允许将镜像当成命令本身来运行,用 CMD 提供默认选项</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;s3cmd&quot;</span>] </span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;--help&quot;</span>]</span></span><br><span class="line"></span><br><span class="line">$docker <span class="keyword">run</span><span class="bash"> s3cmd</span></span><br><span class="line">$docker <span class="keyword">run</span><span class="bash"> s3cmd ls s3://mybucket</span></span><br></pre></td></tr></table></figure><ul><li>VOLUMN</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># VOLUME指令用于暴露任何数据库存储文件，配置文件，或容器创建的文件和目录。强烈建议使用 VOLUME来管理镜像中的可变部分和用户可以改变的部分。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>USER</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果某个服务不需要特权执行，建议使用 USER 指令切换到非 root 用户。</span></span><br><span class="line"><span class="comment"># 如果要依赖确定的 UID/GID，你应该显示的指定一个 UID/GID</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres </span></span><br></pre></td></tr></table></figure><ul><li>WORKDIR</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了清晰性和可靠性，你应该总是在WORKDIR中使用绝对路径 替代类似于 RUN cd </span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Dockerfile&quot;&gt;&lt;a href=&quot;#Dockerfile&quot; class=&quot;headerlink&quot; title=&quot;Dockerfile&quot;&gt;&lt;/a&gt;Dockerfile&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;RUN&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight dockerfile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;RUN&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; apt-get update &amp;amp;&amp;amp; apt-get install -y \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    aufs-tools \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    automake \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    build-essential \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    curl \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    dpkg-sig \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    libcap-dev \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    libsqlite3-dev \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    mercurial \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    reprepro \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    ruby1.9.1 \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    ruby1.9.1-dev \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    s3cmd=1.1.* \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt; &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Docker" scheme="https://cwww3.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB</title>
    <link href="https://cwww3.github.io/2021/10/13/mongodb/"/>
    <id>https://cwww3.github.io/2021/10/13/mongodb/</id>
    <published>2021-10-13T07:21:08.000Z</published>
    <updated>2021-10-26T05:48:18.490Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>MongoDB 是一个面向文档存储的数据库</p><table><thead><tr><th>SQL术语/概念</th><th>MongoDB术语/概念</th><th>解释/说明</th></tr></thead><tbody><tr><td>database</td><td>database</td><td>数据库</td></tr><tr><td>table</td><td>collection</td><td>数据库表/集合</td></tr><tr><td>row</td><td>document</td><td>数据记录行/文档</td></tr><tr><td>column</td><td>field</td><td>数据字段/域</td></tr><tr><td>index</td><td>index</td><td>索引</td></tr><tr><td>table joins</td><td></td><td>表连接,MongoDB不支持</td></tr><tr><td>primary key</td><td>primary key</td><td>主键,MongoDB自动将_id字段设置为主键</td></tr></tbody></table><span id="more"></span><p><a href="https://www.mongodb.com/download-center#community">下载地址</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动 --dbpath指定数据存放位置</span></span><br><span class="line">./mongod --dbpath=/path  </span><br><span class="line">./mongo 连接MongoDB服务</span><br></pre></td></tr></table></figure><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示已有数据库</span></span><br><span class="line">show dbs </span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到指定数据库(没有则创建)</span></span><br><span class="line">use dbName</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前所在数据库</span></span><br><span class="line">db </span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除当前数据库</span></span><br><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合就是 MongoDB 文档组。集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出当前db的集合</span></span><br><span class="line">show collections;</span><br><span class="line">show tables;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建集合 name集合名 options可选参数(capped大小是否固定 size设置大小，字节数  max指定文档最大数量)</span></span><br><span class="line">db.createCollection(name, options)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 例子</span></span><br><span class="line">db.createCollection(&quot;col&quot;)</span><br><span class="line">db.createCollection(&quot;col&quot;, &#123; capped : true, autoIndexId : true, size : 6142800, max : 10000 &#125; )</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除集合</span></span><br><span class="line">db.col.drop()</span><br></pre></td></tr></table></figure><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>文档是一组键值(key-value)对(即 BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。</p><p>需要注意的是：</p><ol><li>文档中的键/值对是有序的。</li><li>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。</li><li>MongoDB区分类型和大小写。</li><li>MongoDB的文档不能有重复的键。</li><li>文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 插入文档</span></span><br><span class="line">db.COLLECTION_NAME.insert(document) # 主键已存在则报错</span><br><span class="line">db.COLLECTION_NAME.insertOne(document) # 主键已存在则更新</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例子  如果col集合不在该数据库中， MongoDB 会自动创建该集合并插入文档</span></span><br><span class="line">db.col.insert(&#123;title: &#x27;MongoDB&#x27;, </span><br><span class="line">    description: &#x27;MongoDB 是一个 Nosql 数据库&#x27;,</span><br><span class="line">    tags: [&#x27;mongodb&#x27;, &#x27;database&#x27;, &#x27;NoSQL&#x27;],</span><br><span class="line">    likes: 100</span><br><span class="line">&#125;)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找</span></span><br><span class="line">db.col.find()</span><br><span class="line">db.col.findOne() # 返回一条</span><br><span class="line">db.col.find().pretty() # 正确可读性</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新 将title为MongoDB的文档改为MongoDB 教程 (只会更新一条)</span></span><br><span class="line">db.col.update(&#123;&#x27;title&#x27;:&#x27;MongoDB&#x27;&#125;,&#123;$set:&#123;&#x27;title&#x27;:&#x27;MongoDB 教程&#x27;&#125;&#125;)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以上语句只会修改第一条发现的文档，如果你要修改多条相同的文档，则需要设置 multi 参数为 <span class="literal">true</span>。</span></span><br><span class="line">db.col.update(&#123;&#x27;title&#x27;:&#x27;MongoDB&#x27;&#125;,&#123;$set:&#123;&#x27;title&#x27;:&#x27;MongoDB 教程&#x27;&#125;,&#123;multi:true&#125;&#125;)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除 title为MongoDB 教程的文档</span></span><br><span class="line">db.col.remove(&#123;&#x27;title&#x27;:&#x27;MongoDB 教程&#x27;&#125;)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除一条</span></span><br><span class="line">db.col.remove(&#123;&#x27;title&#x27;:&#x27;MongoDB 教程&#x27;&#125;,1)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 全删</span></span><br><span class="line">db.col.remove(&#123;&#125;)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择指定字段</span></span><br><span class="line">db.col.find(&#123;&#125;,&#123;title:1&#125;) # 展示_id,title字段(_id默认展示)</span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line">db.col.find(&#123;&#125;,&#123;_id:0,title:1&#125;) # 只展示title字段</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 条件查询</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 等于--&#123;&lt;key&gt;:&lt;value&gt;&#125; 小于--&#123;&lt;key&gt;:&#123;<span class="variable">$lt</span>:&lt;value&gt;&#125;&#125;  小于或等于--lte ，大于--gt 大于或等于--gte  不等于--ne</span></span><br><span class="line">db.col.find(&#123;&quot;likes&quot;:&#123;$lt:50&#125;&#125;).pretty()</span><br><span class="line"><span class="meta">#</span><span class="bash"> AND &#123;key1:value1, key2:value2&#125;</span></span><br><span class="line">db.col.find(&#123;&quot;likes&quot;:50, &quot;title&quot;:&quot;MongoDB 教程&quot;&#125;)</span><br><span class="line"><span class="meta">#</span><span class="bash"> OR</span></span><br><span class="line">db.col.find(</span><br><span class="line">   &#123;</span><br><span class="line">      $or: [</span><br><span class="line">         &#123;key1: value1&#125;, &#123;key2:value2&#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br><span class="line"><span class="meta">#</span><span class="bash"> AND + OR</span></span><br><span class="line">db.col.find(&#123;&quot;likes&quot;: &#123;$gt:50&#125;, $or: [&#123;&quot;by&quot;: &quot;cwww&quot;&#125;,&#123;&quot;title&quot;: &quot;MongoDB 教程&quot;&#125;]&#125;)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">limit</span></span></span><br><span class="line">db.col.find().limit(2)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sort</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 其中 1 为升序排列，而 -1 是用于降序排列</span></span><br><span class="line">db.col.find().sort(&#123;&quot;likes&quot;:-1&#125;)</span><br></pre></td></tr></table></figure><ul><li>MongoDB 索引</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建索引</span></span><br><span class="line">db.col.createIndex(&#123;&quot;title&quot;:1&#125;)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建复合索引</span></span><br><span class="line">db.col.createIndex(&#123;&quot;title&quot;:1,&quot;description&quot;:-1&#125;)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看集合索引</span></span><br><span class="line">db.col.getIndexes()</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看集合索引大小</span></span><br><span class="line">db.col.totalIndexSize()</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除集合所有索引</span></span><br><span class="line">db.col.dropIndexes()</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除集合指定索引</span></span><br><span class="line">db.col.dropIndex(&quot;title&quot;)</span><br></pre></td></tr></table></figure><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>mongodb访问默认是用当前访问的库作为验证，若要验证通过可以通过两种方法。</p><p>1、在连接串上指定验证库，方法就是在连接串上加上authSource=admin，一般使用admin来做验证库</p><p>2、为当前的库添加对应的账户、密码和角色，以满足默认验证库为访问库的情况。</p><h3 id="Go操作MongoDB"><a href="#Go操作MongoDB" class="headerlink" title="Go操作MongoDB"></a>Go操作MongoDB</h3><p><a href="https://github.com/mongodb/mongo-go-driver/">地址</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get go.mongodb.org/mongo-driver/mongo</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;go.mongodb.org/mongo-driver/bson&quot;</span></span><br><span class="line"><span class="string">&quot;go.mongodb.org/mongo-driver/mongo&quot;</span></span><br><span class="line"><span class="string">&quot;go.mongodb.org/mongo-driver/mongo/options&quot;</span></span><br><span class="line"><span class="string">&quot;go.mongodb.org/mongo-driver/mongo/readpref&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 连接MongoDB服务</span></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">10</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line">client, err := mongo.Connect(ctx, options.Client().ApplyURI(<span class="string">&quot;mongodb://localhost:27017&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">err = client.Ping(ctx, readpref.Primary())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序退出前断开连接</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err = client.Disconnect(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取collection对象</span></span><br><span class="line">collection := client.Database(<span class="string">&quot;demo&quot;</span>).Collection(<span class="string">&quot;col&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一条文档</span></span><br><span class="line">res, err := collection.InsertOne(context.Background(), bson.D&#123;&#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;pi&quot;</span>&#125;, &#123;<span class="string">&quot;value&quot;</span>, <span class="number">3.14159</span>&#125;&#125;)</span><br><span class="line">id := res.InsertedID</span><br><span class="line">fmt.Println(id)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询</span></span><br><span class="line">cur, err := collection.Find(ctx, bson.D&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; log.Fatal(err) &#125;</span><br><span class="line"><span class="keyword">defer</span> cur.Close(ctx)</span><br><span class="line"><span class="keyword">for</span> cur.Next(ctx) &#123;</span><br><span class="line"><span class="keyword">var</span> result bson.D</span><br><span class="line">err := cur.Decode(&amp;result)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; log.Fatal(err) &#125;</span><br><span class="line">fmt.Println(result)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := cur.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;MongoDB&quot;&gt;&lt;a href=&quot;#MongoDB&quot; class=&quot;headerlink&quot; title=&quot;MongoDB&quot;&gt;&lt;/a&gt;MongoDB&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;MongoDB 是一个面向文档存储的数据库&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;SQL术语/概念&lt;/th&gt;
&lt;th&gt;MongoDB术语/概念&lt;/th&gt;
&lt;th&gt;解释/说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;database&lt;/td&gt;
&lt;td&gt;database&lt;/td&gt;
&lt;td&gt;数据库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;table&lt;/td&gt;
&lt;td&gt;collection&lt;/td&gt;
&lt;td&gt;数据库表/集合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;row&lt;/td&gt;
&lt;td&gt;document&lt;/td&gt;
&lt;td&gt;数据记录行/文档&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;column&lt;/td&gt;
&lt;td&gt;field&lt;/td&gt;
&lt;td&gt;数据字段/域&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;index&lt;/td&gt;
&lt;td&gt;index&lt;/td&gt;
&lt;td&gt;索引&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;table joins&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;表连接,MongoDB不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;primary key&lt;/td&gt;
&lt;td&gt;primary key&lt;/td&gt;
&lt;td&gt;主键,MongoDB自动将_id字段设置为主键&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    
    <category term="MongoDB" scheme="https://cwww3.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>go-kit</title>
    <link href="https://cwww3.github.io/2021/10/09/go-kit/"/>
    <id>https://cwww3.github.io/2021/10/09/go-kit/</id>
    <published>2021-10-09T08:20:17.000Z</published>
    <updated>2021-10-11T03:49:46.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="go-kit"><a href="#go-kit" class="headerlink" title="go-kit"></a>go-kit</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>go-kit 分为三层：Transport层、Endpoint层、Service层。</p><p>Transport层：负责与传输协议HTTP、GRPC、THRIFT等相关的逻辑处理。</p><p>Endpoint层： 负责request、response格式的转换，以及提供公用拦截器</p><p>Service层： 专注于业务逻辑</p><span id="more"></span><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 目录结构</span></span><br><span class="line"></span><br><span class="line">go-kit-demo</span><br><span class="line">├── endpoint</span><br><span class="line">│   └── endpoint.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">├── service</span><br><span class="line">│   └── service.go</span><br><span class="line">└── transport</span><br><span class="line">    └── transport.go</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>endpoint.go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> endpoint</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/go-kit/kit/endpoint&quot;</span></span><br><span class="line"><span class="string">&quot;go-kit-demo/service&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义请求响应格式</span></span><br><span class="line"><span class="keyword">type</span> HelloRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">Reply <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHelloEndpoint</span><span class="params">(s service.IService)</span> <span class="title">endpoint</span>.<span class="title">Endpoint</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, request <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(response <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">r,ok := request.(HelloRequest)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> HelloResponse&#123;&#125;,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> HelloResponse&#123;Reply: s.Hello(r.Name)&#125;,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>service.go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务类</span></span><br><span class="line"><span class="keyword">type</span> IService <span class="keyword">interface</span> &#123;</span><br><span class="line">Hello(name <span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Service <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Service)</span><span class="title">Hello</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;name:%v&quot;</span>,name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>transport.go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> transport</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line">localEndpoint <span class="string">&quot;go-kit-demo/endpoint&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责与传输协议相关的逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloDecodeRequest</span><span class="params">(ctx context.Context,request *http.Request)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;,error)</span></span> &#123;</span><br><span class="line">name := request.URL.Query().Get(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">&quot;参数为空&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> localEndpoint.HelloRequest&#123;Name: name&#125;,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloEncodeResponse</span><span class="params">(ctx context.Context,w http.ResponseWriter,response <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">w.Header().Set(<span class="string">&quot;Content-type&quot;</span>,<span class="string">&quot;application/json;charset=utf-8&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> json.NewEncoder(w).Encode(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li> main.go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">httpTransport <span class="string">&quot;github.com/go-kit/kit/transport/http&quot;</span></span><br><span class="line">localEndpoint <span class="string">&quot;go-kit-demo/endpoint&quot;</span></span><br><span class="line"><span class="string">&quot;go-kit-demo/service&quot;</span></span><br><span class="line"><span class="string">&quot;go-kit-demo/transport&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 业务接口服务</span></span><br><span class="line">s := service.Service&#123;&#125;</span><br><span class="line">    <span class="comment">// 创建业务服务</span></span><br><span class="line">helloEndpoint := localEndpoint.NewHelloEndpoint(s)</span><br><span class="line">    <span class="comment">// 使用 kit 创建 handler</span></span><br><span class="line">    <span class="comment">// 传入 业务服务 以及 定义的 加密解密方法</span></span><br><span class="line">helloServer := httpTransport.NewServer(helloEndpoint,transport.HelloDecodeRequest,transport.HelloEncodeResponse)</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:9090&quot;</span>,helloServer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211009161848307.png"  /><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211009161918628.png" alt="image-20211009161918628" /><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 目录结构</span></span><br><span class="line">go-kit-demo</span><br><span class="line">├── endpoint</span><br><span class="line">│   └── endpoint.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">├── middleware</span><br><span class="line">│   └── logMiddleware.go</span><br><span class="line">├── service</span><br><span class="line">│   └── service.go</span><br><span class="line">└── transport</span><br><span class="line">    └── transport.go</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>logMiddleware.go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> middleware</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/go-kit/kit/log&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/go-kit/kit/endpoint&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个中间件类型</span></span><br><span class="line"><span class="keyword">type</span> Middleware <span class="function"><span class="keyword">func</span><span class="params">(endpoint.Endpoint)</span> <span class="title">endpoint</span>.<span class="title">Endpoint</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志中间件 在开始和结束打印日志</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LogMiddleware</span><span class="params">(logger log.Logger)</span> <span class="title">Middleware</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(next endpoint.Endpoint)</span> <span class="title">endpoint</span>.<span class="title">Endpoint</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, request <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">logger.Log(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;call start&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> logger.Log(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;call end&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> next(ctx, request)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>main.go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/go-kit/kit/log&quot;</span></span><br><span class="line">httpTransport <span class="string">&quot;github.com/go-kit/kit/transport/http&quot;</span></span><br><span class="line">localEndpoint <span class="string">&quot;go-kit-demo/endpoint&quot;</span></span><br><span class="line"><span class="string">&quot;go-kit-demo/middleware&quot;</span></span><br><span class="line"><span class="string">&quot;go-kit-demo/service&quot;</span></span><br><span class="line"><span class="string">&quot;go-kit-demo/transport&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 业务接口服务</span></span><br><span class="line">s := service.Service&#123;&#125;</span><br><span class="line"><span class="comment">// 创建业务服务</span></span><br><span class="line">helloEndpoint := localEndpoint.NewHelloEndpoint(s)</span><br><span class="line"><span class="comment">// 添加了log中间件的服务</span></span><br><span class="line">logger := log.NewLogfmtLogger(os.Stderr)</span><br><span class="line">helloEndpoint = middleware.LogMiddleware(logger)(helloEndpoint)</span><br><span class="line"><span class="comment">// 使用 kit 创建 handler</span></span><br><span class="line"><span class="comment">// 传入 业务服务 以及 定义的 加密解密方法</span></span><br><span class="line">helloServer := httpTransport.NewServer(helloEndpoint, transport.HelloDecodeRequest, transport.HelloEncodeResponse)</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:9090&quot;</span>, helloServer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211009163859928.png" alt="image-20211009163859928"></p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><a href="https://github.com/cwww3/git-kit-demo">项目源码</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;go-kit&quot;&gt;&lt;a href=&quot;#go-kit&quot; class=&quot;headerlink&quot; title=&quot;go-kit&quot;&gt;&lt;/a&gt;go-kit&lt;/h2&gt;&lt;h3 id=&quot;入门&quot;&gt;&lt;a href=&quot;#入门&quot; class=&quot;headerlink&quot; title=&quot;入门&quot;&gt;&lt;/a&gt;入门&lt;/h3&gt;&lt;p&gt;go-kit 分为三层：Transport层、Endpoint层、Service层。&lt;/p&gt;
&lt;p&gt;Transport层：负责与传输协议HTTP、GRPC、THRIFT等相关的逻辑处理。&lt;/p&gt;
&lt;p&gt;Endpoint层： 负责request、response格式的转换，以及提供公用拦截器&lt;/p&gt;
&lt;p&gt;Service层： 专注于业务逻辑&lt;/p&gt;</summary>
    
    
    
    
    <category term="微服务" scheme="https://cwww3.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件</title>
    <link href="https://cwww3.github.io/2021/09/26/linux-file/"/>
    <id>https://cwww3.github.io/2021/09/26/linux-file/</id>
    <published>2021-09-26T07:23:17.000Z</published>
    <updated>2021-09-26T07:25:53.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="FD文件描述符"><a href="#FD文件描述符" class="headerlink" title="FD文件描述符"></a>FD文件描述符</h3><p>Linux 系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I/O操作的系统调用都会通过文件描述符。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">用户级限制 查看当前进程的最大fd数</span></span><br><span class="line">ulimit -n </span><br><span class="line"><span class="meta">#</span><span class="bash">系统级限制</span></span><br><span class="line">sysctl -a</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="文件描述符表"><a href="#文件描述符表" class="headerlink" title="文件描述符表"></a>文件描述符表</h3><p>Linux系统中的每个进程会在其进程控制块（PCB）内维护属于自己的文件描述符表（file descriptor table）。表中每个条目包含两个域：一是控制该描述符的标记域（flags），二是指向系统级别的打开文件表中对应条目的指针。</p><h3 id="打开文件表-amp-句柄"><a href="#打开文件表-amp-句柄" class="headerlink" title="打开文件表&amp;句柄"></a>打开文件表&amp;句柄</h3><p>内核会维护系统内所有打开的文件及其相关的元信息，该结构称为打开文件表（open file table）。表中每个条目包含以下域：</p><ul><li>文件的偏移量。read()/write()/seek()函数都会修改该值；</li><li>打开文件时的状态和权限标记。通过open()函数的参数传入；</li><li>文件的访问模式（只读、只写、读+写等）。通过open()函数的参数传入；</li><li>指向其对应的inode对象的指针。</li></ul><p>各条目称为打开文件句柄（open file handle）。<strong>文件描述符是进程级别的，文件句柄是系统级别的</strong>，不能混用。它们在不同级别表示已打开的文件。文件描述符与文件句柄直接关联，文件句柄与inode直接关联。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lsof</span><br><span class="line"><span class="meta">#</span><span class="bash">在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Lists open files and the corresponding processes.</span></span><br></pre></td></tr></table></figure><h3 id="INODE"><a href="#INODE" class="headerlink" title="INODE"></a>INODE</h3><p>文件储存在硬盘上，硬盘的最小存储单位叫做扇区（Sector）。每个扇区储存512字节。</p><p>操作系统读取硬盘的时候，是一次性连续读取多个扇区，即一次性读取一个块（block）。这种由多个扇区组成的块，是文件存取的最小单位。块的大小，最常见的是4KB，即连续八个 sector组成一个 block。</p><p>文件数据都储存在块中，还需要一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，即索引节点。</p><p>每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看文件inode信息</span></span><br><span class="line">stat example.txt</span><br></pre></td></tr></table></figure><p>inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看每个硬盘分区的inode总数和已使用的数量</span></span><br><span class="line">df -i</span><br></pre></td></tr></table></figure><h3 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h3><p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210926112812282.png" alt="image-20210926112812282"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;文件&quot;&gt;&lt;a href=&quot;#文件&quot; class=&quot;headerlink&quot; title=&quot;文件&quot;&gt;&lt;/a&gt;文件&lt;/h2&gt;&lt;h3 id=&quot;FD文件描述符&quot;&gt;&lt;a href=&quot;#FD文件描述符&quot; class=&quot;headerlink&quot; title=&quot;FD文件描述符&quot;&gt;&lt;/a&gt;FD文件描述符&lt;/h3&gt;&lt;p&gt;Linux 系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I/O操作的系统调用都会通过文件描述符。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;用户级限制 查看当前进程的最大fd数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ulimit -n &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;系统级限制&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sysctl -a&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://cwww3.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>prometheus</title>
    <link href="https://cwww3.github.io/2021/09/18/prometheus/"/>
    <id>https://cwww3.github.io/2021/09/18/prometheus/</id>
    <published>2021-09-18T07:47:23.000Z</published>
    <updated>2021-09-18T07:47:53.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">go get github.com/prometheus/client_golang/prometheus</span><br><span class="line">go get github.com/prometheus/client_golang/prometheus/promauto</span><br><span class="line">go get github.com/prometheus/client_golang/prometheus/promhttp</span><br></pre></td></tr></table></figure><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;github.com/prometheus/client_golang/prometheus/promhttp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        http.Handle(<span class="string">&quot;/metrics&quot;</span>, promhttp.Handler())</span><br><span class="line">        http.ListenAndServe(<span class="string">&quot;:2112&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行</span></span><br><span class="line">go run main.go</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 访问</span></span><br><span class="line">curl http://localhost:2112/metrics</span><br></pre></td></tr></table></figure><p>上述示例展示如何使用 Prometheus Golang 库来暴露应用的指标数据，但暴露的监控指标数据为文本类型，需要搭建维护额外的 Prometheus 服务来抓取指标，还需要额外的 Grafana 来对数据进行可视化展示。</p><h2 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h2><h4 id="Prometheus下载"><a href="#Prometheus下载" class="headerlink" title="Prometheus下载"></a>Prometheus下载</h4><p><a href="https://prometheus.io/download/">下载地址</a></p><p>解压后当前目录会包含默认的Prometheus配置文件promethes.yml</p><p>启动完成后，可以通过<a href="http://localhost:9090访问Prometheus的UI界面">http://localhost:9090访问Prometheus的UI界面</a></p><h4 id="Node-Exporter下载"><a href="#Node-Exporter下载" class="headerlink" title="Node Exporter下载"></a>Node Exporter下载</h4><p>在Prometheus的架构设计中，Prometheus Server并不直接服务监控特定的目标，其主要任务负责数据的收集，存储并且对外提供数据查询支持。因此为了能够能够监控到某些东西，如主机的CPU使用率，我们需要使用到Exporter。Prometheus周期性的从Exporter暴露的HTTP服务地址（通常是/metrics）拉取监控样本数据。</p><p>从上面的描述中可以看出Exporter可以是一个相对开放的概念，其可以是一个独立运行的程序独立于监控目标以外，也可以是直接内置在监控目标中。只要能够向Prometheus提供标准格式的监控样本数据即可。</p><p>这里为了能够采集到主机的运行指标如CPU, 内存，磁盘等信息。我们可以使用<a href="https://github.com/prometheus/node_exporter">Node Exporter</a>。</p><p>Node Exporter同样采用Golang编写，并且不存在任何的第三方依赖，只需要下载，解压即可运行。可以从<a href="https://prometheus.io/download/%E8%8E%B7%E5%8F%96%E6%9C%80%E6%96%B0%E7%9A%84node">https://prometheus.io/download/获取最新的node</a> exporter版本的二进制包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压启动后访问 http://localhost:9100</span></span><br></pre></td></tr></table></figure><h4 id="从Node-Exporter收集监控数据"><a href="#从Node-Exporter收集监控数据" class="headerlink" title="从Node Exporter收集监控数据"></a>从Node Exporter收集监控数据</h4><p>为了能够让Prometheus Server能够从当前node exporter获取到监控数据，这里需要修改Prometheus配置文件。编辑prometheus.yml并在scrape_configs节点下添加以下内容:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;prometheus&#x27;</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;localhost:9090&#x27;</span>]</span><br><span class="line">  <span class="comment"># 采集node exporter监控数据</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;node&#x27;</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;localhost:9100&#x27;</span>]</span><br></pre></td></tr></table></figure><p>重新启动Prometheus Server。访问<a href="http://localhost:9090/">http://localhost:9090</a>，进入到Prometheus Server。如果输入<code>up</code>并且点击执行按钮以后，可以看到如下结果：</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210916094823568.png" alt="image-20210916094823568" style="zoom:50%;" /><h4 id="Prometheus-UI"><a href="#Prometheus-UI" class="headerlink" title="Prometheus UI"></a>Prometheus UI</h4><p>Prometheus UI是Prometheus内置的一个可视化管理界面，通过Prometheus UI用户能够轻松的了解Prometheus当前的配置，监控任务运行状态等。 通过<code>Graph</code>面板，用户还能直接使用<code>PromQL</code>实时查询监控数据</p><h4 id="PromQL"><a href="#PromQL" class="headerlink" title="PromQL"></a>PromQL</h4><p>PromQL是Prometheus自定义的一套强大的数据查询语言，除了使用监控指标作为查询关键字以为，还内置了大量的函数，帮助用户进一步对时序数据进行处理。</p><h2 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h2><p>Grafana 是一个监控仪表系统，它可以大大帮助你简化监控的复杂度，你只需要提供你需要监控的数据，它就可以帮你生成各种可视化仪表。同时它还有报警功能，可以在系统出现问题时通知你。</p><h4 id="Docker安装运行"><a href="#Docker安装运行" class="headerlink" title="Docker安装运行"></a>Docker安装运行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3000:3000 grafana/grafana</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 访问 http://localhost:3000  </span><br><span class="line">2. 登录 账号密码默认admin。</span><br><span class="line">3. 在数据源中添加prometheus类型。 数据源URL为http://localhost:9090</span><br><span class="line">4. 新建dashboard进行数据分析</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Go&quot;&gt;&lt;a href=&quot;#Go&quot; class=&quot;headerlink&quot; title=&quot;Go&quot;&gt;&lt;/a&gt;Go&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 安装&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;go get github.com/prometheus/client_golang/prometheus&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;go get github.com/prometheus/client_golang/prometheus/promauto&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;go get github.com/prometheus/client_golang/prometheus/promhttp&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="运维" scheme="https://cwww3.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>GoQuestion</title>
    <link href="https://cwww3.github.io/2021/09/06/GoQuestion/"/>
    <id>https://cwww3.github.io/2021/09/06/GoQuestion/</id>
    <published>2021-09-06T02:33:51.000Z</published>
    <updated>2021-09-24T01:23:42.233Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Question1"><a href="#Question1" class="headerlink" title="Question1"></a>Question1</h2><h3 id="time-After-内存泄漏代码"><a href="#time-After-内存泄漏代码" class="headerlink" title="time.After 内存泄漏代码"></a>time.After 内存泄漏代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    )</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            i++</span><br><span class="line">            ch &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> x := &lt;- ch:</span><br><span class="line">            <span class="built_in">println</span>(x)</span><br><span class="line">        <span class="keyword">case</span> &lt;- time.After(<span class="number">3</span> * time.Minute):</span><br><span class="line">            <span class="built_in">println</span>(time.Now().Unix())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>在for循环每次select的时候，都会实例化一个一个新的定时器。该定时器在3分钟后，才会被激活，但是激活后已经跟select无引用关系，被gc给清理掉。</p><p>换句话说，被遗弃的time.After定时任务还是在时间堆里面，定时任务未到期之前，是不会被gc清理的。</p><h3 id="原理验证"><a href="#原理验证" class="headerlink" title="原理验证"></a>原理验证</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    )</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> ms runtime.MemStats</span><br><span class="line">    runtime.ReadMemStats(&amp;ms)</span><br><span class="line">    fmt.Println(<span class="string">&quot;before, have&quot;</span>, runtime.NumGoroutine(), <span class="string">&quot;goroutines,&quot;</span>, ms.Alloc, <span class="string">&quot;bytes allocated&quot;</span>, ms.HeapObjects, <span class="string">&quot;heap object&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</span><br><span class="line">        time.After(<span class="number">3</span> * time.Minute)</span><br><span class="line">    &#125;</span><br><span class="line">    runtime.GC()</span><br><span class="line">    runtime.ReadMemStats(&amp;ms)</span><br><span class="line">    fmt.Println(<span class="string">&quot;after, have&quot;</span>, runtime.NumGoroutine(), <span class="string">&quot;goroutines,&quot;</span>, ms.Alloc, <span class="string">&quot;bytes allocated&quot;</span>, ms.HeapObjects, <span class="string">&quot;heap object&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">    runtime.GC()</span><br><span class="line">    runtime.ReadMemStats(&amp;ms)</span><br><span class="line">    fmt.Println(<span class="string">&quot;after 10sec, have&quot;</span>, runtime.NumGoroutine(), <span class="string">&quot;goroutines,&quot;</span>, ms.Alloc, <span class="string">&quot;bytes allocated&quot;</span>, ms.HeapObjects, <span class="string">&quot;heap object&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Minute)</span><br><span class="line">    runtime.GC()</span><br><span class="line">    runtime.ReadMemStats(&amp;ms)</span><br><span class="line">    fmt.Println(<span class="string">&quot;after 3min, have&quot;</span>, runtime.NumGoroutine(), <span class="string">&quot;goroutines,&quot;</span>, ms.Alloc, <span class="string">&quot;bytes allocated&quot;</span>, ms.HeapObjects, <span class="string">&quot;heap object&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证结果如下图所示：</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210906101432013.png" alt="image-20210906101432013" style="zoom:50%;" /><p>从图中可以看出，实例中循环跑完后，创建了3000172个对象，由于每个time定时器设置的为3分钟，在3分钟后，可以看到对象都被GC回收，只剩174个对象，从而验证了，time.After定时器在定时任务到达之前，会一直存在于时间堆中，不会释放资源，直到定时任务时间到达后才会释放资源。</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>综上，在go代码中，在for循环里<strong>不要使用</strong>select + time.After的组合，可以使用time.NewTimer替代</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    )</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            ch &lt;- <span class="number">100</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"> </span><br><span class="line">    idleDuration := <span class="number">3</span> * time.Minute</span><br><span class="line">    idleDelay := time.NewTimer(idleDuration)</span><br><span class="line">    <span class="keyword">defer</span> idleDelay.Stop()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        idleDelay.Reset(idleDuration)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> x := &lt;- ch:</span><br><span class="line">                <span class="built_in">println</span>(x)</span><br><span class="line">            <span class="keyword">case</span> &lt;-idleDelay.C:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Question2"><a href="#Question2" class="headerlink" title="Question2"></a>Question2</h2><h3 id="作用域和短声明"><a href="#作用域和短声明" class="headerlink" title="作用域和短声明"></a>作用域和短声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">fmt.Println(&amp;a)</span><br><span class="line"><span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">a,_ := get()</span><br><span class="line">fmt.Println(&amp;a)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出a的地址不同</span></span><br></pre></td></tr></table></figure><h3 id="原因分析-1"><a href="#原因分析-1" class="headerlink" title="原因分析"></a>原因分析</h3><p><strong>不同作用域</strong>下<strong>同名</strong>变量使用<strong>短声明</strong>赋值时会产生新的变量进行覆盖</p><p><strong>同一作用域</strong>下<strong>同名</strong>变量使用<strong>短声明</strong>赋值时不会产生新的变量，而是对同一个变量进行赋值</p><h3 id="问题解决-1"><a href="#问题解决-1" class="headerlink" title="问题解决"></a>问题解决</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">fmt.Println(&amp;a)</span><br><span class="line"><span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="comment">// 使用临时变量接收，再通过=赋值</span></span><br><span class="line">      tmp,_ := get()</span><br><span class="line">a = tmp</span><br><span class="line">fmt.Println(&amp;a)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Question1&quot;&gt;&lt;a href=&quot;#Question1&quot; class=&quot;headerlink&quot; title=&quot;Question1&quot;&gt;&lt;/a&gt;Question1&lt;/h2&gt;&lt;h3 id=&quot;time-After-内存泄漏代码&quot;&gt;&lt;a href=&quot;#time-After-内存泄漏代码&quot; class=&quot;headerlink&quot; title=&quot;time.After 内存泄漏代码&quot;&gt;&lt;/a&gt;time.After 内存泄漏代码&lt;/h3&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;time&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ch := &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            i++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ch &amp;lt;- i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; x := &amp;lt;- ch:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;println&lt;/span&gt;(x)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &amp;lt;- time.After(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; * time.Minute):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;println&lt;/span&gt;(time.Now().Unix())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Go Question" scheme="https://cwww3.github.io/tags/Go-Question/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://cwww3.github.io/2021/09/02/linux-command/"/>
    <id>https://cwww3.github.io/2021/09/02/linux-command/</id>
    <published>2021-09-02T03:12:40.000Z</published>
    <updated>2021-11-18T06:51:29.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><ul><li>find</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 只在当前目录下搜索 符合条件的文件</span></span><br><span class="line">find . -maxdepth 1 -name 表达式</span><br><span class="line">-type f/d 指定类型</span><br><span class="line">-perm xxx 指定权限</span><br><span class="line">-a 与</span><br><span class="line">-o 或</span><br><span class="line">! -not 非</span><br></pre></td></tr></table></figure><span id="more"></span><ul><li>xargs</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> xargs命令的作用，是将标准输入转为命令行参数。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> 不接受标准输入作为参数 只能直接在命令行输入参数 无法用管道命令传递参数 不会有输出</span> </span><br><span class="line">echo &quot;hello world&quot; | echo </span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出 hello world</span></span><br><span class="line">echo &quot;hello world&quot; | xargs echo</span><br></pre></td></tr></table></figure><ul><li>grep</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 当前目录下查找内容</span></span><br><span class="line">grep -r &quot;要查找的内容&quot; .</span><br></pre></td></tr></table></figure><ul><li>tee</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不退出vim保存没权限的文件</span></span><br><span class="line">:w !sudo tee %</span><br><span class="line"><span class="comment"># w 保存文件内容</span></span><br><span class="line"><span class="comment"># !sudo 使用sudo权限 </span></span><br><span class="line"><span class="comment"># tee 将w输出的内容重定向到%</span></span><br><span class="line"><span class="comment"># % 当前文件</span></span><br></pre></td></tr></table></figure><ul><li>sed</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 替换文件内容</span></span><br><span class="line">sed -i suffix <span class="string">&quot;s/原字符串/替换字符串/g&quot;</span> filename</span><br><span class="line"><span class="comment"># suffix 对修改文件进行备份，名字为原名加后缀 （osx系统必须指定，可以输入&quot;&quot;表示不备份）</span></span><br><span class="line"><span class="comment"># s 表示替换</span></span><br><span class="line"><span class="comment"># g 表示全部替换</span></span><br><span class="line"><span class="comment"># -i 修改文件  -e 将修改后的内容输出到标准输出，不修改文件</span></span><br></pre></td></tr></table></figure><ul><li>重定向</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Linux重定向是指修改原来默认的一些东西，对原来系统命令的默认执行方式进行改变</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Linux默认输入是键盘，输出是显示器。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">STDIN 0 键盘输入 STDOUT 1 输出信息到提示符窗口 STDERR 2 输出错误信息到提示符窗口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认的 &lt; 重定向输入操作符是 0，而默认的 &gt; 重定向输出操作符是 1。键入 &lt; 或 &gt; 操作符之后，必须指定数据的读写位置，可以是文件名或其他现有的句柄。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 要指定重定向到现有句柄，请使用与 &amp; 字符，后面接要重定向的句柄号。如：2&gt;&amp;1</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment">#将命令输出写入文件或设备，而不是命令提示符或句柄</span></span></span><br><span class="line"> </span><br><span class="line">&lt; #从文件而不是从键盘或句柄读入命令输入</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt; <span class="comment">#将命令输出添加到文件末尾而不删除文件中已有的信息</span></span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&amp; <span class="comment">#将一个句柄的输出写入到另一个句柄的输入中</span></span></span><br><span class="line"> </span><br><span class="line">&lt;&amp; #从一个句柄读取输入并将其写入到另一个句柄输出中</span><br><span class="line"> </span><br><span class="line">| #从一个命令中读取输出并将其写入另一个命令的输入中;也称为管道操作符</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例：</span></span><br><span class="line">mysh &gt; mylog.txt 2&gt;&amp;1</span><br><span class="line"><span class="meta">#</span><span class="bash"> &gt; mylog.txt意思是将标准输出重定向到mylog.txt，等价于mysh 1&gt; mylog.txt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2 &gt;&amp; 1 意思是将错误输出重定向到句柄1标准输出;综合起来就是mysh命令执行过程中产生的标准输出和错误输出都会被重定向到mylog.txt中;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 某些时候我们可能并不希望记录什么标准输出或者是错误输出，那可以用</span></span><br><span class="line">mysh &gt;/dev/null 2&gt;/dev/null;</span><br></pre></td></tr></table></figure><ul><li>进程替代(Process substitution)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">进程替代是进程间通信的一种方式。在 Linux 上使用进程替代的时候，系统会创建一个临时的文件描述符，然后将用以替代的进程的输出和这个文件描述符关联起来，这个可以通过以下命令来验证:</span><br><span class="line">执行 echo &lt;(date)</span><br><span class="line">输出 /dev/fd/11</span><br><span class="line">fd就是文件描述父的缩写，但你去/dev/fd/下面找这个文件描述符，却会发现找不到，那是因为这个文件描述符是临时的，在传给&quot;echo&quot;命令后就被释放了。</span><br><span class="line">此外，进程替代并不能和文件完全等价，这一点要切记。进程替代所建立的&quot;对象&quot;，是不能进行写入和随机读取操作的。</span><br><span class="line"></span><br><span class="line">例子</span><br><span class="line">需求: 运行mysh并指定一个配置文件(配置文件没有权限直接修改，但是需要在配置文件中添加foo=bar)</span><br><span class="line">mysh -config=&lt;(cat /path/config &lt;(print &quot;foo=bar&quot;))</span><br></pre></td></tr></table></figure><ul><li>kill</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kill -l #查看信号</span><br><span class="line">kill PID #默认 -15 TERM</span><br><span class="line">kill -9 PID # 强制杀死程序 KILL</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一般情况下，优先使用SIGTERM信号。这是因为当程序收到了SIGTERM信号之后，会做一些程序的清理操作，或者说是优雅的关闭。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果传入<span class="built_in">kill</span> -9 也就是SIGKILL，那么应用程序将无法捕捉这个信号，从而导致程序强制被关闭，有可能会照成一些异常情况，比如数据还没有保存，数据传输还没有结束等等。</span></span><br></pre></td></tr></table></figure><ul><li>lsof</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsof -i :port # 查看端口占用</span><br><span class="line">lsof -p 5656  # 查看进程ID</span><br></pre></td></tr></table></figure><ul><li>if</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">if [ command ]; then</span><br><span class="line">     符合该条件执行的语句</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ command ];then</span><br><span class="line">     符合该条件执行的语句</span><br><span class="line">elif [ command ];then</span><br><span class="line">     符合该条件执行的语句</span><br><span class="line">else</span><br><span class="line">     符合该条件执行的语句</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 常用参数：</span></span><br><span class="line">[ -a FILE ] 如果 FILE 存在则为真。</span><br><span class="line">[ -d FILE ] 如果 FILE 存在且是一个目录则返回为真。</span><br><span class="line">[ -e FILE ] 如果 指定的文件或目录存在时返回为真。</span><br><span class="line">[ -f FILE ] 如果 FILE 存在且是一个普通文件则返回为真。</span><br><span class="line">[ -r FILE ] 如果 FILE 存在且是可读的则返回为真。</span><br><span class="line">[ -w FILE ] 如果 FILE 存在且是可写的则返回为真。（一个目录为了它的内容被访问必然是可执行的）</span><br><span class="line">[ -x FILE ] 如果 FILE 存在且是可执行的则返回为真。</span><br><span class="line"></span><br><span class="line">[ -z STRING ] 如果STRING的长度为零则返回为真，即空是真</span><br><span class="line">[ -n STRING ] 如果STRING的长度非零则返回为真，即非空是真</span><br><span class="line">[ STRING1 ]　 如果字符串不为空则返回为真,与-n类似</span><br><span class="line">[ STRING1 == STRING2 ] 如果两个字符串相同则返回为真</span><br><span class="line">[ STRING1 != STRING2 ] 如果字符串不相同则返回为真</span><br><span class="line">[ STRING1 &lt; STRING2 ] 如果 “STRING1”字典排序在“STRING2”前面则返回为真。</span><br><span class="line">[ STRING1 &gt; STRING2 ] 如果 “STRING1”字典排序在“STRING2”后面则返回为真。</span><br><span class="line"></span><br><span class="line">[ INT1 -eq INT2 ] INT1和INT2两数相等返回为真 ,=</span><br><span class="line">[ INT1 -ne INT2 ] INT1和INT2两数不等返回为真 ,&lt;&gt;</span><br><span class="line">[ INT1 -gt INT2 ] INT1大于INT2返回为真 ,&gt;</span><br><span class="line">[ INT1 -ge INT2 ] INT1大于等于INT2返回为真,&gt;=</span><br><span class="line">[ INT1 -lt INT2 ] INT1小于INT2返回为真 ,&lt;</span><br><span class="line">[ INT1 -le INT2 ] INT1小于等于INT2返回为真,&lt;=</span><br><span class="line"></span><br><span class="line">[ ! EXPR ] 逻辑非，如果 EXPR 是false则返回为真。</span><br><span class="line">[ EXPR1 -a EXPR2 ] 逻辑与，如果 EXPR1 and EXPR2 全真则返回为真。</span><br><span class="line">[ EXPR1 -o EXPR2 ] 逻辑或，如果 EXPR1 或者 EXPR2 为真则返回为真。</span><br><span class="line">[ ] || [ ] 用OR来合并两个条件</span><br><span class="line">[ ] &amp;&amp; [ ] 用AND来合并两个条件</span><br><span class="line"></span><br><span class="line">IF高级特性：</span><br><span class="line">双圆括号(( ))：表示数学表达式</span><br><span class="line">双方括号[[ ]]：表示高级字符串处理函数</span><br><span class="line"></span><br><span class="line">[ $a != 1 || $b = 2 ]是不允许的 要用[ $a != 1 ] || [ $b = 2 ]</span><br><span class="line">而双括号就可以解决这个问题 [[ $a != 1 || $b = 2 ]]</span><br><span class="line"></span><br><span class="line">[ &quot;$a&quot; -lt &quot;$b&quot; ]，也可以改成双括号的形式((&quot;$a&quot; &lt; &quot;$b&quot;))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Linux常用命令&quot;&gt;&lt;a href=&quot;#Linux常用命令&quot; class=&quot;headerlink&quot; title=&quot;Linux常用命令&quot;&gt;&lt;/a&gt;Linux常用命令&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;find&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 只在当前目录下搜索 符合条件的文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;find . -maxdepth 1 -name 表达式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-type f/d 指定类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-perm xxx 指定权限&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-a 与&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-o 或&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;! -not 非&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://cwww3.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Mutex</title>
    <link href="https://cwww3.github.io/2021/08/20/Mutex/"/>
    <id>https://cwww3.github.io/2021/08/20/Mutex/</id>
    <published>2021-08-19T17:23:49.000Z</published>
    <updated>2021-08-19T17:26:37.558Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mutex解析"><a href="#Mutex解析" class="headerlink" title="Mutex解析"></a>Mutex解析</h2><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210820004216764.png" alt="image-20210820004216764" style="zoom:50%;" /><span id="more"></span><h3 id="初版的-Mutex"><a href="#初版的-Mutex" class="headerlink" title="初版的 Mutex"></a>初版的 Mutex</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    key <span class="keyword">int32</span>;</span><br><span class="line">    sema <span class="keyword">int32</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">xadd</span><span class="params">(val *<span class="keyword">int32</span>, delta <span class="keyword">int32</span>)</span> <span class="params">(<span class="built_in">new</span> <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        v := *val;</span><br><span class="line">        <span class="keyword">if</span> cas(val, v, v+delta) &#123;</span><br><span class="line">            <span class="keyword">return</span> v+delta;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;unreached&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> xadd(&amp;m.key, <span class="number">1</span>) == <span class="number">1</span> &#123;</span><br><span class="line">      <span class="comment">// changed from 0 to 1; we hold lock</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sys.semacquire(&amp;m.sema);</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">     <span class="keyword">if</span> xadd(&amp;m.key, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">       <span class="comment">// changed from 1 to 0; no contention</span></span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     sys.semrelease(&amp;m.sema);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以看到，这简单几行就可以实现一个排外锁。通过<code>cas</code>对 <code>key</code> 进行加一, 如果<code>key</code>的值是从<code>0</code>加到<code>1</code>, 则直接获得了锁。否则通过<code>semacquire</code>进行sleep, 被唤醒的时候就获得了锁。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>互斥锁有两种状态：正常状态和饥饿状态。</p><p>在正常状态下，所有等待锁的goroutine按照<strong>FIFO</strong>顺序等待。唤醒的goroutine不会直接拥有锁，而是会和新请求锁的goroutine竞争锁的拥有。新请求锁的goroutine具有优势：它正在CPU上执行，而且可能有好几个，所以刚刚唤醒的goroutine有很大可能在锁竞争中失败。在这种情况下，这个被唤醒的goroutine会加入到等待队列的前面。 如果一个等待的goroutine超过1ms没有获取锁，那么它将会把锁转变为饥饿模式。</p><p>在饥饿模式下，锁的所有权将从unlock的gorutine直接交给交给等待队列中的第一个。新来的goroutine将不会尝试去获得锁，即使锁看起来是unlock状态, 也不会去尝试自旋操作，而是放在等待队列的尾部。</p><p>如果一个等待的goroutine获取了锁，并且满足一以下其中的任何一个条件：(1)它是队列中的最后一个；(2)它等待的时候小于1ms。它会将锁的状态转换为正常状态。</p><p>正常状态有很好的性能表现，饥饿模式也是非常重要的，因为它能阻止尾部延迟的现象。</p><p> 我们要从多线程(goroutine)的并发场景去理解为什么实现中有很多的分支。</p><p>当一个goroutine获取这个锁的时候， 有可能这个锁根本没有竞争者， 那么这个goroutine轻轻松松获取了这个锁。而如果这个锁已经被别的goroutine拥有， 就需要考虑怎么处理当前的期望获取锁的goroutine。同时， 当并发goroutine很多的时候，有可能会有多个竞争者， 而且还会有通过信号量唤醒的等待者。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    state <span class="keyword">int32</span></span><br><span class="line">    sema  <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>state</code>是一个共用的字段， <strong>第0个</strong> bit 标记这个<code>mutex</code>是否已被某个goroutine所拥有， 下面为了描述方便称之为<code>state</code>已加锁，或者<code>mutex</code>已加锁。 如果<strong>第0个</strong> bit为0, 下文称之为<code>state</code>未被锁, 此mutex目前没有被某个goroutine所拥有。</p><p><strong>第1个</strong> bit 标记这个<code>mutex</code>是否已唤醒, 也就是有某个唤醒的<code>goroutine</code>要尝试获取锁。</p><p><strong>第2个</strong> bit 标记这个<code>mutex</code>状态， 值为1表明此锁已处于饥饿状态。</p><p>其余bit用于记录等待得到锁的goroutine数</p><p>同时，尝试获取锁的goroutine也有状态，有可能它是新来的goroutine，也有可能是被唤醒的goroutine, 可能是处于正常状态的goroutine, 也有可能是处于饥饿状态的goroutine。</p><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果mutext的state没有被锁，也没有等待/唤醒的goroutine, 锁处于正常状态，那么获得锁，返回.</span></span><br><span class="line">    <span class="comment">// 比如锁第一次被goroutine请求时，就是这种状态。或者锁处于空闲的时候，也是这种状态。</span></span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记本goroutine的等待时间</span></span><br><span class="line">    <span class="keyword">var</span> waitStartTime <span class="keyword">int64</span></span><br><span class="line">    <span class="comment">// 本goroutine是否已经处于饥饿状态</span></span><br><span class="line">    starving := <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 本goroutine是否已唤醒</span></span><br><span class="line">    awoke := <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自旋次数</span></span><br><span class="line">    iter := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制锁的当前状态</span></span><br><span class="line">    old := m.state</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 第一个条件是state已被锁，但是不是饥饿状态。如果是饥饿状态，自旋时没有用的，锁的拥有权直接交给了等待队列的第一个。</span></span><br><span class="line">        <span class="comment">// 第二个条件是还可以自旋，多核、压力不大并且在一定次数内可以自旋， 具体的条件可以参考`sync_runtime_canSpin`的实现。</span></span><br><span class="line">        <span class="comment">// 如果满足这两个条件，不断自旋来等待锁被释放、或者进入饥饿状态、或者不能再自旋。</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">            <span class="comment">// 自旋的过程中如果发现state还没有设置woken标识，则设置它的woken标识， 并标记自己为被唤醒。</span></span><br><span class="line">            <span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">                awoke = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            runtime_doSpin()</span><br><span class="line">            iter++</span><br><span class="line">            old = m.state</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 到了这一步， state的状态可能是：</span></span><br><span class="line">        <span class="comment">// 1. 锁还没有被释放，锁处于正常状态</span></span><br><span class="line">        <span class="comment">// 2. 锁还没有被释放， 锁处于饥饿状态</span></span><br><span class="line">        <span class="comment">// 3. 锁已经被释放， 锁处于正常状态</span></span><br><span class="line">        <span class="comment">// 4. 锁已经被释放， 锁处于饥饿状态</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 并且本gorutine的 awoke可能是true, 也可能是false (其它goutine已经设置了state的woken标识)</span></span><br><span class="line">        <span class="comment">// new 复制 state的当前状态， 用来设置新的状态</span></span><br><span class="line">        <span class="comment">// old 是锁当前的状态</span></span><br><span class="line">        <span class="built_in">new</span> := old</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果old state状态不是饥饿状态, new state 设置锁， 尝试通过CAS获取锁,</span></span><br><span class="line">        <span class="comment">// 如果old state状态是饥饿状态, 则不设置new state的锁，因为饥饿状态下锁直接转给等待队列的第一个.</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">new</span> |= mutexLocked</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将等待队列的等待者的数量加1</span></span><br><span class="line">        <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前goroutine已经处于饥饿状态， 并且old state的已被加锁,</span></span><br><span class="line">        <span class="comment">// 将new state的状态标记为饥饿状态, 将锁转变为饥饿状态.</span></span><br><span class="line">        <span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">new</span> |= mutexStarving</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果本goroutine已经设置为唤醒状态, 需要清除new state的唤醒标记, 因为本goroutine要么获得了锁，要么进入休眠，</span></span><br><span class="line">        <span class="comment">// 总之state的新状态不再是woken状态.</span></span><br><span class="line">        <span class="keyword">if</span> awoke &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">                throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过CAS设置new state值.</span></span><br><span class="line">        <span class="comment">// 注意new的锁标记不一定是true, 也可能只是标记一下锁的state是饥饿状态.</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果old state的状态是未被锁状态，并且锁不处于饥饿状态,</span></span><br><span class="line">            <span class="comment">// 那么当前goroutine已经获取了锁的拥有权，返回</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 设置/计算本goroutine的等待时间</span></span><br><span class="line">            queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">                waitStartTime = runtime_nanotime()</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 既然未能获取到锁， 那么就使用sleep原语阻塞本goroutine</span></span><br><span class="line">            <span class="comment">// 如果是新来的goroutine,queueLifo=false, 加入到等待队列的尾部，耐心等待</span></span><br><span class="line">            <span class="comment">// 如果是唤醒的goroutine, queueLifo=true, 加入到等待队列的头部</span></span><br><span class="line">            runtime_SemacquireMutex(&amp;m.sema, queueLifo)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// sleep之后，此goroutine被唤醒</span></span><br><span class="line">            <span class="comment">// 计算当前goroutine是否已经处于饥饿状态.</span></span><br><span class="line">            starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">            <span class="comment">// 得到当前的锁状态</span></span><br><span class="line">            old = m.state</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果当前的state已经是饥饿状态</span></span><br><span class="line">            <span class="comment">// 那么锁应该处于Unlock状态，那么应该是锁被直接交给了本goroutine</span></span><br><span class="line">            <span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123; </span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果当前的state已被锁，或者已标记为唤醒， 或者等待的队列中不为空,</span></span><br><span class="line">                <span class="comment">// 那么state是一个非法状态</span></span><br><span class="line">                <span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">                    throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 当前goroutine用来设置锁，并将等待的goroutine数减1.</span></span><br><span class="line">                delta := <span class="keyword">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果本goroutine是最后一个等待者，或者它并不处于饥饿状态，</span></span><br><span class="line">                <span class="comment">// 那么我们需要把锁的state状态设置为正常模式.</span></span><br><span class="line">                <span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">                    <span class="comment">// 退出饥饿模式</span></span><br><span class="line">                    delta -= mutexStarving</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 设置新state, 因为已经获得了锁，退出、返回</span></span><br><span class="line">                atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果当前的锁是正常模式，本goroutine被唤醒，自旋次数清零，从for循环开始处重新开始</span></span><br><span class="line">            awoke = <span class="literal">true</span></span><br><span class="line">            iter = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果CAS不成功，重新获取锁的state, 从for循环开始处重新开始</span></span><br><span class="line">            old = m.state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Unlock"><a href="#Unlock" class="headerlink" title="Unlock"></a>Unlock</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果state不是处于锁的状态, 那么就是Unlock根本没有加锁的mutex, panic</span></span><br><span class="line">    <span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放了锁，还得需要通知其它等待者</span></span><br><span class="line">    <span class="comment">// 锁如果处于饥饿状态，直接交给等待队列的第一个, 唤醒它，让它去获取锁</span></span><br><span class="line">    <span class="comment">// 锁如果处于正常状态，</span></span><br><span class="line">    <span class="comment">// new state如果是正常状态</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">        old := <span class="built_in">new</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有等待的goroutine, 或者锁不处于空闲的状态，直接返回.</span></span><br><span class="line">            <span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将等待的goroutine数减一，并设置woken标识</span></span><br><span class="line">            <span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">            <span class="comment">// 设置新的state, 这里通过信号量会唤醒一个阻塞的goroutine去获取锁.</span></span><br><span class="line">            <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">                runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            old = m.state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 饥饿模式下， 直接将锁的拥有权传给等待队列中的第一个.</span></span><br><span class="line">        <span class="comment">// 注意此时state的mutexLocked还没有加锁，唤醒的goroutine会设置它。</span></span><br><span class="line">        <span class="comment">// 在此期间，如果有新的goroutine来请求锁， 因为mutex处于饥饿状态， mutex还是被认为处于锁状态，</span></span><br><span class="line">        <span class="comment">// 新来的goroutine不会把锁抢过去.</span></span><br><span class="line">        runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据<code>Unlock</code>的代码分析，下面的哪个答案正确?</p><p>如果一个goroutine <code>g1</code> 通过<code>Lock</code>获取了锁， 在持有锁的期间， 另外一个goroutine <code>g2</code> 调用<code>Unlock</code>释放这个锁， 会出现什么现象？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        mu.Lock()</span><br><span class="line">        time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">        mu.Unlock()</span><br><span class="line">    &#125;()</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    mu.Unlock()</span><br><span class="line">    <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁被另一个goroutine解了，再次解锁时会panic</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Mutex解析&quot;&gt;&lt;a href=&quot;#Mutex解析&quot; class=&quot;headerlink&quot; title=&quot;Mutex解析&quot;&gt;&lt;/a&gt;Mutex解析&lt;/h2&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210820004216764.png&quot; alt=&quot;image-20210820004216764&quot; style=&quot;zoom:50%;&quot; /&gt;</summary>
    
    
    
    
    <category term="go 源码" scheme="https://cwww3.github.io/tags/go-%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>WaitGroup</title>
    <link href="https://cwww3.github.io/2021/08/19/WaitGroup/"/>
    <id>https://cwww3.github.io/2021/08/19/WaitGroup/</id>
    <published>2021-08-19T12:57:52.000Z</published>
    <updated>2021-08-19T12:59:49.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WaitGroup介绍"><a href="#WaitGroup介绍" class="headerlink" title="WaitGroup介绍"></a>WaitGroup介绍</h2><p>WaitGroup 提供了三个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><span id="more"></span><ul><li>Add，用来设置 WaitGroup 的计数值；</li><li>Done，用来将 WaitGroup 的计数值减 1，其实就是调用了 Add(-1)；</li><li>Wait，调用这个方法的 goroutine 会一直阻塞，直到 WaitGroup 的计数值变为 0。</li></ul><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> noCopy <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 避免复制使用的一个技巧，可以告诉vet工具违反了复制使用的规则</span></span><br><span class="line">noCopy noCopy</span><br><span class="line"><span class="comment">// 一个复合值，用来表示waiter数、计数值、信号量</span></span><br><span class="line">state1 [<span class="number">3</span>]<span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取state的地址和信号量的地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">state</span><span class="params">()</span> <span class="params">(statep *<span class="keyword">uint64</span>, semap *<span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;wg.state1))%<span class="number">8</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 如果地址是64bit对齐的，数组前两个元素做state，后一个元素做信号量</span></span><br><span class="line"><span class="keyword">return</span> (*<span class="keyword">uint64</span>)(unsafe.Pointer(&amp;wg.state1)), &amp;wg.state1[<span class="number">2</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果地址是32bit对齐的，数组后两个元素用来做state，它可以用来做64bit的原子操作，第一个元素32bit用来做信号量</span></span><br><span class="line"><span class="keyword">return</span> (*<span class="keyword">uint64</span>)(unsafe.Pointer(&amp;wg.state1[<span class="number">1</span>])), &amp;wg.state1[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WaitGroup中state方法的内存对齐"><a href="#WaitGroup中state方法的内存对齐" class="headerlink" title="WaitGroup中state方法的内存对齐"></a>WaitGroup中state方法的内存对齐</h3><p><code>noCopy</code>是一个空的结构体，大小为0，不需要做内存对齐，所以可以忽略这个字段。</p><p>使用了<code>uint32</code>的数组来构造<code>state1</code>字段，然后根据系统的位数的不同构造不同的返回值，下面说说怎么通过sate1这个字段构建waiter数、计数值、信号量的。</p><h3 id="state1状态和信号量处理"><a href="#state1状态和信号量处理" class="headerlink" title="state1状态和信号量处理"></a><code>state1</code>状态和信号量处理</h3><p><code>state1</code>这里总共被分配了<code>12</code>个字节，这里被设计了三种状态：</p><ul><li>其中对齐的<code>8</code>个字节作为状态，高<code>32</code>位为计数的数量，低<code>32</code>位为等待的<code>goroutine</code>数量</li><li>其中的<code>4</code>个字节作为信号量存储</li></ul><p>提供了<code>(wg *WaitGroup) state() (statep *uint64, semap *uint32)</code>从<code>state1</code>字段中取出他的状态和信号量。</p><p>首先<code>unsafe.Pointer</code>来获取state1的地址值然后转换成uintptr类型的，然后判断一下这个地址值是否能被8整除，这里通过地址 mod 8的方式来判断地址是否是64位对齐。</p><p>因为有内存对齐的存在，在64位架构里面WaitGroup结构体state1起始的位置肯定是64位对齐的，所以在64位架构上用state1前两个元素并成uint64来表示statep，state1最后一个元素表示semap；</p><p>但是在32位架构里面，一个字长是4bytes，要操作64位的数据分布在<strong>两个数据块</strong>中，需要两次操作才能完成访问。如果两次操作中间有可能别其他操作修改，不能保证原子性。</p><p>同理32位架构想要原子性的操作8bytes，需要由调用方保证其数据地址是64位对齐的，否则原子访问会有异常。</p><p>在32位架构中，WaitGroup在初始化的时候，分配内存地址的时候是随机的，所以WaitGroup结构体state1起始的位置不一定是64位对齐，可能会是：<code>uintptr(unsafe.Pointer(&amp;wg.state1))%8 = 4</code>，如果出现这样的情况，那么就需要用state1的第一个元素做padding，用state1的后两个元素合并成uint64来表示statep。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210819203755697.png" alt="image-20210819203755697" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210819204844516.png" alt="image-20210819204844516" style="zoom:50%;" /><h3 id="Add-方法"><a href="#Add-方法" class="headerlink" title="Add 方法"></a>Add 方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取状态值</span></span><br><span class="line">statep, semap := wg.state()</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 高32bit是计数值v，所以把delta左移32，增加到计数上</span></span><br><span class="line">state := atomic.AddUint64(statep, <span class="keyword">uint64</span>(delta)&lt;&lt;<span class="number">32</span>)</span><br><span class="line"><span class="comment">// 获取计数器的值</span></span><br><span class="line">v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line"><span class="comment">// 获取waiter的值</span></span><br><span class="line">w := <span class="keyword">uint32</span>(state)</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 任务计数器不能为负数</span></span><br><span class="line"><span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;sync: negative WaitGroup counter&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// wait不等于0说明已经执行了Wait，此时不容许Add(正数)</span></span><br><span class="line"><span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; delta &gt; <span class="number">0</span> &amp;&amp; v == <span class="keyword">int32</span>(delta) &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计数器的值大于或者没有waiter在等待,直接返回</span></span><br><span class="line"><span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> *statep != state &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 根据上面的条件 此时v等于0且w&gt;0</span></span><br><span class="line">  <span class="comment">// statep清零 可以在Wait()阻塞之后可以重用</span></span><br><span class="line">*statep = <span class="number">0</span></span><br><span class="line">  <span class="comment">// w一般等于1，一般是main函数执行了一次Wait()方法</span></span><br><span class="line"><span class="keyword">for</span> ; w != <span class="number">0</span>; w-- &#123;</span><br><span class="line">    <span class="comment">//释放信号量，执行一次释放一个，唤醒一个等待者，一般是唤醒main(goroutine)</span></span><br><span class="line">runtime_Semrelease(semap, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Wait方法"><a href="#Wait方法" class="headerlink" title="Wait方法"></a>Wait方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">statep, semap := wg.state()</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">state := atomic.LoadUint64(statep)</span><br><span class="line"><span class="comment">// 获取counter</span></span><br><span class="line">v := <span class="keyword">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line"><span class="comment">// 获取waiter</span></span><br><span class="line">w := <span class="keyword">uint32</span>(state)</span><br><span class="line"><span class="comment">// counter为零,不需要等待直接返回</span></span><br><span class="line"><span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用CAS将waiter加1  执行一次Wait方法，wait值就加一，通过循环保证一定能加上</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class="number">1</span>) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 挂起等待唤醒  等待Add方法中runtime_Semrelease唤醒</span></span><br><span class="line">runtime_Semacquire(semap)</span><br><span class="line">      <span class="comment">// 唤醒之后statep应该是清零的 如果不为零,表示WaitGroup又被重复使用,这会panic</span></span><br><span class="line">      <span class="comment">// 在全部调用Wait的goroutine都被唤醒后wg才能再次使用</span></span><br><span class="line"><span class="keyword">if</span> *statep != <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup is reused before previous Wait has returned&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">         <span class="comment">// 直接返回   </span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><p>写个例子去debug一下，看一下个状态下w，v的值，就会清晰很多</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;WaitGroup介绍&quot;&gt;&lt;a href=&quot;#WaitGroup介绍&quot; class=&quot;headerlink&quot; title=&quot;WaitGroup介绍&quot;&gt;&lt;/a&gt;WaitGroup介绍&lt;/h2&gt;&lt;p&gt;WaitGroup 提供了三个方法：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(wg *WaitGroup)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(delta &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(wg *WaitGroup)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(wg *WaitGroup)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="go 源码" scheme="https://cwww3.github.io/tags/go-%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>pprof</title>
    <link href="https://cwww3.github.io/2021/07/19/pprof/"/>
    <id>https://cwww3.github.io/2021/07/19/pprof/</id>
    <published>2021-07-19T05:11:46.000Z</published>
    <updated>2021-07-19T05:12:14.518Z</updated>
    
    <content type="html"><![CDATA[<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><ul><li>web程序 </li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_ <span class="string">&quot;net/http/pprof&quot;</span> <span class="comment">// 引入 pprof 包</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  ...</span><br><span class="line">  fmt.Println(http.ListenAndServe(<span class="string">&quot;localhost:port&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于非web程序 </li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过启动一个goroutine监听端口</span></span><br><span class="line">main() &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(http.ListenAndServe(<span class="string">&quot;localhost:port&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;()</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 或者使用runtime/pprof包 并从程序中获取相关信息</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_ <span class="string">&quot;runtime/pprof&quot;</span> <span class="comment">// 引入 pprof 包</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="采集信息"><a href="#采集信息" class="headerlink" title="采集信息"></a>采集信息</h3><ul><li>接口获取</li></ul><p>通过访问 <code>http://localhost:port/debug/pprof/</code>采集数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 对 CPU 的信息采集三秒，然后输出到 cpu.pprof 文件中</span></span><br><span class="line">curl http://localhost:port/debug/pprof/profile?seconds=3 -o cpu.pprof</span><br><span class="line"><span class="meta">#</span><span class="bash"> 等价</span></span><br><span class="line">curl http://localhost:port/debug/pprof/profile?seconds=3 &gt; cpu.pprof</span><br></pre></td></tr></table></figure><ul><li>程序中获取</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 trace 信息</span></span><br><span class="line">f, err := os.Create(<span class="string">&quot;trace.out&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = trace.Start(f)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 CPU 的信息</span></span><br><span class="line"><span class="keyword">var</span> cpuprofile = flag.String(<span class="string">&quot;cpuprofile&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;write cpu profile to `file`&quot;</span>)</span><br><span class="line">flag.Parse()</span><br><span class="line"><span class="keyword">if</span> *cpuprofile != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    f, err := os.Create(*cpuprofile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;could not create CPU profile: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    <span class="keyword">if</span> err := pprof.StartCPUProfile(f); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;could not start CPU profile: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> pprof.StopCPUProfile()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取内存信息</span></span><br><span class="line"><span class="keyword">var</span> memprofile = flag.String(<span class="string">&quot;memprofile&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;write memory profile to `file`&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> *memprofile != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    f, err := os.Create(*memprofile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;could not create memory profile: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close() </span><br><span class="line">    runtime.GC() </span><br><span class="line">    <span class="keyword">if</span> err := pprof.WriteHeapProfile(f); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;could not write memory profile: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="可视化分析"><a href="#可视化分析" class="headerlink" title="可视化分析"></a>可视化分析</h3><p><code>go tool pprof</code> 既可以对采集到的离线数据进行分析，也可以是结合上面的 pprof http 接口，直接在线上进行分析</p><ul><li>在线分析</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 交互式界面</span></span><br><span class="line">go tool pprof http://localhost:port/debug/pprof/heap</span><br></pre></td></tr></table></figure><ul><li>离线分析</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 交互式界面</span></span><br><span class="line">go tool pprof memory.prof</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以web形式打开</span></span><br><span class="line">go tool pprof -http=:port memory.prof</span><br></pre></td></tr></table></figure><p><code>go tool trace</code>  无法在线上完成，只能通过线下的方式完成</p><ul><li>离线分析</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool trace trace.out</span><br></pre></td></tr></table></figure><h3 id="压测工具"><a href="#压测工具" class="headerlink" title="压测工具"></a>压测工具</h3><ul><li><a href="https://github.com/wg/wrk">wrk地址</a> </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/wg/wrk</span><br><span class="line">cd wrk</span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认情况下wrk会使用自带的LuaJIT和OpenSSL，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果你想使用系统已安装的版本，可以使用WITH_LUAJIT和WITH_OPENSSL这两个选项来指定它们的路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make WITH_LUAJIT=/usr WITH_OPENSSL=/usr</span></span><br><span class="line">make</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在当前目录生成wrk二进制文件 可以将其拷贝到<span class="variable">$PATH</span>目录下</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用方法: wrk &lt;选项&gt; &lt;被测HTTP服务的URL&gt;</span>                            </span><br><span class="line">  Options:                                            </span><br><span class="line">    -c, --connections &lt;N&gt;  跟服务器建立并保持的TCP连接数量  </span><br><span class="line">    -d, --duration    &lt;T&gt;  压测时间           </span><br><span class="line">    -t, --threads     &lt;N&gt;  使用多少个线程进行压测   </span><br><span class="line">                                                      </span><br><span class="line">    -s, --script      &lt;S&gt;  指定Lua脚本路径       </span><br><span class="line">    -H, --header      &lt;H&gt;  为每一个HTTP请求添加HTTP头      </span><br><span class="line">        --latency          在压测结束后，打印延迟统计信息   </span><br><span class="line">        --timeout     &lt;T&gt;  超时时间     </span><br><span class="line">    -v, --version          打印正在使用的wrk的详细版本信息</span><br><span class="line">                                                      </span><br><span class="line">  &lt;N&gt;代表数字参数，支持国际单位 (1k, 1M, 1G)</span><br><span class="line">  &lt;T&gt;代表时间参数，支持时间单位 (2s, 2m, 2h)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用8个线程200个连接，对bing首页进行了30秒的压测，并要求在压测结果中输出响应延迟信息</span></span><br><span class="line">wrk -t8 -c200 -d30s --latency  &quot;http://www.bing.com&quot;  </span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/rakyll/hey">hey地址</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;部署&quot;&gt;&lt;a href=&quot;#部署&quot; class=&quot;headerlink&quot; title=&quot;部署&quot;&gt;&lt;/a&gt;部署&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;web程序 &lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	_ &lt;span class=&quot;string&quot;&gt;&amp;quot;net/http/pprof&amp;quot;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;// 引入 pprof 包&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="pprof" scheme="https://cwww3.github.io/tags/pprof/"/>
    
  </entry>
  
  <entry>
    <title>mq</title>
    <link href="https://cwww3.github.io/2021/07/14/mq/"/>
    <id>https://cwww3.github.io/2021/07/14/mq/</id>
    <published>2021-07-14T10:12:29.000Z</published>
    <updated>2021-07-14T10:14:54.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ul><li>解耦</li><li>异步</li><li>流量削峰</li></ul><span id="more"></span><h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><p>AMQP的全称为：Advanced Message Queuing Protocol（高级消息队列协议）。</p><p>相比JMS：</p><ol><li>JMS定义的是API规范，而AMQP定义了线路层的协议。即JMS实现所发送的消息不能保证被另外不同的JMS实现使用；而AMQP的线路层协议规范了消息的格式，这样不仅能跨AMQP实现，还能跨语言和跨平台。</li><li>AMQP具有更加灵活和透明的消息模型。JMS中只有点对点和发布-订阅两种模式；而AMQP通过将消息生产者与消息队列解耦实现多种方式来发送消息。</li></ol><p>JMS：(ActiveMQ)</p><ul><li>消息生产者 </li><li>消息消费者</li><li>消息通道</li></ul><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210713101139876.png" alt="image-20210713101139876" style="zoom:50%;" /><p>消息生产者将消息发送到通道中，消费者从通道中取出数据消费。</p><p>通道具有双重责任： </p><ol><li>解耦消息的生产者与消费者；</li><li>传递数据以及确定消息发送地方。</li></ol><p>AMQP：</p><p>在消息的生产者与通道之间引入了一种机制：Exchange（交换器），解耦了消息的生产者与队列。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210713101403330.png" alt="image-20210713101403330" style="zoom: 25%;" /><p>消息生产者将消息（带有一个routing key参数）发送到Exchange上，Exchange会绑定一个或多个队列上，然后Exchange根据不同的路由模式，对比队列携带的routing key参数，负责将信息发送到不同队列上。</p><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210713105130472.png" alt="image-20210713105130472" style="zoom:50%;" /><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p>消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</p><h3 id="Publisher"><a href="#Publisher" class="headerlink" title="Publisher"></a>Publisher</h3><p>消息的生产者，也是一个向交换器发布消息的客户端应用程序。</p><h3 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h3><p>Exchange称作交换器，它接收消息和路由消息，然后将消息发送给消息队列。每个交换器都有独一无二的名字。相当于一个路由表。</p><h3 id="Binding-和-Binding-Key"><a href="#Binding-和-Binding-Key" class="headerlink" title="Binding 和 Binding Key"></a>Binding 和 Binding Key</h3><p>每个Exchange都和一个特定的Queue绑定（可以是多对多的关系）。绑定的同时会指定一个binding key。</p><p>每个发送给Exchange的消息一般都有一个routing key参数；当队列与Exchange绑定的binding key与该消息的routing key参数相同的时候，该消息才会被Exchange发给特定的队列。</p><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>Queue是一个不重复，唯一，名字随机的的缓冲区，应用程序在其权限之内可以自由地创建、共享使用和消费消息队列。在RabbitMQ中，队列的名字是系统随机创建的，且当Consumer与Queue断开连接的时候，Queue会被自动删除，在下一次连接时又会自动创建。</p><h3 id="Routing-Key"><a href="#Routing-Key" class="headerlink" title="Routing Key"></a>Routing Key</h3><p>生产者在将消息发送给Exchange的时候，一般会指定一个routing key，来指定这个消息的路由规则。<br>而这个routing key需要与Exchange Type及binding key联合使用才能最终生效。<br>在Exchange Type与binding key固定的情况下，生产者就可以在发送消息给Exchange时，通过指定routing key来决定消息流向哪里。<br>RabbitMQ为routing key设定的长度限制为255 bytes。</p><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内地虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</p><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</p><h3 id="Virtual-Host"><a href="#Virtual-Host" class="headerlink" title="Virtual Host"></a>Virtual Host</h3><p>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</p><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>表示消息队列服务器实体。</p><h3 id="Exchange-Type"><a href="#Exchange-Type" class="headerlink" title="Exchange Type"></a>Exchange Type</h3><p>AMQP定义了4种不同类型的Exchange，每一种都有不同的路由算法。</p><h4 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h4><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210713102242328.png" alt="image-20210713102242328" style="zoom:50%;" /><p>生产者P发送消息到交换器X。</p><p>消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。路由键与队列名<strong>完全匹配</strong>，单播的模式。</p><p>如果消息的routing key 是 orange，则会被路由到队列Q1；<br>如果消息的routing key 是 black 或 green，则会被路由到队列Q2。</p><p>也可以实现多路绑定，即当X和Q1、Q2都绑定了black，routing key 是 black 时，两个队列都能接收到消息。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210713102542004.png" alt="image-20210713102542004" style="zoom:50%;" /><h4 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h4><p>topic 交换器通过<strong>模式匹配</strong>分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用<code>. </code>隔开。它同样也会识别两个通配符：符号<code>#</code>和符号<code>*</code>。<code>#</code>匹配0个或多个单词，<code>*</code>匹配一个单词。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210713102637590.png" alt="image-20210713102637590" style="zoom:50%;" /><h4 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a>Fanout</h4><p>每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的。</p><p>生产者（P）发送到Exchange（X）的所有消息都会路由到图中的两个Queue，并最终被两个消费者（C1与C2）消费。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210713103054848.png" alt="image-20210713103054848" style="zoom:50%;" /><h3 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h3><p>headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。与direct相似，但是效率较低。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://www.erlang.org/downloads">erlang</a>  <a href="https://www.rabbitmq.com/download.html">rabbitmq</a></p><p>mac 通过<code>brew install rabbitmq</code> 安装会自动下载erlang依赖</p><p>ARM 版 rabbitmq 路径 <code>/opt/homebrew/sbin </code>  X86 版  <code>/usr/local/Homebrew/sbin</code></p><p>添加到$PATH下</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><a href="https://github.com/cwww3/rabbitmq-go-demo">项目地址</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;消息队列&quot;&gt;&lt;a href=&quot;#消息队列&quot; class=&quot;headerlink&quot; title=&quot;消息队列&quot;&gt;&lt;/a&gt;消息队列&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;解耦&lt;/li&gt;
&lt;li&gt;异步&lt;/li&gt;
&lt;li&gt;流量削峰&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="mq" scheme="https://cwww3.github.io/tags/mq/"/>
    
  </entry>
  
  <entry>
    <title>protobuf</title>
    <link href="https://cwww3.github.io/2021/07/14/protobuf/"/>
    <id>https://cwww3.github.io/2021/07/14/protobuf/</id>
    <published>2021-07-14T10:07:27.000Z</published>
    <updated>2021-10-11T03:50:52.697Z</updated>
    
    <content type="html"><![CDATA[<h3 id="message"><a href="#message" class="headerlink" title="message"></a>message</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">int32</span> result_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><ul><li>文件后缀<code>.proto</code></li><li>第一行定义版本 默认 <code>proto2</code> </li><li>唯一的数字编号用于识别在消息二进制格式中的字段。一旦被使用，不能更改。1-15只需要一个字节进行编码，用于标识频繁使用的字段。数字编号有一定的范围，且有一些预定义的数字。</li><li><code>proto3</code> 字段默认是 <code>singular</code> 的，标识0个或1个。<code>repeated</code> 标识0个或多个</li><li>一个<code>.proto</code> 文件中可以定义多个消息类型。</li><li>可以通过<code>import</code> 引入定义在其他<code>.protocol</code> 中的消息类型</li><li>注释格式 当行<code>//</code>  多行<code>/*...*/</code></li></ul><h3 id="更新消息类型"><a href="#更新消息类型" class="headerlink" title="更新消息类型"></a>更新消息类型</h3><ul><li><p>如果因为更新删除一个字段或将其直接注释掉，这些被删掉的字段可能被重新使用，加载老版本的数据时，可能会造成数据冲突。</p></li><li><p>可以通过指定保留你删除的字段的编号或名字，这样当使用该数字编号时，编译器会报错。(JSON序列化可能会有问题)</p></li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  reserved <span class="number">2</span>, <span class="number">15</span>, <span class="number">9</span> to <span class="number">11</span>; <span class="comment">// 不能在同一个保留语句中(reserved)混合使用编号和字段名</span></span><br><span class="line">  reserved <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型对应"><a href="#类型对应" class="headerlink" title="类型对应"></a>类型对应</h3><table><thead><tr><th>proto类型</th><th>Go类型</th></tr></thead><tbody><tr><td>double</td><td>float64</td></tr><tr><td>float</td><td>float32</td></tr><tr><td>int32,int64 (对负数编码效率低)</td><td>int32,int64</td></tr><tr><td>sint32,sint64  (适用于对负数编码)</td><td>int32,int64</td></tr><tr><td>uint32,uint64</td><td>uint32,uint64</td></tr><tr><td>bytes</td><td>[]bytes</td></tr><tr><td>string</td><td>string</td></tr><tr><td>bool</td><td>bool</td></tr><tr><td>message</td><td>*struct  []*struct</td></tr></tbody></table><h3 id="GRPC"><a href="#GRPC" class="headerlink" title="GRPC"></a>GRPC</h3><ul><li><p>是rpc的框架</p></li><li><p>服务类型</p><ul><li>一元RPC</li><li>服务端流式RPC</li><li>客服端流式RPC</li><li>双向流式 RPC</li></ul></li><li><p>在服务器端，服务器实现服务声明的方法并运行 gRPC 服务器来处理客户端调用。gRPC 基础设施解码传入请求、执行服务方法并编码服务响应。</p></li><li><p>在客户端，客户端有一个称为<em>stub</em>的本地对象，它实现与服务相同的方法(由proto生成的文件)。然后客户端可以在本地对象上调用这些方法，将调用的参数包装在适当的协议缓冲区消息类型中 ，gRPC 负责将请求发送到服务器并返回服务器的协议缓冲区响应。</p></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="installed-the-compiler"><a href="#installed-the-compiler" class="headerlink" title="installed the compiler"></a>installed the compiler</h4><p><a href="https://github.com/protocolbuffers/protobuf/releases">下载地址</a> 选择对应平台,解压并配置PATH路径</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210918102934244.png" alt="image-20210918102934244" style="zoom:50%;" /><h4 id="install-the-Go-protocol-buffers-plugin"><a href="#install-the-Go-protocol-buffers-plugin" class="headerlink" title="install the Go protocol buffers plugin"></a>install the Go protocol buffers plugin</h4><ul><li><a href="https://github.com/protocolbuffers/protobuf-go">两个版本</a></li><li>github(旧)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 自带grpc插件</span></span><br><span class="line">go get -u github.com/golang/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure><ul><li>google(新)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 不支持grpc, 需要下载protoc-gen-go-grpc</span></span><br><span class="line">go get -u google.golang.org/protobuf/cmd/protoc-gen-go</span><br><span class="line">或 go install google.golang.org/protobuf/cmd/protoc-gen-go@latest （go1.16）</span><br></pre></td></tr></table></figure><h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h3><p>当使用编译器编译<code>.proto</code> 文件时，编译器会生成你所选择的语言生成代码，对于Go,会生成一个<code>.pb.go</code>文件，里面包含<code>.proto</code>中的定义的每一个类型。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成Go类型文件需要在.proto文件中通过 go_package 指定包名</span>   </span><br><span class="line"><span class="meta">#</span><span class="bash"> 例 option go_package = <span class="string">&quot;./;packagename&quot;</span>;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --go_out指定.pb.go文件生成位置</span></span><br><span class="line">protoc --go_out=. *.proto</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成grpc文件(github版本)</span></span><br><span class="line">protoc --go_out=plugin=grpc:. *.proto</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成grpc文件(google版本)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装protoc-gen-go-grpc插件</span> </span><br><span class="line">go get google.golang.org/grpc/cmd/protoc-gen-go-grpc</span><br><span class="line"><span class="meta">#</span><span class="bash"> --go-grpc_out 指定grpc生成路径</span></span><br><span class="line">protoc --go_out=. --go-grpc_out=. *.proto</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><a href="https://github.com/cwww3/grpc_demo">示例代码</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;message&quot;&gt;&lt;a href=&quot;#message&quot; class=&quot;headerlink&quot; title=&quot;message&quot;&gt;&lt;/a&gt;message&lt;/h3&gt;&lt;figure class=&quot;highlight protobuf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;syntax = &lt;span class=&quot;string&quot;&gt;&amp;quot;proto3&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SearchRequest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; query = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;int32&lt;/span&gt; page_number = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;int32&lt;/span&gt; result_per_page = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="protobuf" scheme="https://cwww3.github.io/tags/protobuf/"/>
    
  </entry>
  
  <entry>
    <title>makefile</title>
    <link href="https://cwww3.github.io/2021/07/09/makefile/"/>
    <id>https://cwww3.github.io/2021/07/09/makefile/</id>
    <published>2021-07-09T08:08:08.000Z</published>
    <updated>2021-07-09T08:09:09.158Z</updated>
    
    <content type="html"><![CDATA[<p>Makefile由一条或多条规则构成。每条规则格式如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt; </span><br><span class="line">[tab]  &lt;commands&gt;</span><br></pre></td></tr></table></figure><span id="more"></span><p><code>target</code> 表示目标，即要创建的文件(可以是多个 通过空格隔开 通常是文件)，除了文件还可以是一个操作的名称，称为伪目标</p><p><code>prerequisites</code> 表示条件，即要创建target所需的文件 (可以是多个 通过空格隔开 )，也可以是伪目标</p><p><code>tab </code> 第二行要输入一个Tab键</p><p><code>commands</code> 表示能在终端执行的命令</p><p>示例</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">a.txt: b.txt c.txt</span></span><br><span class="line">    cat b.txt c.txt &gt; a.txt</span><br><span class="line"><span class="comment"># 要创建a必须要b和c </span></span><br><span class="line"><span class="comment"># Tab键后面更命令</span></span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: build</span></span><br><span class="line"><span class="section">build: b.txt c.txt</span></span><br><span class="line">    cat b.txt c.txt &gt; a.txt</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 这里的build就是一个伪目标</span></span><br><span class="line"><span class="comment"># Tab键后面更命令</span></span><br><span class="line"><span class="comment"># 为了防止正好有一个名为build的文件 导致make命令误认为build文件已存在，而不执行</span></span><br><span class="line"><span class="comment"># 可以通过 .PHONY明确声明build是一个伪目标</span></span><br></pre></td></tr></table></figure><p>make命令默认会根据当前目录的Makefile去进行编译构建，也可以通过-f指定文件。</p><p>make 默认只会执行Makefile中的第一个目标</p><p>通过 make target 执行指定规则 </p><p>正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）,可以通过命令前加@符号，取消打印。</p><p>make</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令中的注释也会被打印</span></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">    @<span class="comment"># 这是测试</span></span><br><span class="line">    @echo TODO</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Makefile由一条或多条规则构成。每条规则格式如下&lt;/p&gt;
&lt;figure class=&quot;highlight makefile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;target&amp;gt; : &amp;lt;prerequisites&amp;gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[tab]  &amp;lt;commands&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Makefile" scheme="https://cwww3.github.io/tags/Makefile/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://cwww3.github.io/2021/05/26/hello-world/"/>
    <id>https://cwww3.github.io/2021/05/26/hello-world/</id>
    <published>2021-05-26T02:22:03.000Z</published>
    <updated>2021-05-26T02:22:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><span id="more"></span><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&amp;quot;My New Post&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>背包问题</title>
    <link href="https://cwww3.github.io/2021/05/08/knapsack/"/>
    <id>https://cwww3.github.io/2021/05/08/knapsack/</id>
    <published>2021-05-08T15:27:01.000Z</published>
    <updated>2021-05-26T02:22:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210508233256021.png" alt="image-20210508233256021"></p><p>背包问题是动态规划问题。</p><span id="more"></span><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p>由上图可知，01背包的物品个数只有1，要么选，要么不选。</p><p>有N件物品和⼀个最多能被重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能⽤⼀次，求解将哪些物品装⼊背包⾥物品价值总和最⼤。</p><p>如果通过暴力解法去解，则要将所有的情况列出来，即每个物品都有两种可能，取或不去。所以有2的n次方种情况，n代表物品的件数。</p><p>时间复杂度就是O(2^n)。</p><p><strong>采用动态规划进行优化</strong></p><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><p>假设 背包最⼤重量为4，物品为：</p><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><ol><li>确定dp数组以及下标的含义</li></ol><p>定义<strong>dp[i][j]</strong> 表示从下标为 <strong>[0-i]<strong>的物品⾥任意取，放进容量为</strong>j</strong>的背包，价值总和最⼤是多少。</p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210508234909469.png" alt="image-20210508234909469" style="zoom:50%;" /><ol start="2"><li>确定递推公式</li></ol><p>有两个⽅向推出来dp[i][j]</p><ul><li><p>不选择下标为i的物品    由dp[i - 1][j]推出，  dp[i][j] = dp[i - 1][j]</p></li><li><p>选择下标为i的物品  由dp[i - 1][j - weight[i]]推出  dp[i][j] = dp[i][j] = dp[i - 1][j - weight[i]] + value[i]</p></li></ul><p>递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</p><ol start="3"><li> dp数组如何初始化</li></ol><p><strong>关于初始化，⼀定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。</strong></p><p>⾸先从dp[i][j]的定义触发，如果背包容量j为0的话，即dp[i][0]，⽆论是选取哪些物品，背包价值总和⼀定为0。如图：</p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210508235958966.png" alt="image-20210508235958966" style="zoom:50%;" /><p> i是由i-1推导的，当i为0时⼀定要初始化。</p><p>dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最⼤价值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 倒叙遍历 保证物品被使用一次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = bagWeight; j &gt;= weight[<span class="number">0</span>]; j--) &#123;</span><br><span class="line"> dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - weight[<span class="number">0</span>]] + value[<span class="number">0</span>]; <span class="comment">// 初始化i为0时候的情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正序遍历 dp[0][j - weight[0]]中可能已经加了 value[0]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = weight[<span class="number">0</span>]; j &lt;= bagWeight; j++) &#123;</span><br><span class="line"> dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - weight[<span class="number">0</span>]] + value[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dp数组初始化情况:</p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210509000854888.png" alt="image-20210509000854888" style="zoom:50%;" /><p>其他下标应该初始化多少呢？dp[i][j]在推导的时候⼀定是取价值最⼤的数，如果题⽬给的价值都是正整数那么⾮0下标都初始化为0就</p><p>可以了，因为0就是最⼩的了，不会影响取最⼤价值的结果。如果题⽬给的价值有负数，那么⾮0下标就要初始化为负⽆穷了。</p><ol start="4"><li>确定遍历顺序</li></ol><p>可以看出，有两个遍历的维度：物品与背包重量。应该先遍历哪个？其实都可以！！ 但是先遍历物品更好理解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先遍历物品</span></span><br><span class="line"><span class="comment">// weight数组的⼤⼩ 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= bagWeight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line"> <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j]; <span class="comment">// 容量不够-&gt;不选</span></span><br><span class="line"> <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先遍历背包重量</span></span><br><span class="line"><span class="comment">// weight数组的⼤⼩ 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= bagWeight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line"> <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"> <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>举例推导dp数组</li></ol><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210509002110466.png" alt="image-20210509002110466" style="zoom:50%;" /><p>最终结果就是dp[2][4]。</p><p><strong>做动态规划的题⽬，最好的过程就是⾃⼰在纸上举⼀个例⼦把对应的dp数组的数值推导⼀下，然后在动⼿写代码！</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> w = <span class="number">4</span></span><br><span class="line">weight := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">value := []<span class="keyword">int</span>&#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(weight))</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dp); i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, w+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> j := w; j &gt;= weight[<span class="number">0</span>]; j-- &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-weight[<span class="number">0</span>]] + value[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= w; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> weight[i] &gt; j &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weight[i]]+value[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(dp[<span class="built_in">len</span>(weight)<span class="number">-1</span>][w])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt;= b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一维数组-滚动数组"><a href="#一维数组-滚动数组" class="headerlink" title="一维数组(滚动数组)"></a>一维数组(滚动数组)</h4><p>对于背包问题其实状态都是可以压缩的。</p><p>在使⽤⼆维数组的时候，递推公式：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]</p><p>如果把 <strong>dp[i - 1]</strong> 那⼀层拷⻉到 <strong>dp[i]</strong> 上，表达式完全可以是：<strong>dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i])</strong> </p><p>这样就可以用一维数组表示。这就是滚动数组的由来，需要满⾜的条件是上⼀层可以重复利⽤，直接拷⻉到当前层。</p><p>动规五部曲分析如下：</p><ol><li>确定dp数组的定义</li></ol><p>在⼀维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最⼤为dp[j]。</p><ol start="2"><li>⼀维dp数组的递推公式</li></ol><p>dp[j] 表示 容量为j的背包所背的最⼤价值，那么如何推导dp[j]呢？</p><p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最⼤价值。</p><p>此时dp[j]有两个选择，⼀个是取⾃⼰dp[j]，⼀个是取dp[j - weight[i]] + value[i]，这就要看谁大了。</p><p>所以递归公式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure><ol start="3"><li>⼀维dp数组如何初始化</li></ol><p><strong>关于初始化，⼀定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。</strong></p><p>dp[j]表示：容量为j的背包，所背的物品价值可以最⼤为dp[j]。</p><p>那么dp[0]就应该是0，因为背包容量为0,所背的物品的最⼤价值就是0。</p><p>其他下标初始化。根据题目要求选择合适的值。</p><ol start="4"><li>⼀维dp数组遍历顺序</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line"> dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这⾥和⼆维dp的写法中，遍历背包的顺序是不⼀样的！</strong></p><p>⼆维dp遍历的时候，背包容量是从⼩到⼤，⽽⼀维dp遍历的时候，背包是从⼤到⼩。</p><p>⼀维<strong>dp</strong>数组的背包在遍历顺序上和⼆维其实是有很⼤差异的！，这⼀点⼀定要注意。</p><ol start="5"><li>举例推导dp数组</li></ol><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210509004924306.png" alt="image-20210509004924306" style="zoom:50%;" /><p>⼀维dp 的01背包，要⽐⼆维简洁的多！ 初始化 和 遍历顺序相对简单了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> w = <span class="number">4</span></span><br><span class="line">weight := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">value := []<span class="keyword">int</span>&#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, w+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化 dp[0]=0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := w; j &gt;= weight[i]; j-- &#123;</span><br><span class="line">dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(dp[w])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt;= b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ol><li><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">分割等和⼦集</a></li></ol><p>只要找到集合⾥能够出现 sum / 2 的⼦集总和，就算是可以分割成两个相同元素和⼦集了。</p><p><strong>转换为背包问题</strong>  </p><p>根据题目设定可知：</p><ul><li>背包的体积w为sum / 2 且不大于10000</li><li>背包要放⼊的商品（集合⾥的元素）重量为 元素的数值，价值也为元素的数值 , 即 nums=weight=value</li><li>背包<strong>正好装满</strong>，说明找到了总和为w 的⼦集。即dp[w] == w  （前提 num%2==0）</li><li>背包中每⼀个元素是不可重复放⼊。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canPartition</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">sum += num</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果是奇数 肯定不会相等</span></span><br><span class="line"><span class="keyword">if</span> sum%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w := sum / <span class="number">2</span></span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, w+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := w; j &gt;= nums[i]; j-- &#123;</span><br><span class="line">dp[j] = max(dp[j], dp[j-nums[i]]+nums[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> dp[w] == w &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt;= b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">最后⼀块⽯头的重量 <strong>II</strong></a></li></ol><p>本题其实就是<strong>尽量</strong>让⽯头分成重量相同的两堆，相撞之后剩下的⽯头最⼩，与上题类似，在最后的处理上有所不同。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lastStoneWeightII</span><span class="params">(stones []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> stones &#123;</span><br><span class="line">sum += num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w := sum / <span class="number">2</span></span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, w+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(stones); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := w; j &gt;= stones[i]; j-- &#123;</span><br><span class="line">dp[j] = max(dp[j], dp[j-stones[i]]+stones[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dp[w] &lt;= w</span></span><br><span class="line"><span class="keyword">return</span> sum - dp[w] - dp[w]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt;= b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>完全背包和<strong>01</strong>背包问题唯⼀不同的地⽅就是，每种物品有⽆限件。</p><p>01背包和完全背包唯⼀不同就是体现在<strong>遍历顺序</strong>上，所以直接针对遍历顺序经⾏分析！</p><p>我们知道01背包内嵌的循环是<strong>从⼤到⼩遍历</strong>，为了保证每个物品仅被添加⼀次。</p><p>⽽完全背包的物品是<strong>可以添加多次的，所以要从⼩到⼤去遍历</strong>，即：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先遍历物品，再遍历背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = weight[i]; j &lt; bagWeight ; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210509113830415.png" alt="image-20210509113830415" style="zoom:50%;" /><p><strong>为什么遍历物品在外层循环，遍历背包容量在内层循环？</strong></p><p>01背包中</p><ul><li>⼆维dp数组的两个for遍历的先后循序是可以颠倒的</li><li>⼀维dp数组的两个for循环先后循序⼀定是先遍历物品，再遍历背包容量。</li></ul><p>在完全背包中，</p><ul><li>对于⼀维<strong>dp</strong>数组来说，其实两个<strong>for</strong>循环嵌套顺序同样⽆所谓！</li></ul><p><strong>因为dp[j] 是根据 下标j之前所对应的dp[j]计算出来的。 只要保证下标j之前的dp[j]都是经过计算的就可以了。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一维数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> w = <span class="number">4</span></span><br><span class="line">weight := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">value := []<span class="keyword">int</span>&#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, w+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := weight[i]; j &lt;= w; j++ &#123;</span><br><span class="line">dp[j] = max(dp[j], dp[j-weight[i]]+value[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(dp[w])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> w = <span class="number">4</span></span><br><span class="line">weight := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">value := []<span class="keyword">int</span>&#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(weight))</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dp); i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, w+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正序</span></span><br><span class="line"><span class="keyword">for</span> j := weight[<span class="number">0</span>]; j &lt;= w; j++ &#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = j / weight[<span class="number">0</span>] * value[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= w; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j &lt; weight[i] &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weight[i]]+value[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(dp[<span class="built_in">len</span>(weight)<span class="number">-1</span>][w])</span><br><span class="line">fmt.Println(dp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><ol><li><a href="https://leetcode-cn.com/problems/coin-change-2/">零钱兑换 <strong>II</strong></a></li></ol><p>本题和纯完全背包不⼀样，纯完全背包是能否凑成总⾦额，⽽本题是要求凑成总⾦额的个数！</p><p>注意题⽬描述中是凑成总⾦额的硬币<strong>组合数</strong> </p><p><strong>求组合数还是排列数 会影响遍历的顺序</strong></p><p>动态规划五部曲:</p><ol><li><p>确定dp数组以及下标的含义</p><p>dp[j]：凑成总⾦额j的货币组合数为dp[j]</p></li><li><p> 确定递推公式</p></li></ol><p>   由原来组合方式的基础上 加上 加入当前硬币后新增的方式</p><p>   dp[j] = dp[j] + dp[j - coins[i]]</p><ol start="3"><li>dp数组如何初始化</li></ol><p>⾸先dp[0]⼀定要为1，dp[0] = 1的含义是凑成总⾦额0的货币组合数为1。</p><ol start="4"><li> 确定遍历顺序</li></ol><p>本题中是外层for循环遍历物品（钱币），内层for遍历背包（⾦钱总额），还是外层for遍历背包（⾦钱总额），内层for循环遍历物品（钱币）呢？</p><p>上文讲过完全背包的两个for循环的先后顺序都是可以，<strong>但本题就不⾏了！</strong></p><p>因为纯完全背包求得是能否凑成总和，和<strong>凑成总和的元素有没有顺序没关系</strong>，即：有顺序也⾏，没有顺序也⾏！</p><p>⽽本题要求凑成总和的<strong>组合数</strong>，元素之间<strong>要求没有顺序</strong>。</p><p>如果先遍历物品再遍历容量，那么是在第一个物品遍历完后，再遍历另一种物品。这样能保证顺序是固定的(求组合)。</p><p>如果先遍历容量在遍历物品，那么顺序是不确定的(求排列)。</p><p><strong>建议动⼿把这两种⽅案的dp数组数值变化打印出来，对⽐看⼀看！（实践出真知）</strong></p><ol start="5"><li>举例推导dp数组</li></ol><p>输⼊: amount = 5, coins = [1, 2, 5] ，dp状态图如下：</p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210509214749962.png" alt="image-20210509214749962" style="zoom:50%;" /><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(amount <span class="keyword">int</span>, coins []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// dp[i] 表示 金额为i时 一共有几种组合方式</span></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, amount+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 组合 --&gt; 要先遍历物品再遍历容量</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(coins); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j:=coins[i]; j&lt;=amount; j++ &#123;</span><br><span class="line">            <span class="comment">// 原来的组合方式数 + 加入该枚硬币后新增的组合数</span></span><br><span class="line">            dp[j] = dp[j] + dp[j-coins[i]] </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>多重背包与01背包和完全背包的区别在于，物品的是一个<strong>特定的值</strong>。</p><p>假如物品A的数量是2，把物品A当做两个独立的物品，那数量都是1，那么就转化为01背包问题了。</p><p>时间复杂度：O(m * n * k) m：物品种类个数，n背包容量，k单类物品数量</p><ol><li><p>构建一个新的weight数组和value数组</p></li><li><p>直接在2层for循环中再加一个循环</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> w = <span class="number">10</span></span><br><span class="line">weight := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">value := []<span class="keyword">int</span>&#123;<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">nums := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, w+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化 dp[0]=0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(weight); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := w; j &gt;= weight[i]; j-- &#123;</span><br><span class="line"><span class="comment">// 以上为01背包，然后加⼀个遍历个数</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="number">1</span>; k &lt;= nums[i] &amp;&amp; (j-k*weight[i]) &gt;= <span class="number">0</span>; k++ &#123; <span class="comment">//遍历个数</span></span><br><span class="line">dp[j] = max(dp[j], dp[j-k*weight[i]]+k*value[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(dp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fmt.Println(dp)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>还有那种⼆进制优化的⽅法，其实就是把每种物品的数量，打包成⼀个个独⽴的包。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210508233256021.png&quot; alt=&quot;image-20210508233256021&quot;&gt;&lt;/p&gt;
&lt;p&gt;背包问题是动态规划问题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://cwww3.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Order By 执行流程</title>
    <link href="https://cwww3.github.io/2021/05/08/mysql-order-by/"/>
    <id>https://cwww3.github.io/2021/05/08/mysql-order-by/</id>
    <published>2021-05-07T17:48:46.000Z</published>
    <updated>2021-05-26T02:22:03.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `city` varchar(16) NOT NULL,</span><br><span class="line">  `name` varchar(16) NOT NULL,</span><br><span class="line">  `age` int(11) NOT NULL,</span><br><span class="line">  `addr` varchar(128) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `city` (`city`)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select city,name,age from t where city=&#x27;杭州&#x27; order by name limit 1000  ;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h3><p>为避免全表扫描，我们需要在 city 字段加上索引。用 explain 命令来看看这个语句。</p><p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/826579b63225def812330ef6c344a303.png" alt="img"></p><p>Extra 这个字段中的“Using filesort”表示的就是需要排序，MySQL 会给每个线程分配一块内存用于排序，称为 <strong>sort_buffer</strong>。</p><p>examined_rows=4000，表示参与排序的行数是 4000 行。</p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210508003711460.png" alt="image-20210508003711460" style="zoom:50%;" /><p>从图中可以看到，满足 city=’杭州’条件的行，是从 ID_X 到 ID_(X+N) 的这些记录。</p><p>通常情况下，这个语句执行流程如下所示 ：</p><ol><li>初始化 sort_buffer，确定放入 name、city、age 这三个字段；</li><li>从索引 city 找到第一个满足 city=’杭州’条件的主键 id，也就是图中的 ID_X；</li><li>到主键 id 索引取出整行，取 name、city、age 三个字段的值，存入 sort_buffer 中；</li><li>从索引 city 取下一个记录的主键 id；</li><li>重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的 ID_Y；</li><li>对 sort_buffer 中的数据按照字段 name 做快速排序；</li><li>按照排序结果取前 1000 行返回给客户端。</li></ol><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210508003901677.png" alt="image-20210508003901677" style="zoom:50%;" /><p>图中“按 name 排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数 <strong>sort_buffer_size</strong>。</p><p>sort_buffer_size，就是 MySQL 为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。外部排序一般使用<strong>归并排序</strong>算法(多个临时文件分别排序)。</p><h3 id="rowid-排序"><a href="#rowid-排序" class="headerlink" title="rowid 排序"></a>rowid 排序</h3><p>在上面这个算法过程里面，只对原表的数据读了一遍，剩下的操作都是在 sort_buffer 和临时文件中执行的。但这个算法有一个问题，就是如果<strong>查询要返回的字段很多</strong>的话，那么 sort_buffer 里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。</p><p><strong>如果 MySQL 认为排序的单行长度太大会怎么做呢？</strong></p><p>修改一个参数，让 MySQL 采用另外一种算法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET max_length_for_sort_data = 16;</span><br><span class="line">-- 专门控制用于排序的行数据的长度的一个参数。如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法。</span><br></pre></td></tr></table></figure><p>city、name、age 这三个字段的定义总长度是 36，把 max_length_for_sort_data 设置为 16，再来看看计算过程有什么改变。</p><p>新的算法放入 sort_buffer 的字段，只有要<strong>排序的列</strong>（即 name 字段）和<strong>主键 id</strong>。但这时，排序的结果就因为少了 city 和 age 字段的值，不能直接返回了。流程如下：</p><ol><li>初始化 sort_buffer，确定放入两个字段，即 name 和 id；</li><li>从索引 city 找到第一个满足 city=’杭州’条件的主键 id，也就是图中的 ID_X；</li><li>到主键 id 索引取出整行，取 name、id 这两个字段，存入 sort_buffer 中；</li><li>从索引 city 取下一个记录的主键 id；</li><li>重复步骤 3、4 直到不满足 city=’杭州’条件为止，也就是图中的 ID_Y；</li><li>对 sort_buffer 中的数据按照字段 name 进行排序；</li><li>遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。</li></ol><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210508005237006.png" alt="image-20210508005237006" style="zoom:50%;" /><p>对比全字段排序会发现，rowid 排序多访问了一次表 t 的主键索引，就是步骤 7。</p><p>需要说明的是，最后的“结果集”是一个<strong>逻辑概念</strong>，实际上 MySQL 服务端从排序后的 sort_buffer 中依次取出 id，然后到原表查到 city、name 和 age 这三个字段的结果，不需要在服务端再耗费内存存储结果，是直接返回给客户端的。</p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>如果 MySQL 实在是担心排序内存太小，会影响排序效率，才会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</p><p>如果 MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</p><p>体现了 MySQL 的一个设计思想：<strong>如果内存够，就要多利用内存，尽量减少磁盘访问</strong>。</p><p>对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。</p><p>其实，并不是所有的 order by 语句，都需要排序操作的。从上面分析的执行过程，我们可以看到，MySQL 之所以需要生成临时表，并且在临时表上做排序操作，<strong>其原因是原来的数据都是无序的</strong>。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>如果能够保证从 city 这个索引上取出来的行，天然就是按照 name 递增排序的话，就可以不用再排序了。</p><p>所以，可以在这个市民表上创建一个 city 和 name 的<strong>联合索引</strong>。这样整个查询过程的流程就变成了：</p><ol><li>从索引 (city,name) 找到第一个满足 city=’杭州’条件的主键 id；</li><li>到主键 id 索引取出整行，取 name、city、age 三个字段的值，作为结果集的一部分直接返回；</li><li>从索引 (city,name) 取下一个记录主键 id；</li><li>重复步骤 2、3，直到查到第 1000 条记录，或者是不满足 city=’杭州’条件时循环结束。</li></ol><p><strong>进一步优化</strong></p><p>利用覆盖索引 创建一个 city、name 和 age 的联合索引，这样就不需要再回到主键索引上去取数据。(省去步骤2)</p><p>通过explain分析</p><p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/9e40b7b8f0e3f81126a9171cc22e3423.png" alt="img"></p><p>Extra 字段里面多了“Using index”，表示的就是使用了覆盖索引，性能上会快很多。</p><p>当然，这里并不是说要为了每个查询能用上覆盖索引，就要把语句中涉及的字段都建上联合索引，毕竟索引还是有维护代价的。这是一个需要<strong>权衡</strong>的决定。</p><h3 id="内存临时表"><a href="#内存临时表" class="headerlink" title="内存临时表"></a>内存临时表</h3><p>场景： 在一个存储单词且有10000条记录的表中随机取出三个单词</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select word from words order by rand() limit 3;</span><br></pre></td></tr></table></figure><p>explain 命令看看这个语句的执行情况</p><p><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/59a4fb0165b7ce1184e41f2d061ce350.png" alt="img"></p><p>Extra 字段显示 Using temporary，表示的是需要使用临时表；Using filesort，表示的是需要执行排序操作。</p><p><strong>对于临时内存表的排序来说，它会选择哪一种算法呢？</strong></p><p>之前的结论：对于 InnoDB 表来说，执行全字段排序会减少磁盘访问，因此会被优先选择。</p><p><strong>对于内存表，回表过程只是简单地根据数据行的位置，直接访问内存得到数据，根本不会导致多访问磁盘。</strong>优化器没有了这一层顾虑，那么它会优先考虑的，就是用于排序的行越小越好了，所以，MySQL 这时就会选择 rowid 排序。</p><p>这条语句的执行流程是这样的：</p><ol><li>创建一个临时表。这个临时表使用的是 memory 引擎，表里有两个字段，第一个字段是 double 类型，为了后面描述方便，记为字段 R，第二个字段是 varchar(64) 类型，记为字段 W。并且，这个表没有建索引。</li><li>从 words 表中，按主键顺序取出所有的 word 值。对于每一个 word 值，调用 rand() 函数生成一个大于 0 小于 1 的随机小数，并把这个随机小数和 word 分别存入临时表的 R 和 W 字段中，到此，扫描行数是 10000。</li><li>现在临时表有 10000 行数据了，接下来要在这个没有索引的内存临时表上，按照字段 R 排序。</li><li>初始化 sort_buffer。sort_buffer 中有两个字段，一个是 double 类型，另一个是整型。</li><li>从内存临时表中一行一行地取出 R 值和位置信息（后面会和你解释这里为什么是“位置信息”），分别存入 sort_buffer 中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加 10000，变成了 20000。</li><li>在 sort_buffer 中根据 R 的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫描行数。</li><li>排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出 word 值，返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了 20003。</li></ol><p>通过慢查询日志（slow log）来验证一下分析得到的扫描行数是否正确。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Query_time: 0.900376 Lock_time: 0.000347 Rows_sent: 3 Rows_examined: 20003</span><br><span class="line">SET timestamp=1541402277;</span><br><span class="line">select word from words order by rand() limit 3;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/cwww3/picture@master/img/image-20210508012334810.png" alt="image-20210508012334810" style="zoom:50%;" /><p>图中的 pos 就是位置信息，这里的“位置信息”是个什么概念？</p><p>回到一个基本概念：<strong>MySQL 的表是用什么方法来定位“一行数据”的。</strong></p><p>rowid 表示的是：每个引擎用来唯一标识数据行的信息。</p><ul><li>对于有主键的 InnoDB 表来说，这个 rowid 就是主键 ID；</li><li>对于没有主键的 InnoDB 表来说，这个 rowid 就是由系统生成的；</li><li>MEMORY 引擎不是索引组织表。在这个例子里面，可以认为它就是一个数组。因此，这个 rowid 其实就是数组的下标。</li></ul><p><strong>order by rand() 使用了内存临时表，内存临时表排序的时候使用了 rowid 排序方法。</strong></p><h3 id="磁盘临时表"><a href="#磁盘临时表" class="headerlink" title="磁盘临时表"></a>磁盘临时表</h3><p>是不是所有的临时表都是内存表呢？</p><p>tmp_table_size 这个配置限制了内存临时表的大小，默认值是 16M。如果临时表大小超过了 tmp_table_size，那么内存临时表就会转成磁盘临时表。</p><p>磁盘临时表使用的引擎默认是 InnoDB，是由参数 internal_tmp_disk_storage_engine 控制的。</p><p>为了复现这个过程，把 tmp_table_size 设置成 1024，把 sort_buffer_size 设置成 32768, 把 max_length_for_sort_data 设置成 16。</p><p>发现这个 SQL 语句的排序没有用到临时文件，原因是 MySQL 5.6 版本引入的一个新的排序算法，即：优先队列排序算法。(因为只娶了3条，没必要对所有的数据进行归并排序)</p>]]></content>
    
    
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CREATE TABLE `t` (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `id` int(11) NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `city` varchar(16) NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `name` varchar(16) NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `age` int(11) NOT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  `addr` varchar(128) DEFAULT NULL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  PRIMARY KEY (`id`),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  KEY `city` (`city`)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) ENGINE=InnoDB;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;select city,name,age from t where city=&amp;#x27;杭州&amp;#x27; order by name limit 1000  ;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="MySql" scheme="https://cwww3.github.io/tags/MySql/"/>
    
  </entry>
  
</feed>
