<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cwww3&#39;s Blog</title>
  
  <subtitle>Record what you think</subtitle>
  <link href="https://cwww3.github.io/atom.xml" rel="self"/>
  
  <link href="https://cwww3.github.io/"/>
  <updated>2022-09-03T18:17:14.531Z</updated>
  <id>https://cwww3.github.io/</id>
  
  <author>
    <name>Cwww3</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Informer机制</title>
    <link href="https://cwww3.github.io/2022/09/04/informer/"/>
    <id>https://cwww3.github.io/2022/09/04/informer/</id>
    <published>2022-09-03T18:15:50.000Z</published>
    <updated>2022-09-03T18:17:14.531Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNzYyNzc%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70.png" alt="在这里插入图片描述"></p><span id="more"></span><p>在 Informer 架构中，有多个核心组件</p><h3 id="Reflector"><a href="#Reflector" class="headerlink" title="Reflector"></a>Reflector</h3><p>Reflector 是用于监控指定资源的(Watch)，一旦资源发生改变，将资源存入 DeltaFIFO 中。</p><p>在第一次运行时，会先获取一份完成的资源列表(List)存入 DeltaFIFO 中。</p><h3 id="DeltaFIFO"><a href="#DeltaFIFO" class="headerlink" title="DeltaFIFO"></a>DeltaFIFO</h3><p>DeltaFIFO 可以分开理解，首先 FIFO 是一个先进先出的队列，拥有操作队列的基本方法，Delta 则是存储资源对象以及对象的操作类型(Add/Delete/Update/Sync)，DeltaFIFO 与其他队列最大的不同则是它会保留所有资源对象的操作类型，即队列中会存在拥有不同操作类型的同一个资源对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DeltaFIFO <span class="keyword">struct</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  queue []<span class="keyword">string</span>  <span class="comment">// 存储的是key,资源对象通过KeyOf生成key，key与资源对象对应</span></span><br><span class="line">  items <span class="keyword">map</span>[<span class="keyword">string</span>]Deltas <span class="comment">// map的key就是queue中的元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Deltas []Delta <span class="comment">// Delta 保存的是资源对象以及操作类型 Deltas中每个资源的操作类型都不同(去重)</span></span><br></pre></td></tr></table></figure><p>资源从队列中被 Pop 出之后，会执行 informer 会调用 HandleDeltas 方法，将它加入到 indexder 中，此外，还会将它分发给用户通过 Informer 的 AddEventHandler 方法注册的回调函数中。</p><h4 id="Resync"><a href="#Resync" class="headerlink" title="Resync"></a>Resync</h4><p>Resync 机制会将 Indexer 中存储的资源对象同步到 DeltaFIFO 中，并将这些资源对象设置为 Sync 的操作类型。</p><p>Resync 函数在 Reflector 中定时执行，执行周期由创建 informer 时设定。</p><h3 id="Indexer"><a href="#Indexer" class="headerlink" title="Indexer"></a>Indexer</h3><p>indexer 是 client-go 用来存储资源对象并自带索引功能的本地存储。Reflector 从 DeltaFIFO 中取出对象存储至 Indexer。Indexer 与 Etcd 中所保存的数据完全一致，client-go 可以很方便的从本地获取数据，而不需要每次请求 API Server 从 Etcd 中获取数据,从而减轻了 API Server 和 Etcd 的压力。</p><p>Indexer 是在 ThreadSafeMap 的基础上进行封装的。ThreadSafeMap 是一个并发读写安全的 map，Indexer 在此基础上实现了索引功能。</p><p>Index 有四个非常重要的数据结构，分别是 Indices(index 的复数形式),index,Indexers 和 IndexerFunc。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Indexers <span class="keyword">map</span>[<span class="keyword">string</span>]IndexFunc</span><br><span class="line"><span class="keyword">type</span> IndexFunc <span class="function"><span class="keyword">func</span><span class="params">(obj <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">string</span>, error)</span></span></span><br><span class="line"><span class="keyword">type</span> Indices <span class="keyword">map</span>[<span class="keyword">string</span>]Index</span><br><span class="line"><span class="keyword">type</span> Index <span class="keyword">map</span>[<span class="keyword">string</span>]sets.String</span><br></pre></td></tr></table></figure><p><strong>Indexers</strong>:用于存储索引器，key 为索引器的名称，value 位索引器的实现函数，它定义了获取资源对象的什么信息,以及如何获取,并组装成字符串数组返回。</p><p><strong>IndexFunc</strong>: 索引器函数，定义为接收一个资源对象，返回检索结果列表</p><p><strong>Indeces</strong>: 用于存储 Index，key 为索引器的名字，value 为 Index</p><p><strong>index</strong>: 用于存储缓存的数据</p><p>index.ByIndex 函数通过执行索引器函数得到索引结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *threadSafeMap)</span> <span class="title">ByIndex</span><span class="params">(indexName, indexKey <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">interface</span>()</span>,<span class="title">error</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  indexFunc := c.indexers[indexName] <span class="comment">// 根据索引器名称得到索引器函数</span></span><br><span class="line">  ... <span class="comment">// 执行该函数</span></span><br><span class="line"></span><br><span class="line">  index := c.indices[indexName] <span class="comment">// 根据索引器名称从indices中获取index</span></span><br><span class="line">  set := index[indexKey] <span class="comment">// 根据查询的key得到查询的结果</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cwww3/picture/master/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNzYyNzc%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="k8s" scheme="https://cwww3.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>processAndthread</title>
    <link href="https://cwww3.github.io/2022/07/23/processAndthread/"/>
    <id>https://cwww3.github.io/2022/07/23/processAndthread/</id>
    <published>2022-07-23T03:55:03.000Z</published>
    <updated>2022-07-23T03:55:19.150Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>创建 就绪 运行  阻塞  阻塞挂起 就绪挂起 结束 </p><p>程序阻塞时，会将程序所占用的物理内存,swap到硬盘上，此时进程进入了挂起状态</p><p>程序sleep也会导致挂起</p><span id="more"></span><h3 id="进程控制块（PCB）"><a href="#进程控制块（PCB）" class="headerlink" title="进程控制块（PCB）"></a>进程控制块（PCB）</h3><h4 id="进程描述信息"><a href="#进程描述信息" class="headerlink" title="进程描述信息"></a>进程描述信息</h4><p>进程标识符 用户标识符</p><h4 id="进程控制和管理信息"><a href="#进程控制和管理信息" class="headerlink" title="进程控制和管理信息"></a>进程控制和管理信息</h4><p>进程当前状态 进程的优先级</p><h4 id="资源分配清单"><a href="#资源分配清单" class="headerlink" title="资源分配清单"></a>资源分配清单</h4><p>有关内存地址空间或虚拟地址空间的信息</p><p>所打开的文件的列表，所使用的的I/O设备信息</p><h4 id="CPU相关信息"><a href="#CPU相关信息" class="headerlink" title="CPU相关信息"></a>CPU相关信息</h4><p>CPU中各个寄存器的值，当进程切换时，CPU的状态信息都会被保存在相应地PCB中，以便程序能从断点出继续执行</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程控制块（TCP）"><a href="#线程控制块（TCP）" class="headerlink" title="线程控制块（TCP）"></a>线程控制块（TCP）</h3><p>一个进程可以存在多个线程，线程之间共享进程的资源，除了维护自己所必需的栈以及寄存器。</p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>用户态线程，在用户态空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理</p><h2 id="CPU上下文切换"><a href="#CPU上下文切换" class="headerlink" title="CPU上下文切换"></a>CPU上下文切换</h2><p>CPU的上下文即程序计数器以及寄存器，程序计数器用来存储CPU正在执行的指令位置</p><p>CPU在执行任务前，需要设置好寄存器以及程序计数器</p><p>CPU上下文切换就是把前一个任务的CPU上下文保存起来，然后加载新任务，更新上下文信息。</p><p>任务即进程、线程和中断。</p><h3 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h3><p>进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，也包含了内核堆栈、寄存器等内核空间的资源</p><h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3><p>线程是进程当中的一条执行流程。</p><p>同一个进程内的多个线程可以共享代码段、数据段、打开的文件资源等，但每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相对独立的。</p><p>只需要切换线程的私有数据、寄存器等不共享的数据。</p><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>进程是资源分配的单位，线程是CPU调度的单位</p><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><h4 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h4><h4 id="最短作业有限"><a href="#最短作业有限" class="headerlink" title="最短作业有限"></a>最短作业有限</h4><h4 id="高响应比优先"><a href="#高响应比优先" class="headerlink" title="高响应比优先"></a>高响应比优先</h4><h4 id="时间片轮转"><a href="#时间片轮转" class="headerlink" title="时间片轮转"></a>时间片轮转</h4><h4 id="最高优先级"><a href="#最高优先级" class="headerlink" title="最高优先级"></a>最高优先级</h4><h4 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h4><p>抢占式/非抢占式</p><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><ol><li>管道</li><li>消息队列</li><li>共享内存(虚拟内存映射相同的物理地址)</li><li>信号量(P/V)</li><li>信号(kill)</li><li>socket</li></ol><h2 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h2><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>并发进程/线程在一些关键点上可能需要互相等待与互通消息，这种制约的等待与互通信息称为进程/线程同步。如操作A应在操作B之前执行…</p><h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><p>如操作A与操作B不能在同一时刻执行…</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>锁：加锁/解锁</p><p>信号量：P/V操作 </p><p>都可以实现互斥，信号量还可以实现同步</p><blockquote><p>哲学家就餐问题</p></blockquote><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁的四个必要条件：</p><ul><li>互斥</li><li>持有并等待</li><li>不可剥夺</li><li>环路</li></ul><p>解决死锁就是破坏这一个或多个条件。</p><p>最基本的锁有两种：</p><ol><li>互斥锁，抢锁失败后，线程释放CPU(阻塞，用户态陷入内核态)</li><li>自旋锁，抢锁失败后，线程忙等待，知道拿到锁</li></ol><p>上下文切换需要时间成本，如果锁住的代码执行时间较短，应该使用自旋锁。</p><h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><h5 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁 悲观锁"></a>乐观锁 悲观锁</h5><p>上面所提到的锁都是悲观锁</p><p>乐观锁全称并没有加锁，也叫无锁编程(在线文档)，虽然祛除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，适合在冲突概率低，且加锁成本非常高的场景。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h2&gt;&lt;h3 id=&quot;状态&quot;&gt;&lt;a href=&quot;#状态&quot; class=&quot;headerlink&quot; title=&quot;状态&quot;&gt;&lt;/a&gt;状态&lt;/h3&gt;&lt;p&gt;创建 就绪 运行  阻塞  阻塞挂起 就绪挂起 结束 &lt;/p&gt;
&lt;p&gt;程序阻塞时，会将程序所占用的物理内存,swap到硬盘上，此时进程进入了挂起状态&lt;/p&gt;
&lt;p&gt;程序sleep也会导致挂起&lt;/p&gt;</summary>
    
    
    
    
    <category term="os" scheme="https://cwww3.github.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>memory</title>
    <link href="https://cwww3.github.io/2022/07/23/memory/"/>
    <id>https://cwww3.github.io/2022/07/23/memory/</id>
    <published>2022-07-23T03:54:08.000Z</published>
    <updated>2022-09-03T18:24:40.803Z</updated>
    
    <content type="html"><![CDATA[<p>物理内存，大小有限，多个程序使用，不易分配。</p><p>引入虚拟地址，程序的视角认为整个内存只有它在使用。程序间相互隔离，互不影响。</p><p>CPU 中的内存管理单元(MMU)，负责将虚拟地址转化为实际的物理地址。</p><span id="more"></span><h3 id="管理虚拟地址和物理地址"><a href="#管理虚拟地址和物理地址" class="headerlink" title="管理虚拟地址和物理地址"></a>管理虚拟地址和物理地址</h3><h4 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h4><p>程序由若干个逻辑分段组成，代码分段、数据分段、栈段、堆段组成。虚拟地址由两部分组成，<strong>段选择因子</strong>和<strong>段内偏移量</strong>。根据段选择因子可以从存储在内存中的段表中找到<strong>段基地址</strong>，再根据段内偏移量，得到真正的物理地址。段选择因子还包含了其他信息,段界限(限制段的大小),特权级 DPL(读/写控制)</p><h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><p>内存碎片,会产生多个不连续的物理内存，导致新的程序无法被装载。</p><p>内存浪费，程序的所有内存都被装载到物理内存，但是有部分内存并不常用。</p><h5 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h5><p>内存交换，对于不连续的内存，可以读入到磁盘，再从磁盘中读出，连续地存入内存(Swap)</p><h5 id="问题：-1"><a href="#问题：-1" class="headerlink" title="问题："></a>问题：</h5><p>如果频繁的进行内存交换，且交换的是内存占用很大的程序，那么效率肯定会很低。引入分页解决</p><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>优化交换的内存大小，让需要交换写入或者从磁盘装载的数据更少一点。</p><p>分页是把<strong>整个虚拟和物理内存空间</strong>切成一段段固定尺寸的大小——页(Page).虚拟地址和物理地址的映射通过存储在内存中的页表来映射。<strong>页表保存所有虚拟地址和物理地址的映射</strong></p><p>如果内存空间不够，操作系统会把其他正在运行的进程中的最近没被使用的内存页面给释放掉，暂时暂时卸载硬盘上(Swap Out)，一旦需要，再加载进来(Swap In)。每次交换的大小就是一个页或者几个页，提升了交换的效率。</p><p>分页使得我们在加载程序的时候，不再需要一次性把程序加载到物理内存中，而只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里。</p><p>在分页机制下，虚拟地址分为<strong>页号</strong>和<strong>业内偏移</strong>，根据页号，能从页表中获取<strong>物理内存的基地址</strong>，再根据业内偏移得到物理内存地址。</p><h5 id="问题：-2"><a href="#问题：-2" class="headerlink" title="问题："></a>问题：</h5><p>因为页表存储的是整个虚拟地址和物理地址的映射，那么存储一个页表所需的内存会比较多，且每一个程序都会拥有一个自己的页表，那会导致很大一部分内存用于存储页表信息。</p><h5 id="解决：-1"><a href="#解决：-1" class="headerlink" title="解决："></a>解决：</h5><p>多级页表(Multi-Level Page Table)</p><p>一级页表中存储 1024 个页表项(覆盖整个虚拟空间的大小，相比原来一级分页中的页表空间占用小了很多)，根据页表项中的信息，可以得到二级页表中的页表项，再根据二级页表中的页表项得到物理地址。</p><p>根据<strong>局部性原理</strong>，每个进程都有 4GB 的虚拟空间，显然，其使用的空间远未达到 4GB，因为存在部分的页表项是空的，根本没有分配，对于已分配的页表项，如果一定时间未访问，在物理内存紧张的情况下，也会被换出到因硬盘。</p><p>所以如果使用了二级分页，<strong>如果一级页表的页表项没有被分配，就不需要创建二级页表了</strong>，这样就能减少页表对内存的占用。</p><h5 id="问题：-3"><a href="#问题：-3" class="headerlink" title="问题："></a>问题：</h5><p>虽然在空间上减少了占用，但是由于采用了多级映射的原因，导致地址转换的速度变慢了。</p><h5 id="解决：-2"><a href="#解决：-2" class="headerlink" title="解决："></a>解决：</h5><p>还是程序局部性原理，在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。利用这一特性，科学家在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache——TLB.</p><h4 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h4><p>分段和分页并不是对立的，可以组合起来使用。</p><ol><li>现将程序划分为多个有逻辑意义的段</li><li>再将每个段分为多个页</li></ol><p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/2022-09-02-20-03-49-image.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;物理内存，大小有限，多个程序使用，不易分配。&lt;/p&gt;
&lt;p&gt;引入虚拟地址，程序的视角认为整个内存只有它在使用。程序间相互隔离，互不影响。&lt;/p&gt;
&lt;p&gt;CPU 中的内存管理单元(MMU)，负责将虚拟地址转化为实际的物理地址。&lt;/p&gt;</summary>
    
    
    
    
    <category term="os" scheme="https://cwww3.github.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>go-sql</title>
    <link href="https://cwww3.github.io/2022/07/05/go-sql/"/>
    <id>https://cwww3.github.io/2022/07/05/go-sql/</id>
    <published>2022-07-05T15:58:13.000Z</published>
    <updated>2022-07-05T16:01:28.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sql源码浅析"><a href="#Sql源码浅析" class="headerlink" title="Sql源码浅析"></a>Sql源码浅析</h2><h3 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(driverName, dataSourceName <span class="keyword">string</span>)</span> <span class="params">(*DB, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 查找已注册的驱动 由_ &quot;github.com/go-sql-driver/mysql&quot;提供</span></span><br><span class="line">  <span class="comment">// 驱动是真正和数据库打交道的</span></span><br><span class="line">  driversMu.RLock()</span><br><span class="line">driveri, ok := drivers[driverName]</span><br><span class="line">driversMu.RUnlock()</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;sql: unknown driver %q (forgotten import?)&quot;</span>, driverName)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> driverCtx, ok := driveri.(driver.DriverContext); ok &#123;</span><br><span class="line">    <span class="comment">// 获取连接器</span></span><br><span class="line">connector, err := driverCtx.OpenConnector(dataSourceName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OpenDB(connector), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OpenDB(dsnConnector&#123;dsn: dataSourceName, driver: driveri&#125;), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// OpenDB may just validate its arguments without creating a connection</span></span><br><span class="line"><span class="comment">// to the database. To verify that the data source name is valid, call</span></span><br><span class="line"><span class="comment">// Ping.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenDB</span><span class="params">(c driver.Connector)</span> *<span class="title">DB</span></span> &#123;</span><br><span class="line">  <span class="comment">// 初始化数据，为后续维护连接池做准备</span></span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">db := &amp;DB&#123;</span><br><span class="line">connector:    c,</span><br><span class="line">openerCh:     <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, connectionRequestQueueSize),</span><br><span class="line">lastPut:      <span class="built_in">make</span>(<span class="keyword">map</span>[*driverConn]<span class="keyword">string</span>),</span><br><span class="line">connRequests: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint64</span>]<span class="keyword">chan</span> connRequest),</span><br><span class="line">stop:         cancel,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> db.connectionOpener(ctx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runs in a separate goroutine, opens new connections when requested.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">connectionOpener</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-db.openerCh:</span><br><span class="line">      <span class="comment">// 收到创建新的连接的请求</span></span><br><span class="line">db.openNewConnection(ctx)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="Tx"><a href="#Tx" class="headerlink" title="Tx"></a>Tx</h3><h4 id="Begin"><a href="#Begin" class="headerlink" title="Begin"></a>Begin</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Begin</span><span class="params">()</span> <span class="params">(*Tx, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> db.BeginTx(context.Background(), <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">BeginTx</span><span class="params">(ctx context.Context, opts *TxOptions)</span> <span class="params">(*Tx, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> tx *Tx</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">var</span> isBadConn <span class="keyword">bool</span></span><br><span class="line">  <span class="comment">// 重试策略</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; maxBadConnRetries; i++ &#123;</span><br><span class="line">    <span class="comment">// cachedOrNewConn 获取连接池的连接，如果没有，</span></span><br><span class="line">    <span class="comment">// 在连接没有到达设置的最大值时，就创建一个新的连接, 否则只能等待。</span></span><br><span class="line">    <span class="comment">//  inUse=true</span></span><br><span class="line">tx, err = db.begin(ctx, opts, cachedOrNewConn)</span><br><span class="line">isBadConn = errors.Is(err, driver.ErrBadConn)</span><br><span class="line"><span class="keyword">if</span> !isBadConn &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> isBadConn &#123;</span><br><span class="line"><span class="keyword">return</span> db.begin(ctx, opts, alwaysNewConn)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tx, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">begin</span><span class="params">(ctx context.Context, opts *TxOptions, strategy connReuseStrategy)</span> <span class="params">(tx *Tx, err error)</span></span> &#123;</span><br><span class="line">dc, err := db.conn(ctx, strategy)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// releaseConn释放连接时调用,放入连接池 inUse=false</span></span><br><span class="line"><span class="keyword">return</span> db.beginDC(ctx, dc, dc.releaseConn, opts)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">begin</span><span class="params">(ctx context.Context, opts *TxOptions, strategy connReuseStrategy)</span> <span class="params">(tx *Tx, err error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 根据策略获取到了dc</span></span><br><span class="line">dc, err := db.conn(ctx, strategy)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 传入dc</span></span><br><span class="line"><span class="keyword">return</span> db.beginDC(ctx, dc, dc.releaseConn, opts)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// beginDC starts a transaction. The provided dc must be valid and ready to use.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">beginDC</span><span class="params">(ctx context.Context, dc *driverConn, release <span class="keyword">func</span>(error)</span>, <span class="title">opts</span> *<span class="title">TxOptions</span>) <span class="params">(tx *Tx, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> txi driver.Tx</span><br><span class="line">keepConnOnRollback := <span class="literal">false</span></span><br><span class="line">withLock(dc, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">_, hasSessionResetter := dc.ci.(driver.SessionResetter)</span><br><span class="line">_, hasConnectionValidator := dc.ci.(driver.Validator)</span><br><span class="line">keepConnOnRollback = hasSessionResetter &amp;&amp; hasConnectionValidator</span><br><span class="line">    <span class="comment">// dc.ci就是驱动与数据库建立连接的原始结构,通过它开启事务，返回事务的原始结构</span></span><br><span class="line">txi, err = ctxDriverBegin(ctx, opts, dc.ci)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">release(err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Schedule the transaction to rollback when the context is canceled.</span></span><br><span class="line"><span class="comment">// The cancel function in Tx will be called after done is set to true.</span></span><br><span class="line">  <span class="comment">// 生成一个cancel Contxt，这个context伴随着这个事务，它的生命周期和事务一样长</span></span><br><span class="line">ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">tx = &amp;Tx&#123;</span><br><span class="line">db:                 db,</span><br><span class="line">dc:                 dc,</span><br><span class="line">releaseConn:        release,</span><br><span class="line">txi:                txi,</span><br><span class="line">cancel:             cancel,</span><br><span class="line">keepConnOnRollback: keepConnOnRollback,</span><br><span class="line">ctx:                ctx,</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 等待事务结束</span></span><br><span class="line"><span class="keyword">go</span> tx.awaitDone()</span><br><span class="line"><span class="keyword">return</span> tx, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// awaitDone blocks until the context in Tx is canceled and rolls back</span></span><br><span class="line"><span class="comment">// the transaction if it&#x27;s not already done.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">awaitDone</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Wait for either the transaction to be committed or rolled</span></span><br><span class="line"><span class="comment">// back, or for the associated context to be closed.</span></span><br><span class="line">  <span class="comment">// 等待context的结束</span></span><br><span class="line">  <span class="comment">// 在执行tx.Commit()或tx.RollBack()时，会调用cancel()</span></span><br><span class="line">&lt;-tx.ctx.Done()</span><br><span class="line"></span><br><span class="line">discardConnection := !tx.keepConnOnRollback</span><br><span class="line">  <span class="comment">// 如果不是由Commit或RollBack调用的cancel(),导致ctx结束，那么回滚会在这执行</span></span><br><span class="line">tx.rollback(discardConnection)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Commit commits the transaction.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">Commit</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="comment">// Check context first to avoid transaction leak.</span></span><br><span class="line">   <span class="comment">// If put it behind tx.done CompareAndSwap statement, we can&#x27;t ensure</span></span><br><span class="line">   <span class="comment">// the consistency between tx.done and the real COMMIT operation.</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">   <span class="comment">// 如果没有调用rollback以及ctx没有结束，那么会走到这</span></span><br><span class="line">   <span class="keyword">case</span> &lt;-tx.ctx.Done():</span><br><span class="line">      <span class="keyword">if</span> atomic.LoadInt32(&amp;tx.done) == <span class="number">1</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> ErrTxDone</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> tx.ctx.Err()</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 原子操作,0-&gt;1,rollback时也会做这个操作，确保只执行一次</span></span><br><span class="line">   <span class="keyword">if</span> !atomic.CompareAndSwapInt32(&amp;tx.done, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> ErrTxDone</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Cancel the Tx to release any active R-closemu locks.</span></span><br><span class="line">   <span class="comment">// This is safe to do because tx.done has already transitioned</span></span><br><span class="line">   <span class="comment">// from 0 to 1. Hold the W-closemu lock prior to rollback</span></span><br><span class="line">   <span class="comment">// to ensure no other connection has an active query.</span></span><br><span class="line">   tx.cancel() <span class="comment">// 执行cancel方法，结束开始事务时开启的goroutine</span></span><br><span class="line">   tx.closemu.Lock()</span><br><span class="line">   tx.closemu.Unlock()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> err error</span><br><span class="line">   <span class="comment">// 通过驱动建立的连接执行commit方法</span></span><br><span class="line">   withLock(tx.dc, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      err = tx.txi.Commit()</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="keyword">if</span> !errors.Is(err, driver.ErrBadConn) &#123;</span><br><span class="line">      tx.closePrepared()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 释放连接 inUse=false</span></span><br><span class="line">   tx.<span class="built_in">close</span>(err)</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Rollback"><a href="#Rollback" class="headerlink" title="Rollback"></a>Rollback</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Rollback aborts the transaction.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">Rollback</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> tx.rollback(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// rollback aborts the transaction and optionally forces the pool to discard</span></span><br><span class="line"><span class="comment">// the connection.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span> <span class="title">rollback</span><span class="params">(discardConn <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// 原子操作 确保只执行一次</span></span><br><span class="line"><span class="keyword">if</span> !atomic.CompareAndSwapInt32(&amp;tx.done, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> ErrTxDone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rollbackHook != <span class="literal">nil</span> &#123;</span><br><span class="line">rollbackHook()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cancel the Tx to release any active R-closemu locks.</span></span><br><span class="line"><span class="comment">// This is safe to do because tx.done has already transitioned</span></span><br><span class="line"><span class="comment">// from 0 to 1. Hold the W-closemu lock prior to rollback</span></span><br><span class="line"><span class="comment">// to ensure no other connection has an active query.</span></span><br><span class="line">tx.cancel()</span><br><span class="line">tx.closemu.Lock()</span><br><span class="line">tx.closemu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">  <span class="comment">// 通过驱动建立的连接执行rollback方法</span></span><br><span class="line">withLock(tx.dc, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">err = tx.txi.Rollback()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> !errors.Is(err, driver.ErrBadConn) &#123;</span><br><span class="line">tx.closePrepared()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> discardConn &#123;</span><br><span class="line">err = driver.ErrBadConn</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 释放连接</span></span><br><span class="line">tx.<span class="built_in">close</span>(err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>事务是基于连接的，连接只能被一方使用，在释放之前，无法得到。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Sql源码浅析&quot;&gt;&lt;a href=&quot;#Sql源码浅析&quot; class=&quot;headerlink&quot; title=&quot;Sql源码浅析&quot;&gt;&lt;/a&gt;Sql源码浅析&lt;/h2&gt;&lt;h3 id=&quot;Connect&quot;&gt;&lt;a href=&quot;#Connect&quot; class=&quot;headerlink&quot; title=&quot;Connect&quot;&gt;&lt;/a&gt;Connect&lt;/h3&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Open&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(driverName, dataSourceName &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(*DB, error)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 查找已注册的驱动 由_ &amp;quot;github.com/go-sql-driver/mysql&amp;quot;提供&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 驱动是真正和数据库打交道的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  driversMu.RLock()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	driveri, ok := drivers[driverName]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	driversMu.RUnlock()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; !ok &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;, fmt.Errorf(&lt;span class=&quot;string&quot;&gt;&amp;quot;sql: unknown driver %q (forgotten import?)&amp;quot;&lt;/span&gt;, driverName)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; driverCtx, ok := driveri.(driver.DriverContext); ok &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 获取连接器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		connector, err := driverCtx.OpenConnector(dataSourceName)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;, err&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; OpenDB(connector), &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; OpenDB(dsnConnector&amp;#123;dsn: dataSourceName, driver: driveri&amp;#125;), &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// OpenDB may just validate its arguments without creating a connection&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// to the database. To verify that the data source name is valid, call&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Ping.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;OpenDB&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(c driver.Connector)&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;DB&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 初始化数据，为后续维护连接池做准备&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ctx, cancel := context.WithCancel(context.Background())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	db := &amp;amp;DB&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		connector:    c,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		openerCh:     &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt;&amp;#123;&amp;#125;, connectionRequestQueueSize),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		lastPut:      &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;map&lt;/span&gt;[*driverConn]&lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		connRequests: &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;uint64&lt;/span&gt;]&lt;span class=&quot;keyword&quot;&gt;chan&lt;/span&gt; connRequest),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		stop:         cancel,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;go&lt;/span&gt; db.connectionOpener(ctx)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; db&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Runs in a separate goroutine, opens new connections when requested.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(db *DB)&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;connectionOpener&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ctx context.Context)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &amp;lt;-db.openerCh:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 收到创建新的连接的请求&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			db.openNewConnection(ctx)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="go-sql" scheme="https://cwww3.github.io/tags/go-sql/"/>
    
  </entry>
  
  <entry>
    <title>gorm</title>
    <link href="https://cwww3.github.io/2022/07/02/gorm/"/>
    <id>https://cwww3.github.io/2022/07/02/gorm/</id>
    <published>2022-07-02T14:51:13.000Z</published>
    <updated>2022-07-06T13:08:02.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GORM源码浅析"><a href="#GORM源码浅析" class="headerlink" title="GORM源码浅析"></a>GORM源码浅析</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gorm 连接数据库</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(dialector Dialector, opts ...Option)</span> <span class="params">(db *DB, err error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 全局配置</span></span><br><span class="line">  config := &amp;Config&#123;&#125;</span><br><span class="line">  </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载配置</span></span><br><span class="line"><span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line"><span class="keyword">if</span> opt != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> applyErr := opt.Apply(config); applyErr != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, applyErr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(opt Option)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> errr := opt.AfterInitialize(db); errr != <span class="literal">nil</span> &#123;</span><br><span class="line">err = errr</span><br><span class="line">&#125;</span><br><span class="line">&#125;(opt)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 时间精度配置 默认毫秒</span></span><br><span class="line"><span class="keyword">if</span> d, ok := dialector.(<span class="keyword">interface</span>&#123; Apply(*Config) error &#125;); ok &#123;</span><br><span class="line"><span class="keyword">if</span> err = d.Apply(config); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册query/create..等操作执行时所需要调用的函数</span></span><br><span class="line">  <span class="comment">// gorm:query -&gt; gorm:preload -&gt; gorm:after_query</span></span><br><span class="line">  <span class="comment">// 对不同版本的数据库做相应的约束配置</span></span><br><span class="line">  <span class="comment">// 调用sql.Open()初始化连接池</span></span><br><span class="line">db.callbacks = initializeCallbacks(db)</span><br><span class="line"><span class="keyword">if</span> config.Dialector != <span class="literal">nil</span> &#123;</span><br><span class="line">err = config.Dialector.Initialize(db)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// clone=1</span></span><br><span class="line">db = &amp;DB&#123;Config: config, clone: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在执行sql前后，相关的信息都会存在其中</span></span><br><span class="line">db.Statement = &amp;Statement&#123;</span><br><span class="line">DB:       db,</span><br><span class="line">ConnPool: db.ConnPool,</span><br><span class="line">Context:  context.Background(),</span><br><span class="line">Clauses:  <span class="keyword">map</span>[<span class="keyword">string</span>]clause.Clause&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 连接时，自动会进行ping操作</span></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; !config.DisableAutomaticPing &#123;</span><br><span class="line"><span class="keyword">if</span> pinger, ok := db.ConnPool.(<span class="keyword">interface</span>&#123; Ping() error &#125;); ok &#123;</span><br><span class="line">err = pinger.Ping()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">config.Logger.Error(context.Background(), <span class="string">&quot;failed to initialize database, got error %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Session create new db session 可覆盖全局配置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Session</span><span class="params">(config *Session)</span> *<span class="title">DB</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">txConfig = *db.Config</span><br><span class="line">tx       = &amp;DB&#123;</span><br><span class="line">Config:    &amp;txConfig,</span><br><span class="line">Statement: db.Statement, <span class="comment">// 直接赋值原db的statement</span></span><br><span class="line">Error:     db.Error,</span><br><span class="line">clone:     <span class="number">1</span>, <span class="comment">// clone = 1</span></span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 对全局配置进行覆盖</span></span><br><span class="line"><span class="keyword">if</span> config.CreateBatchSize &gt; <span class="number">0</span> &#123;</span><br><span class="line">tx.Config.CreateBatchSize = config.CreateBatchSize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config.SkipDefaultTransaction &#123;</span><br><span class="line">tx.Config.SkipDefaultTransaction = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config.AllowGlobalUpdate &#123;</span><br><span class="line">txConfig.AllowGlobalUpdate = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config.FullSaveAssociations &#123;</span><br><span class="line">txConfig.FullSaveAssociations = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果条件true 会对原db的statement进行深拷贝(并发安全)</span></span><br><span class="line">  <span class="comment">// 如果不进行clone,原db和新db使用的是同一个statement </span></span><br><span class="line">  <span class="comment">// 在分别执行sql后，信息都会存于同一个statement中，相互影响</span></span><br><span class="line"><span class="keyword">if</span> config.Context != <span class="literal">nil</span> || config.PrepareStmt || config.SkipHooks &#123;</span><br><span class="line">tx.Statement = tx.Statement.clone()</span><br><span class="line">tx.Statement.DB = tx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config.Context != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Statement.Context = config.Context</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> config.DisableNestedTransaction &#123;</span><br><span class="line">txConfig.DisableNestedTransaction = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// newDB=true clone=2</span></span><br><span class="line">  <span class="comment">// newDB=false clone=1</span></span><br><span class="line">  <span class="comment">// clone值的影响在getInstance()中体现</span></span><br><span class="line"><span class="keyword">if</span> !config.NewDB &#123;</span><br><span class="line">tx.clone = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config.DryRun &#123;</span><br><span class="line">tx.Config.DryRun = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config.QueryFields &#123;</span><br><span class="line">tx.Config.QueryFields = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config.Logger != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Config.Logger = config.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config.NowFunc != <span class="literal">nil</span> &#123;</span><br><span class="line">tx.Config.NowFunc = config.NowFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config.Initialized &#123;</span><br><span class="line">tx = tx.getInstance()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="getInstance"><a href="#getInstance" class="headerlink" title="getInstance"></a>getInstance</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 在执行大部分语句之前都会调用该方法 </span></span><br><span class="line"><span class="comment">// Model() Where() Order() Find() ...</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">getInstance</span><span class="params">()</span> *<span class="title">DB</span></span> &#123;</span><br><span class="line">  <span class="comment">// 根据clone的值，做相应的处理</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果db=1，会将statement清空，原先设置的条件(比如where order...)都会清除</span></span><br><span class="line">  <span class="comment">// 如果db=2, 会将statement进行深拷贝，原先的条件保留，但是新老db互不影响()</span></span><br><span class="line">  <span class="comment">// 如果clone=0，直接返回，不做任何操作</span></span><br><span class="line">  <span class="comment">// 做一些build(拼接)操作，比如执行Where(),Order()等操作时，直接使用原db即可，不需要对statement进行拷贝或清除</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> db.clone &gt; <span class="number">0</span> &#123;</span><br><span class="line">tx := &amp;DB&#123;Config: db.Config, Error: db.Error&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> db.clone == <span class="number">1</span> &#123;</span><br><span class="line"><span class="comment">// clone with new statement</span></span><br><span class="line">tx.Statement = &amp;Statement&#123;</span><br><span class="line">DB:       tx,</span><br><span class="line">ConnPool: db.Statement.ConnPool,</span><br><span class="line">Context:  db.Statement.Context,</span><br><span class="line">Clauses:  <span class="keyword">map</span>[<span class="keyword">string</span>]clause.Clause&#123;&#125;,</span><br><span class="line">Vars:     <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, <span class="number">8</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// with clone statement</span></span><br><span class="line">tx.Statement = db.Statement.clone()</span><br><span class="line">tx.Statement.DB = tx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Tx"><a href="#Tx" class="headerlink" title="Tx"></a>Tx</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Transaction start a transaction as a block, return error will rollback, otherwise to commit.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span> <span class="title">Transaction</span><span class="params">(fc <span class="keyword">func</span>(tx *DB)</span> <span class="title">error</span>, <span class="title">opts</span> ...*<span class="title">sql</span>.<span class="title">TxOptions</span>) <span class="params">(err error)</span></span> &#123;</span><br><span class="line">panicked := <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> committer, ok := db.Statement.ConnPool.(TxCommitter); ok &amp;&amp; committer != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// nested transaction</span></span><br><span class="line">    <span class="comment">// 嵌套事务会进入该分支，原理是一个事务可以分为多个段，用户可以将事务回滚到指定的段，而不是整个事务</span></span><br><span class="line">    <span class="comment">// https://dotnettutorials.net/lesson/savepoint-in-mysql/</span></span><br><span class="line"><span class="keyword">if</span> !db.DisableNestedTransaction &#123;</span><br><span class="line">err = db.SavePoint(fmt.Sprintf(<span class="string">&quot;sp%p&quot;</span>, fc)).Error</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Make sure to rollback when panic, Block error or Commit error</span></span><br><span class="line"><span class="keyword">if</span> panicked || err != <span class="literal">nil</span> &#123;</span><br><span class="line">db.RollbackTo(fmt.Sprintf(<span class="string">&quot;sp%p&quot;</span>, fc))</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">err = fc(db.Session(&amp;Session&#123;NewDB: db.clone == <span class="number">1</span>&#125;))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 非嵌套事务 开启事务</span></span><br><span class="line">tx := db.Begin(opts...)</span><br><span class="line"><span class="keyword">if</span> tx.Error != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> tx.Error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Make sure to rollback when panic, Block error or Commit error</span></span><br><span class="line"><span class="keyword">if</span> panicked || err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// rollback 事务</span></span><br><span class="line">tx.Rollback()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err = fc(tx); err == <span class="literal">nil</span> &#123;</span><br><span class="line">panicked = <span class="literal">false</span></span><br><span class="line">      <span class="comment">// commit 事务</span></span><br><span class="line"><span class="keyword">return</span> tx.Commit().Error</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">panicked = <span class="literal">false</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="嵌套事务"><a href="#嵌套事务" class="headerlink" title="嵌套事务"></a>嵌套事务</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.Transaction(<span class="function"><span class="keyword">func</span><span class="params">(tx *gorm.DB)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  tx.Transaction(<span class="function"><span class="keyword">func</span><span class="params">(tx2 *gorm.DB)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;GORM源码浅析&quot;&gt;&lt;a href=&quot;#GORM源码浅析&quot; class=&quot;headerlink&quot; title=&quot;GORM源码浅析&quot;&gt;&lt;/a&gt;GORM源码浅析&lt;/h2&gt;&lt;h3 id=&quot;连接&quot;&gt;&lt;a href=&quot;#连接&quot; class=&quot;headerlink&quot; title=&quot;连接&quot;&gt;&lt;/a&gt;连接&lt;/h3&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// gorm 连接数据库&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Open&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(dialector Dialector, opts ...Option)&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(db *DB, err error)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 全局配置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  config := &amp;amp;Config&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 加载配置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; _, opt := &lt;span class=&quot;keyword&quot;&gt;range&lt;/span&gt; opts &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; opt != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; applyErr := opt.Apply(config); applyErr != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;, applyErr&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(opt Option)&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; errr := opt.AfterInitialize(db); errr != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					err = errr&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;(opt)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 时间精度配置 默认毫秒&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; d, ok := dialector.(&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt;&amp;#123; Apply(*Config) error &amp;#125;); ok &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err = d.Apply(config); err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 注册query/create..等操作执行时所需要调用的函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// gorm:query -&amp;gt; gorm:preload -&amp;gt; gorm:after_query&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 对不同版本的数据库做相应的约束配置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 调用sql.Open()初始化连接池&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	db.callbacks = initializeCallbacks(db)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; config.Dialector != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		err = config.Dialector.Initialize(db)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// clone=1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	db = &amp;amp;DB&amp;#123;Config: config, clone: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 在执行sql前后，相关的信息都会存在其中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	db.Statement = &amp;amp;Statement&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		DB:       db,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		ConnPool: db.ConnPool,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Context:  context.Background(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Clauses:  &lt;span class=&quot;keyword&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;]clause.Clause&amp;#123;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 连接时，自动会进行ping操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err == &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;amp;&amp;amp; !config.DisableAutomaticPing &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; pinger, ok := db.ConnPool.(&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt;&amp;#123; Ping() error &amp;#125;); ok &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			err = pinger.Ping()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		config.Logger.Error(context.Background(), &lt;span class=&quot;string&quot;&gt;&amp;quot;failed to initialize database, got error %v&amp;quot;&lt;/span&gt;, err)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Gorm" scheme="https://cwww3.github.io/tags/Gorm/"/>
    
  </entry>
  
  <entry>
    <title>mysqlbinlog</title>
    <link href="https://cwww3.github.io/2022/03/31/mysqlbinlog/"/>
    <id>https://cwww3.github.io/2022/03/31/mysqlbinlog/</id>
    <published>2022-03-31T01:19:54.000Z</published>
    <updated>2022-03-31T01:20:26.430Z</updated>
    
    <content type="html"><![CDATA[<p>查看是否开启binlog</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;log_bin&#x27;;</span><br></pre></td></tr></table></figure><p>查看binlog</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show binary logs</span><br></pre></td></tr></table></figure><span id="more"></span><p>分析binlog</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog </span><br><span class="line">-base64-output=decode-rows  -- 解码</span><br><span class="line">--no-defaults --database=db  </span><br><span class="line">--start-datetime=&#x27;2019-04-11 00:00:00&#x27; </span><br><span class="line">--stop-datetime=&#x27;2019-04-11 15:00:00&#x27;  mysql-bin.000007 </span><br><span class="line">-- 指定位置 --start-position   --stop-position</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;查看是否开启binlog&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;show variables like &amp;#x27;log_bin&amp;#x27;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;查看binlog&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;show binary logs&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="MySql" scheme="https://cwww3.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>map</title>
    <link href="https://cwww3.github.io/2022/01/06/map/"/>
    <id>https://cwww3.github.io/2022/01/06/map/</id>
    <published>2022-01-05T16:29:49.000Z</published>
    <updated>2022-09-03T18:36:37.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A header for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 元素个数，调用 len(map) 时，直接返回此值</span></span><br><span class="line">    count     <span class="keyword">int</span></span><br><span class="line">    flags     <span class="keyword">uint8</span></span><br><span class="line">    <span class="comment">// buckets 的对数</span></span><br><span class="line">    B         <span class="keyword">uint8</span></span><br><span class="line">    <span class="comment">// overflow 的 bucket 近似数</span></span><br><span class="line">    noverflow <span class="keyword">uint16</span></span><br><span class="line">    <span class="comment">// 计算 key 的哈希的时候会传入哈希函数</span></span><br><span class="line">    hash0     <span class="keyword">uint32</span></span><br><span class="line">    <span class="comment">// 指向 buckets 数组，大小为 2^B</span></span><br><span class="line">    <span class="comment">// 如果元素个数为0，就为 nil</span></span><br><span class="line">    buckets    unsafe.Pointer</span><br><span class="line">    <span class="comment">// 扩容的时候，buckets 长度会是 oldbuckets 的两倍</span></span><br><span class="line">    oldbuckets unsafe.Pointer</span><br><span class="line">    <span class="comment">// 指示扩容进度，小于此地址的 buckets 迁移完成</span></span><br><span class="line">    nevacuate  <span class="keyword">uintptr</span></span><br><span class="line">    extra *mapextra <span class="comment">// optional fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>buckets 是一个指针，最终它指向的是一个结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">tophash [bucketCnt]<span class="keyword">uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译期间会给它加料，动态地创建一个新的结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="keyword">uint8</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype</span><br><span class="line">    values   [<span class="number">8</span>]valuetype</span><br><span class="line">    pad      <span class="keyword">uintptr</span></span><br><span class="line">    overflow <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bmap</code> 就是我们常说的“桶”，桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是“一类”的(低位一样)。在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（一个桶内最多有 8 个位置）。</p><p><img src="https://raw.githubusercontent.com/cwww3/picture/master/pic/image-20220104233340464.png" alt="image-20220104233340464"></p><p>bmap 是存放 k-v 的地方，我们把视角拉近，仔细看 bmap 的内部组成。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/pic/image-20220104233831611.png" alt="image-20220104233831611" style="zoom:50%;" /><p>上图就是 bucket 的内存模型，<code>HOB Hash</code> 指的就是 top hash。 注意到 key 和 value 是各自放在一起的，并不是 <code>key/value/key/value/...</code> 这样的形式。这样的好处是在某些情况下可以省略掉 padding 字段，节省内存空间。</p><h3 id="创建-map"><a href="#创建-map" class="headerlink" title="创建 map"></a>创建 map</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="keyword">int64</span>, h *hmap, bucket unsafe.Pointer)</span> *<span class="title">hmap</span></span> &#123;</span><br><span class="line">    <span class="comment">// 省略各种条件检查...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到一个 B，使得 map 的装载因子在正常范围内</span></span><br><span class="line">    B := <span class="keyword">uint8</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> ; overLoadFactor(hint, B); B++ &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 hash table</span></span><br><span class="line">    <span class="comment">// 如果 B 等于 0，那么 buckets 就会在赋值的时候再分配</span></span><br><span class="line">    <span class="comment">// 如果长度比较大，分配内存会花费长一点</span></span><br><span class="line">    buckets := bucket</span><br><span class="line">    <span class="keyword">var</span> extra *mapextra</span><br><span class="line">    <span class="keyword">if</span> B != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> nextOverflow *bmap</span><br><span class="line">        buckets, nextOverflow = makeBucketArray(t, B)</span><br><span class="line">        <span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">            extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">            extra.nextOverflow = nextOverflow</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 hamp</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">        h = (*hmap)(newobject(t.hmap))</span><br><span class="line">    &#125;</span><br><span class="line">    h.count = <span class="number">0</span></span><br><span class="line">    h.B = B</span><br><span class="line">    h.extra = extra</span><br><span class="line">    h.flags = <span class="number">0</span></span><br><span class="line">    h.hash0 = fastrand()</span><br><span class="line">    h.buckets = buckets</span><br><span class="line">    h.oldbuckets = <span class="literal">nil</span></span><br><span class="line">    h.nevacuate = <span class="number">0</span></span><br><span class="line">    h.noverflow = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这个函数返回的结果：<code>*hmap</code>，它是一个指针，而之前讲过的 <code>makeslice</code> 函数返回的是 <code>slice</code> 结构体</p><h3 id="key-定位过程"><a href="#key-定位过程" class="headerlink" title="key 定位过程"></a>key 定位过程</h3><p>key 经过哈希计算后得到哈希值，共 64 个 bit 位（64 位机，32 位机就不讨论了，现在主流都是 64 位机），计算它<strong>到底要落在哪个桶时，只会用到最后 B 个 bit 位</strong>。还记得前面提到过的 B 吗？如果 B = 5，那么桶的数量，也就是 buckets 数组的长度是 2^5 = 32。</p><p>例如，现在有一个 key 经过哈希函数计算后，得到的哈希结果是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10010111</span> | <span class="number">000011110110110010001111001010100010010110010101010</span> │ <span class="number">01010</span></span><br></pre></td></tr></table></figure><p>用最后的 5 个 bit 位，也就是 <code>01010</code>，值为 10，也就是 10 号桶。这个操作实际上就是取余操作，但是取余开销太大，所以代码实现上用的位操作代替。</p><p><strong>再用哈希值的高 8 位，找到此 key 在 bucket 中的位置</strong> (先找到 tophash 的位置，再通过计算得到 k,v 的位置)，这是在寻找已有的 key。最开始桶内还没有 key，新加入的 key 会找到第一个空位，放入。</p><p>buckets 编号就是桶编号，当两个不同的 key 落在同一个桶中，也就是发生了哈希冲突。冲突的解决手段是用链表法：在 bucket 中，从前往后找到第一个空位。这样，在查找某个 key 时，先找到对应的桶，再去遍历 bucket 中的 key。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/pic/image-20220104234423872.png" alt="image-20220104234423872" style="zoom:50%;" /><p>上图中，假定 B = 5，所以 bucket 总数就是 2^5 = 32。首先计算出待查找 key 的哈希，使用低 5 位 <code>00110</code>，找到对应的 6 号 bucket，使用高 8 位 <code>10010111</code>，对应十进制 151，在 6 号 bucket 中寻找 tophash 值（HOB hash）为 151 的 key，找到了 2 号槽位，这样整个查找过程就结束了。</p><p>如果在 bucket 中没找到，并且 overflow 不为空，还要继续去 overflow bucket 中寻找，直到找到或是所有的 key 槽位都找遍了，包括所有的 overflow bucket。</p><p>查找某个 key 的底层函数是 <code>mapacess</code> 系列函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 h 什么都没有，返回零值</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写和读冲突</span></span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;concurrent map read and map write&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不同类型 key 使用的 hash 算法在编译期确定</span></span><br><span class="line">    alg := t.key.alg</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算哈希值，并且加入 hash0 引入随机性</span></span><br><span class="line">    hash := alg.hash(key, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比如 B=5，那 m 就是31，二进制是全 1</span></span><br><span class="line">    <span class="comment">// 求 bucket num 时，将 hash 与 m 相与，</span></span><br><span class="line">    <span class="comment">// 达到 bucket num 由 hash 的低 8 位决定的效果</span></span><br><span class="line">    m := <span class="keyword">uintptr</span>(<span class="number">1</span>)&lt;&lt;h.B - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// b 就是 bucket 的地址</span></span><br><span class="line">    b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// oldbuckets 不为 nil，说明发生了扩容</span></span><br><span class="line">    <span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不是同 size 扩容（看后面扩容的内容）</span></span><br><span class="line">        <span class="comment">// 对应条件 1 的解决方案</span></span><br><span class="line">        <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">            <span class="comment">// 新 bucket 数量是老的 2 倍</span></span><br><span class="line">            m &gt;&gt;= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求出 key 在老的 map 中的 bucket 位置</span></span><br><span class="line">        oldb := (*bmap)(add(c, (hash&amp;m)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 oldb 没有搬迁到新的 bucket</span></span><br><span class="line">        <span class="comment">// 那就在老的 bucket 中寻找</span></span><br><span class="line">        <span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">            b = oldb</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算出高 8 位的 hash</span></span><br><span class="line">    <span class="comment">// 相当于右移 56 位，只取高8位</span></span><br><span class="line">    top := <span class="keyword">uint8</span>(hash &gt;&gt; (sys.PtrSize*<span class="number">8</span> - <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加一个 minTopHash</span></span><br><span class="line">    <span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">        top += minTopHash</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历 8 个 bucket</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">            <span class="comment">// tophash 不匹配，继续</span></span><br><span class="line">            <span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// tophash 匹配，定位到 key 的位置</span></span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset+i*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">            <span class="comment">// key 是指针</span></span><br><span class="line">            <span class="keyword">if</span> t.indirectkey &#123;</span><br><span class="line">                <span class="comment">// 解引用</span></span><br><span class="line">                k = *((*unsafe.Pointer)(k))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 key 相等</span></span><br><span class="line">            <span class="keyword">if</span> alg.equal(key, k) &#123;</span><br><span class="line">                <span class="comment">// 定位到 value 的位置</span></span><br><span class="line">                v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="keyword">uintptr</span>(t.keysize)+i*<span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">                <span class="comment">// value 解引用</span></span><br><span class="line">                <span class="keyword">if</span> t.indirectvalue &#123;</span><br><span class="line">                    v = *((*unsafe.Pointer)(v))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bucket 找完（还没找到），继续到 overflow bucket 里找</span></span><br><span class="line">        b = b.overflow(t)</span><br><span class="line">        <span class="comment">// overflow bucket 也找完了，说明没有目标 key</span></span><br><span class="line">        <span class="comment">// 返回零值</span></span><br><span class="line">        <span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b 是 bmap 的地址，这里 bmap 还是源码里定义的结构体，只包含一个 tophash 数组，经编译器扩充之后的结构体才包含 key，value，overflow 这些字段。dataOffset 是 key 相对于 bmap 起始地址的偏移：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dataOffset = unsafe.Offsetof(<span class="keyword">struct</span> &#123;</span><br><span class="line">        b bmap</span><br><span class="line">        v <span class="keyword">int64</span></span><br><span class="line">    &#125;&#123;&#125;.v)</span><br></pre></td></tr></table></figure><p>再说整个大循环的写法，最外层是一个无限循环，通过</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = b.overflow(t)</span><br></pre></td></tr></table></figure><p>遍历所有的 bucket，这相当于是一个 bucket 链表。</p><p>当定位到一个具体的 bucket 时，里层循环就是遍历这个 bucket 里所有的 cell，或者说所有的槽位，也就是 bucketCnt=8 个槽位。整个循环过程：</p><p><img src="https://raw.githubusercontent.com/cwww3/picture/master/pic/image-20220104235126819.png" alt="image-20220104235126819"></p><p>再说一下 <strong>minTopHash</strong>，当一个 cell 的 tophash 值小于 minTopHash 时，标志这个 cell 的迁移状态。因为这个状态值是放在 tophash 数组里，<strong>为了和正常的哈希值区分开，会给 key 计算出来的哈希值一个增量</strong>：minTopHash。这样就能区分正常的 top hash 值和表示状态的哈希值。（如果算出来的哈希值在 0-3 之间，那么给他加一个 minTopHash，前面 0-3 仅用来表示状态。）</p><p>下面的这几种状态就表征了 bucket 的情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空的 cell，也是初始时 bucket 的状态</span></span><br><span class="line">empty          = <span class="number">0</span></span><br><span class="line"><span class="comment">// 空的 cell，表示 cell 已经被迁移到新的 bucket</span></span><br><span class="line">evacuatedEmpty = <span class="number">1</span></span><br><span class="line"><span class="comment">// key,value 已经搬迁完毕，但是 key 都在新 bucket 前半部分，</span></span><br><span class="line"><span class="comment">// 后面扩容部分会再讲到。</span></span><br><span class="line">evacuatedX     = <span class="number">2</span></span><br><span class="line"><span class="comment">// 同上，key 在后半部分</span></span><br><span class="line">evacuatedY     = <span class="number">3</span></span><br><span class="line"><span class="comment">// tophash 的最小正常值</span></span><br><span class="line">minTopHash     = <span class="number">4</span></span><br></pre></td></tr></table></figure><p>源码里判断这个 bucket 是否已经搬迁完毕，用到的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evacuated</span><span class="params">(b *bmap)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    h := b.tophash[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> h &gt; empty &amp;&amp; h &lt; minTopHash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>底层的执行函数是 <code>mapdelete</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapdelete</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span></span><br></pre></td></tr></table></figure><p>它首先会检查 h.flags 标志，如果发现写标位是 1，直接 panic，因为这表明有其他协程同时在进行写操作。</p><p>计算 key 的哈希，找到落入的 bucket。检查此 map 如果正在扩容的过程中，直接触发一次搬迁操作。</p><p>删除操作同样是两层循环，核心还是找到 key 的具体位置。寻找过程都是类似的，在 bucket 中挨个 cell 寻找。</p><p>找到对应位置后，对 key 或者 value 进行“清零”操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对 key 清零</span></span><br><span class="line"><span class="keyword">if</span> t.indirectkey &#123;</span><br><span class="line">    *(*unsafe.Pointer)(k) = <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    typedmemclr(t.key, k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 value 清零</span></span><br><span class="line"><span class="keyword">if</span> t.indirectvalue &#123;</span><br><span class="line">    *(*unsafe.Pointer)(v) = <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    typedmemclr(t.elem, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，将 count 值减 1，将对应位置的 tophash 值置成 <code>Empty</code>。</p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>本来 map 的遍历过程比较简单：遍历所有的 bucket 以及它后面挂的 overflow bucket，然后挨个遍历 bucket 中的所有 cell。每个 bucket 中包含 8 个 cell，从有 key 的 cell 中取出 key 和 value，这个过程就完成了。</p><p>但是，现实并没有这么简单。还记得前面讲过的扩容过程吗？扩容过程不是一个原子的操作，它每次最多只搬运 2 个 bucket，所以如果触发了扩容操作，那么在很长时间里，map 的状态都是处于一个中间态：有些 bucket 已经搬迁到新家，而有些 bucket 还待在老地方。</p><p>因此，遍历如果发生在扩容的过程中，就会涉及到遍历新老 bucket 的过程，这是难点所在。</p><p>先是调用 <code>mapiterinit</code> 函数初始化迭代器，然后循环调用 <code>mapiternext</code> 函数进行 map 迭代。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/pic/image-20220105000801438.png" alt="image-20220105000801438" style="zoom:50%;" /><p>即使是对一个写死的 map 进行遍历，每次出来的结果也是无序的，近距离地观察他们的实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成随机数 r</span></span><br><span class="line">r := <span class="keyword">uintptr</span>(fastrand())</span><br><span class="line"><span class="keyword">if</span> h.B &gt; <span class="number">31</span>-bucketCntBits &#123;</span><br><span class="line">    r += <span class="keyword">uintptr</span>(fastrand()) &lt;&lt; <span class="number">31</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从哪个 bucket 开始遍历</span></span><br><span class="line">it.startBucket = r &amp; (<span class="keyword">uintptr</span>(<span class="number">1</span>)&lt;&lt;h.B - <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 从 bucket 的哪个 cell 开始遍历</span></span><br><span class="line">it.offset = <span class="keyword">uint8</span>(r &gt;&gt; h.B &amp; (bucketCnt - <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>假设我们有下图所示的一个 map，起始时 B = 1，有两个 bucket，后来触发了扩容（这里不要深究扩容条件，只是一个设定），B 变成 2。并且， 1 号 bucket 中的内容搬迁到了新的 bucket，<code>1 号</code>裂变成 <code>1 号</code>和 <code>3 号</code>；<code>0 号</code> bucket 暂未搬迁。老的 bucket 挂在在 <code>*oldbuckets</code> 指针上面，新的 bucket 则挂在 <code>*buckets</code> 指针上面。</p><p><img src="https://raw.githubusercontent.com/cwww3/picture/master/pic/image-20220105000418534.png" alt="image-20220105000418534"></p><p>这时，我们对此 map 进行遍历。假设经过初始化后，startBucket = 3，offset = 2。于是，遍历的起点将是 3 号 bucket 的 2 号 cell，下面这张图就是开始遍历时的状态：</p><p><img src="https://raw.githubusercontent.com/cwww3/picture/master/pic/image-20220105000448649.png" alt="image-20220105000448649"></p><p>标红的表示起始位置，bucket 遍历顺序为：3 -&gt; 0 -&gt; 1 -&gt; 2。因为 3 号 bucket 对应老的 1 号 bucket，因此先检查老 1 号 bucket 是否已经被搬迁过。</p><p>在本例中，老 1 号 bucket 已经被搬迁过了。所以它的 tophash[0] 值在 (0,4) 范围内，因此只用遍历新的 3 号 bucket。依次遍历 3 号 bucket 的 cell，这时候会找到第一个非空的 key：元素 e。到这里，mapiternext 函数返回，这时我们的遍历结果仅有一个元素：由于返回的 key 不为空，所以会继续调用 mapiternext 函数。继续从上次遍历到的地方往后遍历，从新 3 号 overflow bucket 中找到了元素 f 和 元素 g。</p><p>新 3 号 bucket 遍历完之后，回到了新 0 号 bucket。0 号 bucket 对应老的 0 号 bucket，经检查，老 0 号 bucket 并未搬迁，因此对新 0 号 bucket 的遍历就改为遍历老 0 号 bucket。<strong>那是不是把老 0 号 bucket 中的所有 key 都取出来呢？</strong></p><p>并没有这么简单，回忆一下，老 0 号 bucket 在搬迁后将裂变成 2 个 bucket：新 0 号、新 2 号。而我们此时正在遍历的只是新 0 号 bucket（注意，遍历都是遍历的 <code>*bucket</code> 指针，也就是所谓的新 buckets）。所以，我们<strong>只会取出老 0 号 bucket 中那些在裂变之后，分配到新 0 号 bucket 中的那些 key</strong>。</p><p>因此，<code>lowbits == 00</code> 的将进入遍历结果集：和之前的流程一样，继续遍历新 1 号 bucket，发现老 1 号 bucket 已经搬迁，只用遍历新 1 号 bucket 中现有的元素就可以了。</p><p>继续遍历新 2 号 bucket，它来自老 0 号 bucket，因此需要在老 0 号 bucket 中那些会裂变到新 2 号 bucket 中的 key，也就是 <code>lowbit == 10</code> 的那些 key。</p><p>最后，继续遍历到新 3 号 bucket 时，发现所有的 bucket 都已经遍历完毕，整个迭代过程执行完毕。</p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>使用哈希表的目的就是要快速查找到目标 key，然而，随着向 map 中添加的 key 越来越多，key 发生碰撞的概率也越来越大。bucket 中的 8 个 cell 会被逐渐塞满，查找、插入、删除 key 的效率也会越来越低。最理想的情况是一个 bucket 只装一个 key，这样，就能达到 <code>O(1)</code> 的效率，但这样空间消耗太大，用空间换时间的代价太高。</p><p>Go 语言采用一个 bucket 里装载 8 个 key，定位到某个 bucket 后，还需要再定位到具体的 key，这实际上又用了时间换空间。</p><p>当然，这样做，要有一个度，不然所有的 key 都落在了同一个 bucket 里，直接退化成了链表，各种操作的效率直接降为 O(n)，是不行的。</p><p>因此，需要有一个指标来衡量前面描述的情况，这就是<code>装载因子</code>。Go 源码里这样定义 <code>装载因子</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loadFactor := count / (<span class="number">2</span>^B)</span><br></pre></td></tr></table></figure><p>count 就是 map 的元素个数，2^B 表示 bucket 数量。</p><p>再来说触发 map 扩容的时机：在向 map 插入新 key 的时候，会进行条件检测，符合下面这 2 个条件，就会触发扩容：</p><ol><li>装载因子超过阈值，源码里定义的阈值是 6.5。</li><li>overflow 的 bucket 数量过多：当 B 小于 15，也就是 bucket 总数 2^B 小于 2^15 时，如果 overflow 的 bucket 数量超过 2^B；当 B &gt;= 15，也就是 bucket 总数 2^B 大于等于 2^15，如果 overflow 的 bucket 数量超过 2^15。</li></ol><p>通过汇编语言可以找到赋值操作对应源码中的函数是 <code>mapassign</code>，对应扩容条件的源码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/hashmap.go/mapassign</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发扩容时机</span></span><br><span class="line"><span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(<span class="keyword">int64</span>(h.count), h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">        hashGrow(t, h)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装载因子超过 6.5</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overLoadFactor</span><span class="params">(count <span class="keyword">int64</span>, B <span class="keyword">uint8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> count &gt;= bucketCnt &amp;&amp; <span class="keyword">float32</span>(count) &gt;= loadFactor*<span class="keyword">float32</span>((<span class="keyword">uint64</span>(<span class="number">1</span>)&lt;&lt;B))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// overflow buckets 太多</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tooManyOverflowBuckets</span><span class="params">(noverflow <span class="keyword">uint16</span>, B <span class="keyword">uint8</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> B &lt; <span class="number">16</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> noverflow &gt;= <span class="keyword">uint16</span>(<span class="number">1</span>)&lt;&lt;B</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> noverflow &gt;= <span class="number">1</span>&lt;&lt;<span class="number">15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 1 点：我们知道，每个 bucket 有 8 个空位，在没有溢出，且所有的桶都装满了的情况下，装载因子算出来的结果是 8。因此当装载因子超过 6.5 时，表明很多 bucket 都快要装满了，查找效率和插入效率都变低了。在这个时候进行扩容是有必要的。</p><p>第 2 点：是对第 1 点的补充。就是说在装载因子比较小的情况下，这时候 map 的查找和插入效率也很低，而第 1 点识别不出来这种情况。表面现象就是计算装载因子的分子比较小，即 map 里元素总数少，但是 bucket 数量多（真实分配的 bucket 数量多，包括大量的 overflow bucket）。</p><p>不难想像造成这种情况的原因：不停地插入、删除元素。先插入很多元素，导致创建了很多 bucket，但是装载因子达不到第 1 点的临界值，未触发扩容来缓解这种情况。之后，删除元素降低元素总数量，再插入很多元素，导致创建很多的 overflow bucket，但就是不会触犯第 1 点的规定，你能拿我怎么办？overflow bucket 数量太多，导致 key 会很分散，查找插入效率低得吓人，因此出台第 2 点规定。这就像是一座空城，房子很多，但是住户很少，都分散了，找起人来很困难。</p><p><strong>对于命中条件 1，2 的限制，都会发生扩容。但是扩容的策略并不相同，毕竟两种条件应对的场景不同。</strong></p><p>对于条件 1，元素太多，而 bucket 数量太少，很简单：将 B 加 1，bucket 最大数量（2^B）直接变成原来 bucket 数量的 2 倍。于是，就有新老 bucket 了。注意，这时候元素都在老 bucket 里，还没迁移到新的 bucket 来。而且，新 bucket 只是最大数量变为原来最大数量（2^B）的 2 倍（2^B * 2）。</p><p>对于条件 2，其实元素没那么多，但是 overflow bucket 数特别多，说明很多 bucket 都没装满。解决办法就是开辟一个新 bucket 空间，将老 bucket 中的元素移动到新 bucket，使得同一个 bucket 中的 key 排列地更紧密。这样，原来，在 overflow bucket 中的 key 可以移动到 bucket 中来。结果是节省空间，提高 bucket 利用率，map 的查找和插入效率自然就会提升。</p><p>对于条件 2 的解决方案，还有一个极端的情况：如果插入 map 的 key 哈希都一样，就会落到同一个 bucket 里，超过 8 个就会产生 overflow bucket，结果也会造成 overflow bucket 数过多。移动元素其实解决不了问题，因为这时整个哈希表已经退化成了一个链表，操作效率变成了 <code>O(n)</code>。</p><p>再来看一下扩容具体是怎么做的。由于 map 扩容需要将原有的 key/value 重新搬迁到新的内存地址，如果有大量的 key/value 需要搬迁，会非常影响性能。因此 Go map 的扩容采取了一种称为“渐进式”的方式，原有的 key 并不会一次性搬迁完毕，每次最多只会搬迁 2 个 bucket。</p><p>上面说的 <code>hashGrow()</code> 函数实际上<strong>并没有真正地“搬迁”</strong>，它只是分配好了新的 buckets，并将老的 buckets 挂到了 oldbuckets 字段上。<strong>真正搬迁</strong> buckets 的动作在 <code>growWork()</code> 函数中，而调用 <code>growWork()</code> 函数的动作是在 mapassign 和 mapdelete 函数中。<strong>也就是插入或修改、删除 key 的时候，都会尝试进行搬迁 buckets 的工作</strong>。先检查 oldbuckets 是否搬迁完毕，具体来说就是检查 oldbuckets 是否为 nil。</p><p>我们先看 <code>hashGrow()</code> 函数所做的工作，再来看具体的搬迁 buckets 是如何进行的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashGrow</span><span class="params">(t *maptype, h *hmap)</span></span> &#123;</span><br><span class="line">    <span class="comment">// B+1 相当于是原来 2 倍的空间</span></span><br><span class="line">    bigger := <span class="keyword">uint8</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应条件 2</span></span><br><span class="line">    <span class="keyword">if</span> !overLoadFactor(<span class="keyword">int64</span>(h.count), h.B) &#123;</span><br><span class="line">        <span class="comment">// 进行等量的内存扩容，所以 B 不变</span></span><br><span class="line">        bigger = <span class="number">0</span></span><br><span class="line">        h.flags |= sameSizeGrow</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将老 buckets 挂到 buckets 上</span></span><br><span class="line">    oldbuckets := h.buckets</span><br><span class="line">    <span class="comment">// 申请新的 buckets 空间</span></span><br><span class="line">    newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger)</span><br><span class="line"></span><br><span class="line">    flags := h.flags &amp;^ (iterator | oldIterator)</span><br><span class="line">    <span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &#123;</span><br><span class="line">        flags |= oldIterator</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 提交 grow 的动作</span></span><br><span class="line">    h.B += bigger</span><br><span class="line">    h.flags = flags</span><br><span class="line">    h.oldbuckets = oldbuckets</span><br><span class="line">    h.buckets = newbuckets</span><br><span class="line">    <span class="comment">// 搬迁进度为 0</span></span><br><span class="line">    h.nevacuate = <span class="number">0</span></span><br><span class="line">    <span class="comment">// overflow buckets 数为 0</span></span><br><span class="line">    h.noverflow = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运算符：&amp;^。这叫<code>按位置 0</code>运算符</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">01010011</span></span><br><span class="line">y = <span class="number">01010100</span></span><br><span class="line">z = x &amp;^ y = <span class="number">00000011</span></span><br></pre></td></tr></table></figure><p>如果 y bit 位为 1，那么结果 z 对应 bit 位就为 0，否则 z 对应 bit 位就和 x 对应 bit 位的值相同。</p><p>几个标志位如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能有迭代器使用 buckets</span></span><br><span class="line">iterator     = <span class="number">1</span></span><br><span class="line"><span class="comment">// 可能有迭代器使用 oldbuckets</span></span><br><span class="line">oldIterator  = <span class="number">2</span></span><br><span class="line"><span class="comment">// 有协程正在向 map 中写入 key</span></span><br><span class="line">hashWriting  = <span class="number">4</span></span><br><span class="line"><span class="comment">// 等量扩容（对应条件 2）</span></span><br><span class="line">sameSizeGrow = <span class="number">8</span></span><br></pre></td></tr></table></figure><p>再来看看真正执行搬迁工作的 growWork() 函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growWork</span><span class="params">(t *maptype, h *hmap, bucket <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 确认搬迁老的 bucket 对应正在使用的 bucket</span></span><br><span class="line">    evacuate(t, h, bucket&amp;h.oldbucketmask())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再搬迁一个 bucket，以加快搬迁进程</span></span><br><span class="line">    <span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">        evacuate(t, h, h.nevacuate)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hmap)</span> <span class="title">growing</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h.oldbuckets != <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bucket&amp;h.oldbucketmask()</code> 这行代码，如源码注释里说的，是为了确认搬迁的 bucket 是我们正在使用的 bucket。</p><p>接下来，我们集中所有的精力在搬迁的关键函数 evacuate。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evacuate</span><span class="params">(t *maptype, h *hmap, oldbucket <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定位老的 bucket 地址</span></span><br><span class="line">    b := (*bmap)(add(h.oldbuckets, oldbucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">    <span class="comment">// 结果是 2^B，如 B = 5，结果为32</span></span><br><span class="line">    newbit := h.noldbuckets()</span><br><span class="line">    <span class="comment">// key 的哈希函数</span></span><br><span class="line">    alg := t.key.alg</span><br><span class="line">    <span class="comment">// 如果 b 没有被搬迁过</span></span><br><span class="line">    <span class="keyword">if</span> !evacuated(b) &#123;</span><br><span class="line">        <span class="keyword">var</span> (</span><br><span class="line">            <span class="comment">// 表示bucket 移动的目标地址</span></span><br><span class="line">            x, y   *bmap</span><br><span class="line">            <span class="comment">// 指向 x,y 中的 key/val</span></span><br><span class="line">            xi, yi <span class="keyword">int</span></span><br><span class="line">            <span class="comment">// 指向 x，y 中的 key</span></span><br><span class="line">            xk, yk unsafe.Pointer</span><br><span class="line">            <span class="comment">// 指向 x，y 中的 value</span></span><br><span class="line">            xv, yv unsafe.Pointer</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// 默认是等 size 扩容，前后 bucket 序号不变</span></span><br><span class="line">        <span class="comment">// 使用 x 来进行搬迁</span></span><br><span class="line">        x = (*bmap)(add(h.buckets, oldbucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">        xi = <span class="number">0</span></span><br><span class="line">        xk = add(unsafe.Pointer(x), dataOffset)</span><br><span class="line">        xv = add(xk, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))、</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不是等 size 扩容，前后 bucket 序号有变</span></span><br><span class="line">        <span class="comment">// 使用 y 来进行搬迁</span></span><br><span class="line">        <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">            <span class="comment">// y 代表的 bucket 序号增加了 2^B</span></span><br><span class="line">            y = (*bmap)(add(h.buckets, (oldbucket+newbit)*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">            yi = <span class="number">0</span></span><br><span class="line">            yk = add(unsafe.Pointer(y), dataOffset)</span><br><span class="line">            yv = add(yk, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有的 bucket，包括 overflow buckets</span></span><br><span class="line">        <span class="comment">// b 是老的 bucket 地址</span></span><br><span class="line">        <span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">            k := add(unsafe.Pointer(b), dataOffset)</span><br><span class="line">            v := add(k, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历 bucket 中的所有 cell</span></span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; bucketCnt; i, k, v = i+<span class="number">1</span>, add(k, <span class="keyword">uintptr</span>(t.keysize)), add(v, <span class="keyword">uintptr</span>(t.valuesize)) &#123;</span><br><span class="line">                <span class="comment">// 当前 cell 的 top hash 值</span></span><br><span class="line">                top := b.tophash[i]</span><br><span class="line">                <span class="comment">// 如果 cell 为空，即没有 key</span></span><br><span class="line">                <span class="keyword">if</span> top == empty &#123;</span><br><span class="line">                    <span class="comment">// 那就标志它被&quot;搬迁&quot;过</span></span><br><span class="line">                    b.tophash[i] = evacuatedEmpty</span><br><span class="line">                    <span class="comment">// 继续下个 cell</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 正常不会出现这种情况</span></span><br><span class="line">                <span class="comment">// 未被搬迁的 cell 只可能是 empty 或是</span></span><br><span class="line">                <span class="comment">// 正常的 top hash（大于 minTopHash）</span></span><br><span class="line">                <span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">                    throw(<span class="string">&quot;bad map state&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                k2 := k</span><br><span class="line">                <span class="comment">// 如果 key 是指针，则解引用</span></span><br><span class="line">                <span class="keyword">if</span> t.indirectkey &#123;</span><br><span class="line">                    k2 = *((*unsafe.Pointer)(k2))</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 默认使用 X，等量扩容</span></span><br><span class="line">                useX := <span class="literal">true</span></span><br><span class="line">                <span class="comment">// 如果不是等量扩容</span></span><br><span class="line">                <span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">                    <span class="comment">// 计算 hash 值，和 key 第一次写入时一样</span></span><br><span class="line">                    hash := alg.hash(k2, <span class="keyword">uintptr</span>(h.hash0))</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果有协程正在遍历 map</span></span><br><span class="line">                    <span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果出现 相同的 key 值，算出来的 hash 值不同</span></span><br><span class="line">                        <span class="keyword">if</span> !t.reflexivekey &amp;&amp; !alg.equal(k2, k2) &#123;</span><br><span class="line">                            <span class="comment">// 只有在 float 变量的 NaN() 情况下会出现</span></span><br><span class="line">                            <span class="keyword">if</span> top&amp;<span class="number">1</span> != <span class="number">0</span> &#123;</span><br><span class="line">                                <span class="comment">// 第 B 位置 1</span></span><br><span class="line">                                hash |= newbit</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// 第 B 位置 0</span></span><br><span class="line">                                hash &amp;^= newbit</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 取高 8 位作为 top hash 值</span></span><br><span class="line">                            top = <span class="keyword">uint8</span>(hash &gt;&gt; (sys.PtrSize*<span class="number">8</span> - <span class="number">8</span>))</span><br><span class="line">                            <span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">                                top += minTopHash</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 取决于新哈希值的 oldB+1 位是 0 还是 1</span></span><br><span class="line">                    <span class="comment">// 详细看后面的文章</span></span><br><span class="line">                    useX = hash&amp;newbit == <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果 key 搬到 X 部分</span></span><br><span class="line">                <span class="keyword">if</span> useX &#123;</span><br><span class="line">                    <span class="comment">// 标志老的 cell 的 top hash 值，表示搬移到 X 部分</span></span><br><span class="line">                    b.tophash[i] = evacuatedX</span><br><span class="line">                    <span class="comment">// 如果 xi 等于 8，说明要溢出了</span></span><br><span class="line">                    <span class="keyword">if</span> xi == bucketCnt &#123;</span><br><span class="line">                        <span class="comment">// 新建一个 bucket</span></span><br><span class="line">                        newx := h.newoverflow(t, x)</span><br><span class="line">                        x = newx</span><br><span class="line">                        <span class="comment">// xi 从 0 开始计数</span></span><br><span class="line">                        xi = <span class="number">0</span></span><br><span class="line">                        <span class="comment">// xk 表示 key 要移动到的位置</span></span><br><span class="line">                        xk = add(unsafe.Pointer(x), dataOffset)</span><br><span class="line">                        <span class="comment">// xv 表示 value 要移动到的位置</span></span><br><span class="line">                        xv = add(xk, bucketCnt*<span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 设置 top hash 值</span></span><br><span class="line">                    x.tophash[xi] = top</span><br><span class="line">                    <span class="comment">// key 是指针</span></span><br><span class="line">                    <span class="keyword">if</span> t.indirectkey &#123;</span><br><span class="line">                        <span class="comment">// 将原 key（是指针）复制到新位置</span></span><br><span class="line">                        *(*unsafe.Pointer)(xk) = k2 <span class="comment">// copy pointer</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 将原 key（是值）复制到新位置</span></span><br><span class="line">                        typedmemmove(t.key, xk, k) <span class="comment">// copy value</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// value 是指针，操作同 key</span></span><br><span class="line">                    <span class="keyword">if</span> t.indirectvalue &#123;</span><br><span class="line">                        *(*unsafe.Pointer)(xv) = *(*unsafe.Pointer)(v)</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        typedmemmove(t.elem, xv, v)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 定位到下一个 cell</span></span><br><span class="line">                    xi++</span><br><span class="line">                    xk = add(xk, <span class="keyword">uintptr</span>(t.keysize))</span><br><span class="line">                    xv = add(xv, <span class="keyword">uintptr</span>(t.valuesize))</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// key 搬到 Y 部分，操作同 X 部分</span></span><br><span class="line">                    <span class="comment">// ……</span></span><br><span class="line">                    <span class="comment">// 省略了这部分，操作和 X 部分相同</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有协程在使用老的 buckets，就把老 buckets 清除掉，帮助gc</span></span><br><span class="line">        <span class="keyword">if</span> h.flags&amp;oldIterator == <span class="number">0</span> &#123;</span><br><span class="line">            b = (*bmap)(add(h.oldbuckets, oldbucket*<span class="keyword">uintptr</span>(t.bucketsize)))</span><br><span class="line">            <span class="comment">// 只清除bucket 的 key,value 部分，保留 top hash 部分，指示搬迁状态</span></span><br><span class="line">            <span class="keyword">if</span> t.bucket.kind&amp;kindNoPointers == <span class="number">0</span> &#123;</span><br><span class="line">                memclrHasPointers(add(unsafe.Pointer(b), dataOffset), <span class="keyword">uintptr</span>(t.bucketsize)-dataOffset)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                memclrNoHeapPointers(add(unsafe.Pointer(b), dataOffset), <span class="keyword">uintptr</span>(t.bucketsize)-dataOffset)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新搬迁进度</span></span><br><span class="line">    <span class="comment">// 如果此次搬迁的 bucket 等于当前进度</span></span><br><span class="line">    <span class="keyword">if</span> oldbucket == h.nevacuate &#123;</span><br><span class="line">        <span class="comment">// 进度加 1</span></span><br><span class="line">        h.nevacuate = oldbucket + <span class="number">1</span></span><br><span class="line">        <span class="comment">// Experiments suggest that 1024 is overkill by at least an order of magnitude.</span></span><br><span class="line">        <span class="comment">// Put it in there as a safeguard anyway, to ensure O(1) behavior.</span></span><br><span class="line">        <span class="comment">// 尝试往后看 1024 个 bucket</span></span><br><span class="line">        stop := h.nevacuate + <span class="number">1024</span></span><br><span class="line">        <span class="keyword">if</span> stop &gt; newbit &#123;</span><br><span class="line">            stop = newbit</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 寻找没有搬迁的 bucket</span></span><br><span class="line">        <span class="keyword">for</span> h.nevacuate != stop &amp;&amp; bucketEvacuated(t, h, h.nevacuate) &#123;</span><br><span class="line">            h.nevacuate++</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在 h.nevacuate 之前的 bucket 都被搬迁完毕</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有的 buckets 搬迁完毕</span></span><br><span class="line">        <span class="keyword">if</span> h.nevacuate == newbit &#123;</span><br><span class="line">            <span class="comment">// 清除老的 buckets</span></span><br><span class="line">            h.oldbuckets = <span class="literal">nil</span></span><br><span class="line">            <span class="comment">// 清除老的 overflow bucket</span></span><br><span class="line">            <span class="comment">// 回忆一下：[0] 表示当前 overflow bucket</span></span><br><span class="line">            <span class="comment">// [1] 表示 old overflow bucket</span></span><br><span class="line">            <span class="keyword">if</span> h.extra != <span class="literal">nil</span> &#123;</span><br><span class="line">                h.extra.overflow[<span class="number">1</span>] = <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 清除正在扩容的标志位</span></span><br><span class="line">            h.flags &amp;^= sameSizeGrow</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>evacuate 函数的代码注释非常清晰，对着代码和注释是很容易看懂整个的搬迁过程的，耐心点。</p><p>搬迁的目的就是将老的 buckets 搬迁到新的 buckets。而通过前面的说明我们知道，应对条件 1，新的 buckets 数量是之前的一倍，应对条件 2，新的 buckets 数量和之前相等。</p><p>对于条件 2，从老的 buckets 搬迁到新的 buckets，由于 bucktes 数量不变，因此可以按序号来搬，比如原来在 0 号 bucktes，到新的地方后，仍然放在 0 号 buckets。</p><p>对于条件 1，就没这么简单了。要重新计算 key 的哈希，才能决定它到底落在哪个 bucket。例如，原来 B = 5，计算出 key 的哈希后，只用看它的低 5 位，就能决定它落在哪个 bucket。扩容后，B 变成了 6，因此需要多看一位，它的低 6 位决定 key 落在哪个 bucket。这称为 <code>rehash</code>。</p><p><img src="../../Library/Application%20Support/typora-user-images/image-20220104232034372.png" alt="image-20220104232034372"></p><p>因此，某个 key 在搬迁前后 bucket 序号可能和原来相等，也可能是相比原来加上 2^B（原来的 B 值），取决于 hash 值 第 6 bit 位是 0 还是 1。</p><p>再明确一个问题：如果扩容后，B 增加了 1，意味着 buckets 总数是原来的 2 倍，原来 1 号的桶“裂变”到两个桶。</p><p>例如，原始 B = 2，1 号 bucket 中有 2 个 key 的哈希值低 3 位分别为：010，110。由于原来 B = 2，所以低 2 位 <code>10</code> 决定它们落在 2 号桶，现在 B 变成 3，所以 <code>010</code>、<code>110</code> 分别落入 2、6 号桶。</p><p><img src="https://raw.githubusercontent.com/cwww3/picture/master/pic/image-20220104232110233.png" alt="image-20220104232110233"></p><p>关键点:</p><p>evacuate 函数每次只完成一个 bucket 的搬迁工作，因此要遍历完此 bucket 的所有的 cell，将有值的 cell copy 到新的地方。bucket 还会链接 overflow bucket，它们同样需要搬迁。因此会有 2 层循环，外层遍历 bucket 和 overflow bucket，内层遍历 bucket 的所有 cell。这样的循环在 map 的源码里到处都是，要理解透了。</p><p>源码里提到 X, Y part，其实就是我们说的如果是扩容到原来的 2 倍，桶的数量是原来的 2 倍，前一半桶被称为 X part，后一半桶被称为 Y part。一个 bucket 中的 key 可能会分裂落到 2 个桶，一个位于 X part，一个位于 Y part。所以在搬迁一个 cell 之前，需要知道这个 cell 中的 key 是落到哪个 Part。很简单，重新计算 cell 中 key 的 hash，并向前“多看”一位，决定落入哪个 Part，这个前面也说得很详细了。</p><p>有一个特殊情况是：有一种 key，每次对它计算 hash，得到的结果都不一样。这个 key 就是 <code>math.NaN()</code> 的结果，它的含义是 <code>not a number</code>，类型是 float64。当它作为 map 的 key，在搬迁的时候，会遇到一个问题：再次计算它的哈希值和它当初插入 map 时的计算出来的哈希值不一样！</p><p>你可能想到了，这样带来的一个后果是，这个 key 是永远不会被 Get 操作获取的！当我使用 <code>m[math.NaN()]</code> 语句的时候，是查不出来结果的。这个 key 只有在遍历整个 map 的时候，才有机会现身。所以，可以向一个 map 插入任意数量的 <code>math.NaN()</code> 作为 key。</p><p>当搬迁碰到 <code>math.NaN()</code> 的 key 时，只通过 tophash 的最低位决定分配到 X part 还是 Y part（如果扩容后是原来 buckets 数量的 2 倍）。如果 tophash 的最低位是 0 ，分配到 X part；如果是 1 ，则分配到 Y part。</p><p>确定了要搬迁到的目标 bucket 后，搬迁操作就比较好进行了。将源 key/value 值 copy 到目的地相应的位置。</p><p>设置 key 在原始 buckets 的 tophash 为 <code>evacuatedX</code> 或是 <code>evacuatedY</code>，表示已经搬迁到了新 map 的 x part 或是 y part。新 map 的 tophash 则正常取 key 哈希值的高 8 位。</p><p>扩容前，B = 2，共有 4 个 buckets，lowbits 表示 hash 值的低位(B 为 2，都是 10,在同一个 bucket 中)。假设我们不关注其他 buckets 情况，专注在 2 号 bucket。并且假设 overflow 太多，触发了等量扩容（对应于前面的条件 2）。</p><p><img src="https://raw.githubusercontent.com/cwww3/picture/master/pic/image-20220104232812869.png" alt="image-20220104232812869"></p><p>扩容完成后，overflow bucket 消失了，key 都集中到了一个 bucket，更为紧凑了，提高了查找的效率。</p><p><img src="https://raw.githubusercontent.com/cwww3/picture/master/pic/image-20220104232911854.png" alt="image-20220104232911854"></p><p>假设触发了 2 倍的扩容，那么扩容完成后，老 buckets 中的 key 分裂到了 2 个 新的 bucket。一个在 x part，一个在 y 的 part。依据是 hash 的 lowbits。新 map 中 <code>0-3</code> 称为 x part，<code>4-7</code> 称为 y part。</p><p><img src="https://raw.githubusercontent.com/cwww3/picture/master/pic/image-20220104232940068.png" alt="image-20220104232940068"></p><p>注意，上面的两张图忽略了其他 buckets 的搬迁情况，表示所有的 bucket 都搬迁完毕后的情形。实际上，我们知道，搬迁是一个“渐进”的过程，并不会一下子就全部搬迁完毕。所以在搬迁过程中，oldbuckets 指针还会指向原来老的 []bmap，并且已经搬迁完毕的 key 的 tophash 值会是一个状态值，表示 key 的搬迁去向。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Map&quot;&gt;&lt;a href=&quot;#Map&quot; class=&quot;headerlink&quot; title=&quot;Map&quot;&gt;&lt;/a&gt;Map&lt;/h2&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// A header for a Go map.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; hmap &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 元素个数，调用 len(map) 时，直接返回此值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    count     &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    flags     &lt;span class=&quot;keyword&quot;&gt;uint8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// buckets 的对数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    B         &lt;span class=&quot;keyword&quot;&gt;uint8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// overflow 的 bucket 近似数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    noverflow &lt;span class=&quot;keyword&quot;&gt;uint16&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 计算 key 的哈希的时候会传入哈希函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    hash0     &lt;span class=&quot;keyword&quot;&gt;uint32&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 指向 buckets 数组，大小为 2^B&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果元素个数为0，就为 nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    buckets    unsafe.Pointer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 扩容的时候，buckets 长度会是 oldbuckets 的两倍&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    oldbuckets unsafe.Pointer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 指示扩容进度，小于此地址的 buckets 迁移完成&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    nevacuate  &lt;span class=&quot;keyword&quot;&gt;uintptr&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    extra *mapextra &lt;span class=&quot;comment&quot;&gt;// optional fields&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Go" scheme="https://cwww3.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>slice</title>
    <link href="https://cwww3.github.io/2021/12/31/slice/"/>
    <id>https://cwww3.github.io/2021/12/31/slice/</id>
    <published>2021-12-31T09:40:02.000Z</published>
    <updated>2021-12-31T10:00:13.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="keyword">uintptr</span></span><br><span class="line">Len  <span class="keyword">int</span></span><br><span class="line">Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">0</span>:<span class="number">3</span>] or slice[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><ul><li>Empty</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 底层数据长度为0</span></span><br><span class="line">nums := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)</span><br><span class="line">nums := []<span class="keyword">int</span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>Nil</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未分配底层数组</span></span><br><span class="line"><span class="keyword">var</span> nums []<span class="keyword">int</span></span><br></pre></td></tr></table></figure><ul><li>empty和nil都可以使用append，底层会申请内存进行扩容</li><li>字面量创建</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vstat [<span class="number">3</span>]<span class="keyword">int</span> <span class="comment">// 1.根据切片中的元素数量对底层数组的大小进行推断并创建一个数组；</span></span><br><span class="line">vstat[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// 2.将这些字面量元素存储到初始化的数组中；</span></span><br><span class="line">vstat[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">vstat[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> vauto *[<span class="number">3</span>]<span class="keyword">int</span> = <span class="built_in">new</span>([<span class="number">3</span>]<span class="keyword">int</span>) <span class="comment">// 3.创建一个同样指向 [3]int 类型的数组指针；</span></span><br><span class="line">*vauto = vstat <span class="comment">// 4.将静态存储区的数组 vstat 赋值给 vauto 指针所在的地址；</span></span><br><span class="line">slice := vauto[:] <span class="comment">//5.通过 [:] 操作获取一个底层使用 vauto 的切片；</span></span><br></pre></td></tr></table></figure><p> [:] 就是使用下标创建切片的方法，从这一点也能看出 [:] 操作是创建切片最底层的一种方法。</p><ul><li>关键字创建</li></ul><p>如果使用字面量的方式创建切片，大部分的工作都会在编译期间完成。但是当我们使用 <code>make</code> 关键字创建切片时，很多工作都需要运行时的参与；调用方必须向 <code>make</code> 函数传入切片的大小以及可选的容量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 检查<span class="built_in">len</span>是否传入，检查<span class="built_in">len</span>是否小于<span class="built_in">cap</span></span><br><span class="line"><span class="number">2.</span> 当切片发生逃逸或者非常大时，运行时需要 runtime.makeslice 在堆上初始化切片</span><br><span class="line"><span class="number">3.</span> 当前的切片不会发生逃逸并且切片非常小时，会使用与字面量相同的方式创建</span><br></pre></td></tr></table></figure><p><strong>使用 makeslice 创建切片</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">mem, overflow := math.MulUintptr(et.size, <span class="keyword">uintptr</span>(<span class="built_in">cap</span>))</span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> || <span class="built_in">len</span> &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line">mem, overflow := math.MulUintptr(et.size, <span class="keyword">uintptr</span>(<span class="built_in">len</span>))</span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> &#123;</span><br><span class="line">panicmakeslicelen()</span><br><span class="line">&#125;</span><br><span class="line">panicmakeslicecap()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mallocgc(mem, et, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算切片所需空间并在堆上申请一段连续的内存 (内存空间=切片中元素大小×切片容量)</p><p>如果发生一下情况，会崩溃</p><ul><li>内存空间的大小发生了溢出；</li><li>申请的内存大于最大可分配的内存；</li><li>传入的长度小于 0 或者长度大于容量；</li></ul><p><code>mallocgc</code> 是用于申请内存的函数，遇到了比较小的对象会直接初始化在 Go 语言调度器里面的 P 结构中，而大于 32KB 的对象会在堆上初始化。</p><h3 id="追加和扩容"><a href="#追加和扩容" class="headerlink" title="追加和扩容"></a>追加和扩容</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 当容量足够时，直接添加</span></span><br><span class="line">a = <span class="built_in">append</span>(a,<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 当容量不足时，先扩容(拷贝原先的数据),再添加 这是底层数组已经改变</span></span><br><span class="line">a = <span class="built_in">append</span>(a,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    newcap := old.<span class="built_in">cap</span></span><br><span class="line">    doublecap := newcap + newcap</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">        newcap = <span class="built_in">cap</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">            newcap = doublecap</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">                newcap += newcap / <span class="number">4</span></span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在分配内存空间之前需要先确定新的切片容量，运行时根据切片的当前容量选择不同的策略进行扩容：</p><ul><li>如果期望容量大于当前容量的两倍就会使用期望容量；</li><li>如果当前切片的长度小于 1024 就会将容量翻倍；</li><li>如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；</li></ul><p>上述代码片段仅会确定切片的<strong>大致容量</strong>，下面还需要根据切片中的元素大小<strong>对齐内存</strong>，当数组中元素所占的字节大小为 1、8 或者 2 的倍数时，运行时会使用如下所示的代码对齐内存：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> overflow <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> lenmem, newlenmem, capmem <span class="keyword">uintptr</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> et.size == <span class="number">1</span>:</span><br><span class="line">lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>)</span><br><span class="line">newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>)</span><br><span class="line">capmem = roundupsize(<span class="keyword">uintptr</span>(newcap))</span><br><span class="line">overflow = <span class="keyword">uintptr</span>(newcap) &gt; maxAlloc</span><br><span class="line">newcap = <span class="keyword">int</span>(capmem)</span><br><span class="line"><span class="keyword">case</span> et.size == sys.PtrSize:</span><br><span class="line">lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * sys.PtrSize</span><br><span class="line">newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * sys.PtrSize</span><br><span class="line">capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) * sys.PtrSize)</span><br><span class="line">overflow = <span class="keyword">uintptr</span>(newcap) &gt; maxAlloc/sys.PtrSize</span><br><span class="line">newcap = <span class="keyword">int</span>(capmem / sys.PtrSize)</span><br><span class="line"><span class="keyword">case</span> isPowerOfTwo(et.size):</span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// roundupsize函数会将待申请的内存向上取整 取整时会使用 runtime.class_to_size 数组</span></span><br><span class="line"><span class="keyword">var</span> class_to_size = [_NumSizeClasses]<span class="keyword">uint16</span>&#123;<span class="number">0</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>,<span class="number">48</span>,<span class="number">64</span>,<span class="number">80</span>,...&#125;</span><br></pre></td></tr></table></figure><p><strong>例子</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">a = a.<span class="built_in">append</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) <span class="comment">// len=5 cap=6</span></span><br><span class="line"><span class="comment">// 期望容量(5)大于原容量的两倍(2*0) 得到新容量(5) 占用内存(5*8byte) </span></span><br><span class="line"><span class="comment">// 进行内存对齐得到（48）最终容量(48/8==6)</span></span><br><span class="line"></span><br><span class="line">a = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">a = a.<span class="built_in">append</span>(<span class="number">5</span>) <span class="comment">// len=5 cap=8</span></span><br><span class="line"><span class="comment">// 期望容量(5)小于1024 (2*0) 新容量为原容量的两倍(8) 占用内存(8*8byte) </span></span><br><span class="line"><span class="comment">// 进行内存对齐得到（64）最终容量(64/8==8)</span></span><br></pre></td></tr></table></figure><h3 id="拷贝切片"><a href="#拷贝切片" class="headerlink" title="拷贝切片"></a>拷贝切片</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将src的内容拷贝到dst中  拷贝的大小取两者中的较小值</span></span><br><span class="line"><span class="built_in">copy</span>(dst, src)</span><br></pre></td></tr></table></figure><h3 id="传值和传指针"><a href="#传值和传指针" class="headerlink" title="传值和传指针"></a>传值和传指针</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAppend</span><span class="params">(s []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">// 这里 s 虽然改变了，但并不会影响外层函数的 s</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAppendPtr</span><span class="params">(s *[]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 会改变外层 s 本身</span></span><br><span class="line">*s = <span class="built_in">append</span>(*s, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">newS := myAppend(s) </span><br><span class="line"></span><br><span class="line">fmt.Println(s) <span class="comment">// 1,1,1</span></span><br><span class="line">fmt.Println(newS) <span class="comment">// 1,1,1,100</span></span><br><span class="line"></span><br><span class="line">s = newS</span><br><span class="line"></span><br><span class="line">myAppendPtr(&amp;s)</span><br><span class="line">fmt.Println(s) <span class="comment">// 1,1,1,100,1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Slice&quot;&gt;&lt;a href=&quot;#Slice&quot; class=&quot;headerlink&quot; title=&quot;Slice&quot;&gt;&lt;/a&gt;Slice&lt;/h2&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; SliceHeader &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Data &lt;span class=&quot;keyword&quot;&gt;uintptr&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Len  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Cap  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Go" scheme="https://cwww3.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>kqueue</title>
    <link href="https://cwww3.github.io/2021/12/24/kqueue/"/>
    <id>https://cwww3.github.io/2021/12/24/kqueue/</id>
    <published>2021-12-23T17:06:14.000Z</published>
    <updated>2022-09-03T18:36:37.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用-Kqueue-实现简单的-TCP-服务器"><a href="#使用-Kqueue-实现简单的-TCP-服务器" class="headerlink" title="使用 Kqueue 实现简单的 TCP 服务器"></a>使用 Kqueue 实现简单的 TCP 服务器</h2><p><a href="https://github.com/FRosner/FrSrv">项目地址</a></p><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>TCP 服务器由 TCP socket，来自客户端连接的 socket，kqueue 以及轮询 kqueue 的 event loop 组成。</p><p><img src="https://raw.githubusercontent.com/cwww3/picture/master/pic/image-20211223235715574.png" alt="image-20211223235715574"></p><span id="more"></span><p>当一个客户端想要连接服务器，连接请求会被放入 TCP 连接队列。内核会将该事件放入 kqueue，然后 event loop 轮询 kqueue 获取该事件，并创建一个新的客户端 socket。</p><p><img src="https://raw.githubusercontent.com/cwww3/picture/master/pic/image-20211224000209004.png" alt="image-20211224000209004"></p><p>当客户端写入数据，内核会将该事件放入 kqueue，然后 event loop 轮询获取该事件，获取到 socket，并从这个 socket 中读取数据。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ol><li>Create, bind, and listen on a new socket</li><li>Create new kqueue</li><li>Subscribe to socket events</li><li>Poll for new events in a loop and handle them</li></ol><p>socket 模块用于封装 socket 相关的所用功能，kqueue 模块用于封装 event loop 的所用功能。</p><p>在 main 模块中调用他们，实现 tcp 服务。</p><h4 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h4><p>用 Go 类型定义一个 Socket，需要将文件描述符进行保存。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Socket <span class="keyword">struct</span> &#123;</span><br><span class="line">  FileDescriptor <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现读 io.Reader，写 io.Writer，关闭 io.Closer 等接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(socket Socket)</span> <span class="title">Read</span><span class="params">(bytes []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(bytes) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  numBytesRead, err :=</span><br><span class="line">    syscall.Read(socket.FileDescriptor, bytes)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    numBytesRead = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> numBytesRead, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(socket Socket)</span> <span class="title">Write</span><span class="params">(bytes []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">  numBytesWritten, err :=</span><br><span class="line">    syscall.Write(socket.FileDescriptor, bytes)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    numBytesWritten = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> numBytesWritten, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(socket *Socket)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> syscall.Close(socket.FileDescriptor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(socket *Socket)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> strconv.Itoa(socket.FileDescriptor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据提供的 ip 和端口，创建并监听</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Listen</span><span class="params">(ip <span class="keyword">string</span>, port <span class="keyword">int</span>)</span> <span class="params">(*Socket, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1. 创建套接字</span></span><br><span class="line">  socket := &amp;Socket&#123;&#125;</span><br><span class="line"><span class="comment">// AF_INET 表示IPV4</span></span><br><span class="line">  <span class="comment">// SOCK_STREAM 表示有序的、可靠的、基于双向连接的字节流</span></span><br><span class="line">  <span class="comment">// 0在SOCK_STREAM套接字中表示TCP</span></span><br><span class="line">  socketFileDescriptor, err :=</span><br><span class="line">    syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to create socket (%v)&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  socket.FileDescriptor = socketFileDescriptor</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 绑定ip和端口</span></span><br><span class="line">  socketAddress := &amp;syscall.SockaddrInet4&#123;Port: port&#125;</span><br><span class="line">  <span class="built_in">copy</span>(socketAddress.Addr[:], net.ParseIP(ip))</span><br><span class="line">  <span class="keyword">if</span> err = syscall.Bind(socket.FileDescriptor, socketAddress);</span><br><span class="line">    err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to bind socket (%v)&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 开始监听,接收连接请求 SOMAXCONN设置最大等待的连接数</span></span><br><span class="line">  <span class="keyword">if</span> err = syscall.Listen(socket.FileDescriptor, syscall.SOMAXCONN);</span><br><span class="line">    err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to listen on socket (%v)&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> socket, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="kqueue"><a href="#kqueue" class="headerlink" title="kqueue"></a>kqueue</h4><p>定义一个 EventLoop 结构体</p><p>分别保存 kqueue 文件描述符以及用于监听客户端连接的套接字文件描述符</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EventLoop <span class="keyword">struct</span> &#123;</span><br><span class="line">  KqueueFileDescriptor <span class="keyword">int</span></span><br><span class="line">  SocketFileDescriptor <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个创建 EventLoop 的函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEventLoop</span><span class="params">(s *socket.Socket)</span> <span class="params">(*EventLoop, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 创建kqueue,返回对应的文件描述符</span></span><br><span class="line">  kQueue, err := syscall.Kqueue()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>,</span><br><span class="line">      fmt.Errorf(<span class="string">&quot;failed to create kqueue file descriptor (%v)&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 定义监听的事件类型以及处理方法</span></span><br><span class="line">  <span class="comment">// Ident设置创建的socket文件描述符</span></span><br><span class="line">  <span class="comment">// Filter 设置成EVFILT_READ表示对传入的连接事件感兴趣</span></span><br><span class="line">  <span class="comment">// Flags 设置相应的响应动作 EV_ADD表示添加到kqueue中，EV_ENABLE表示启用</span></span><br><span class="line">  changeEvent := syscall.Kevent_t&#123;</span><br><span class="line">    Ident:  <span class="keyword">uint64</span>(s.FileDescriptor),</span><br><span class="line">    Filter: syscall.EVFILT_READ,</span><br><span class="line">    Flags:  syscall.EV_ADD | syscall.EV_ENABLE,</span><br><span class="line">    Fflags: <span class="number">0</span>,</span><br><span class="line">    Data:   <span class="number">0</span>,</span><br><span class="line">    Udata:  <span class="literal">nil</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将定义的事件类型注册要kqueue上</span></span><br><span class="line">  changeEventRegistered, err := syscall.Kevent(</span><br><span class="line">    kQueue,</span><br><span class="line">    []syscall.Kevent_t&#123;changeEvent&#125;,</span><br><span class="line">    <span class="literal">nil</span>,</span><br><span class="line">    <span class="literal">nil</span></span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> || changeEventRegistered == <span class="number">-1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>,</span><br><span class="line">      fmt.Errorf(<span class="string">&quot;failed to register change event (%v)&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;EventLoop&#123;</span><br><span class="line">    KqueueFileDescriptor: kQueue,</span><br><span class="line">    SocketFileDescriptor: s.FileDescriptor</span><br><span class="line">  &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义函数对 kquue 轮询处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(eventLoop *EventLoop)</span> <span class="title">Handle</span><span class="params">(handler Handler)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 轮询kqueue获取事件的数量</span></span><br><span class="line">    newEvents := <span class="built_in">make</span>([]syscall.Kevent_t, <span class="number">10</span>)</span><br><span class="line">    numNewEvents, err := syscall.Kevent(</span><br><span class="line">      eventLoop.KqueueFileDescriptor,</span><br><span class="line">      <span class="literal">nil</span>,</span><br><span class="line">      newEvents,</span><br><span class="line">      <span class="literal">nil</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理每一个事件</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numNewEvents; i++ &#123;</span><br><span class="line">      currentEvent := newEvents[i]</span><br><span class="line">      eventFileDescriptor := <span class="keyword">int</span>(currentEvent.Ident)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> currentEvent.Flags&amp;syscall.EV_EOF != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 客户端关闭事件</span></span><br><span class="line">        syscall.Close(eventFileDescriptor)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> eventFileDescriptor == eventLoop.SocketFileDescriptor &#123;</span><br><span class="line">        <span class="comment">// 客户端连接事件</span></span><br><span class="line">        socketConnection, _, err :=</span><br><span class="line">          syscall.Accept(eventFileDescriptor)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 获取客户端连接请求创建对应的套接字和文件描述符</span></span><br><span class="line">        <span class="comment">// 并定义订阅读事件，注册到kqueue上</span></span><br><span class="line">        socketEvent := syscall.Kevent_t&#123;</span><br><span class="line">          Ident:  <span class="keyword">uint64</span>(socketConnection),</span><br><span class="line">          Filter: syscall.EVFILT_READ,</span><br><span class="line">          Flags:  syscall.EV_ADD,</span><br><span class="line">          Fflags: <span class="number">0</span>,</span><br><span class="line">          Data:   <span class="number">0</span>,</span><br><span class="line">          Udata:  <span class="literal">nil</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        socketEventRegistered, err := syscall.Kevent(</span><br><span class="line">          eventLoop.KqueueFileDescriptor,</span><br><span class="line">          []syscall.Kevent_t&#123;socketEvent&#125;,</span><br><span class="line">          <span class="literal">nil</span>,</span><br><span class="line">          <span class="literal">nil</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> || socketEventRegistered == <span class="number">-1</span> &#123;</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> currentEvent.Filter&amp;syscall.EVFILT_READ != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 处理已经建立连接的客户端所发来的数据</span></span><br><span class="line">        handler(&amp;socket.Socket&#123;</span><br><span class="line">          FileDescriptor: <span class="keyword">int</span>(eventFileDescriptor)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ignore all other events</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="main"><a href="#main" class="headerlink" title="main"></a>main</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  s, err := socket.Listen(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Println(<span class="string">&quot;Failed to create Socket:&quot;</span>, err)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  eventLoop, err := kqueue.NewEventLoop(s)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Println(<span class="string">&quot;Failed to create event loop:&quot;</span>, err)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  log.Println(<span class="string">&quot;Server started. Waiting for incoming connections. ^C to exit.&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义以建立连接的客户端发来数据时的处理函数</span></span><br><span class="line">  eventLoop.Handle(<span class="function"><span class="keyword">func</span><span class="params">(s *socket.Socket)</span></span> &#123;</span><br><span class="line">    reader := bufio.NewReader(s)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      line, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> || strings.TrimSpace(line) == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      s.Write([]<span class="keyword">byte</span>(line))</span><br><span class="line">    &#125;</span><br><span class="line">    s.Close()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟连接、发送数据、关闭连接</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c,err := net.Dial(<span class="string">&quot;tcp&quot;</span>,<span class="string">&quot;127.0.0.1:8080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err!= <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> c.Close()</span><br><span class="line">_,_ = c.Write([]<span class="keyword">byte</span>(<span class="string">&quot;hello world\n&quot;</span>))</span><br><span class="line">log.Println(<span class="string">&quot;send msg&quot;</span>)</span><br><span class="line">time.Sleep(time.Second*<span class="number">5</span>)</span><br><span class="line">log.Println(<span class="string">&quot;client closed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;使用-Kqueue-实现简单的-TCP-服务器&quot;&gt;&lt;a href=&quot;#使用-Kqueue-实现简单的-TCP-服务器&quot; class=&quot;headerlink&quot; title=&quot;使用 Kqueue 实现简单的 TCP 服务器&quot;&gt;&lt;/a&gt;使用 Kqueue 实现简单的 TCP 服务器&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/FRosner/FrSrv&quot;&gt;项目地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;设计&quot;&gt;&lt;a href=&quot;#设计&quot; class=&quot;headerlink&quot; title=&quot;设计&quot;&gt;&lt;/a&gt;设计&lt;/h3&gt;&lt;p&gt;TCP 服务器由 TCP socket，来自客户端连接的 socket，kqueue 以及轮询 kqueue 的 event loop 组成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/cwww3/picture/master/pic/image-20211223235715574.png&quot; alt=&quot;image-20211223235715574&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="网络" scheme="https://cwww3.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS</title>
    <link href="https://cwww3.github.io/2021/11/27/HTTPS/"/>
    <id>https://cwww3.github.io/2021/11/27/HTTPS/</id>
    <published>2021-11-27T12:52:40.000Z</published>
    <updated>2022-09-03T18:36:37.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTP 由于是明⽂传输，所以安全上存在以下三个⻛险：</p><p>窃听⻛险，⽐如通信链路上可以获取通信内容，⽤户号容易没。</p><p>篡改⻛险，⽐如强制植⼊垃圾⼴告，视觉污染，⽤户眼容易瞎。</p><p>冒充⻛险，⽐如冒充淘宝⽹站，⽤户钱容易没。</p><span id="more"></span><p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加⼊了 SSL/TLS 协议，可以很好的解决 HTTP 的安全问题。</p><ul><li><p>混合加密的⽅式实现信息的机密性，解决了窃听的⻛险。</p><p>在通信建⽴前采⽤⾮对称加密的⽅式交换「会话秘钥」，后续就不再使⽤⾮对称加密。</p><p>在通信过程中全部使⽤对称加密的「会话秘钥」的⽅式加密明⽂数据。</p><p>对称加密只使⽤⼀个密钥，运算速度快，密钥必须保密，⽆法做到安全的密钥交换。⾮对称加密使⽤两个密钥：公钥和私钥，公钥可以任意分发⽽私钥保密，解决了密钥交换问题但速度慢。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/pic/image-20211127200955709.png" alt="image-20211127200955709" style="zoom:25%;" /></li><li><p>摘要算法的⽅式来实现完整性，它能够为数据⽣成独⼀⽆⼆的「指纹」，指纹⽤于校验数据的完整性，解决了篡改的⻛险。</p><p>客户端在发送明⽂之前会通过摘要算法算出明⽂的「指纹」，发送的时候把「指纹 + 明⽂」⼀同加密成密⽂后，发送给服务器，服务器解密后，⽤相同的摘要算法算出发送过来的明⽂，通过⽐较客户端携带的「指纹」和当前算出的「指纹」做⽐较，若「指纹」相同，说明数据是完整的。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/pic/image-20211127201037389.png" alt="image-20211127201037389" style="zoom:25%;" /></li><li><p>数字证书，解决了冒充的⻛险。</p><p>客户端先向服务器端索要公钥，然后⽤公钥加密信息，服务器收到密⽂后，⽤⾃⼰的私钥解密。这就存在些问题，如何保证公钥不被篡改和信任度？所以这⾥就需要借助第三⽅权威机构 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。</p></li></ul><p>​ <img src="https://raw.githubusercontent.com/cwww3/picture/master/pic/image-20211127201414160.png" alt="image-20211127201414160" style="zoom:33%;" /></p><h3 id="SSL-TLS-协议基本流程"><a href="#SSL-TLS-协议基本流程" class="headerlink" title="SSL/TLS 协议基本流程"></a>SSL/TLS 协议基本流程</h3><p>TSL 四次握手</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/pic/image-20211127204231432.png" alt="image-20211127204231432" style="zoom:50%;" /><ul><li>ClientHello</li></ul><p>⾸先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。</p><p>在这⼀步，客户端主要向服务器发送以下信息：</p><p>（1）客户端⽀持的 SSL/TLS 协议版本，如 TLS 1.2 版本。</p><p>（2）客户端⽣产的随机数（ Client Random ），后⾯⽤于⽣产「会话秘钥」。</p><p>（3）客户端⽀持的密码套件列表，如 RSA 加密算法。</p><ul><li>ServerHello</li></ul><p>服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello 。服务器回应的内容有如下内容：</p><p>（1）确认 SSL/ TLS 协议版本，如果浏览器不⽀持，则关闭加密通信。</p><p>（2）服务器⽣产的随机数（ Server Random ），后⾯⽤于⽣产「会话秘钥」。</p><p>（3）确认的密码套件列表，如 RSA 加密算法。</p><p>（4）服务器的数字证书。</p><ul><li>客户端回应</li></ul><p>客户端收到服务器的回应之后，⾸先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使⽤它加密报⽂，向服务器发送如下信息：</p><p>（1）⼀个随机数（ pre-master key ）。该随机数会被服务器公钥加密。</p><p>（2）加密通信算法改变通知，表示随后的信息都将⽤「会话秘钥」加密通信。</p><p>（3）客户端握⼿结束通知，表示客户端的握⼿阶段已经结束。这⼀项同时把之前所有内容的发⽣的数据做个摘要，⽤来供服务端校验。上⾯第⼀项的随机数是整个握⼿阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就⽤双⽅协商的加密算法，各⾃⽣成本次通信的「会话秘钥」。</p><ul><li>服务器的最后回应</li></ul><p>服务器收到客户端的第三个随机数（ pre-master key ）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发⽣最后的信息：</p><p>（1）加密通信算法改变通知，表示随后的信息都将⽤「会话秘钥」加密通信。</p><p>（2）服务器握⼿结束通知，表示服务器的握⼿阶段已经结束。这⼀项同时把之前所有内容的发⽣的数据做个摘要，⽤来供客户端校验。</p><p>⾄此，整个 SSL/TLS 的握⼿阶段全部结束。接下来，客户端与服务器进⼊加密通信，就完全是使⽤普通的 HTTP 协议，只不过⽤「会话秘钥」加密内容。</p><p>事实上，不同的密钥交换算法，TLS 的握⼿过程可能会有⼀些区别。</p><p>这⾥先简单介绍下密钥交换算法，因为考虑到性能的问题，所以双⽅在加密应⽤信息时使⽤的是对称加密密钥，⽽对称加密密钥是不能被泄漏的，为了保证对称加密密钥的安全性，所以使⽤⾮对称加密的⽅式来保护对称加密密钥的协商，这个⼯作就是密钥交换算法负责的。接下来，我们就以最简单的 RSA 密钥交换算法，来看看它的 TLS 握⼿过程。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/pic/16380164319252.png" alt="16380164319252"  /><p><strong>RSA</strong> 算法的缺陷</p><p>使⽤ <strong>RSA</strong> 密钥协商算法的最⼤问题是不⽀持<strong>前向保密</strong>。因为客户端传递随机数（⽤于⽣成对称加密密钥的条件之⼀）给服务端时使⽤的是公钥加密的，服务端收到到后，会⽤私钥解密得到随机数。所以⼀旦服务端的私钥泄漏了，过去被第三⽅截获的所有 TLS 通讯密⽂都会被破解。</p><p>为了解决这⼀问题，于是就有了 DH 密钥协商算法，这⾥简单介绍它的⼯作流程。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/pic/image-20211127204841502.png" alt="image-20211127204841502" style="zoom:50%;" /><p>客户端和服务端各⾃会⽣成随机数，并以此作为私钥，然后根据公开的 DH 计算公示算出各⾃的公钥，通过 TLS 握⼿双⽅交换各⾃的公钥，这样双⽅都有⾃⼰的私钥和对⽅的公钥，然后双⽅根据各⾃持有的材料算出⼀个随机数，这个随机数的值双⽅都是⼀样的，这就可以作为后续对称加密时使⽤的密钥。</p><p>DH 密钥交换过程中，即使第三⽅截获了 <strong>TLS</strong> 握⼿阶段传递的公钥，在不知道的私钥的情况下，也是⽆法计算出密钥的，⽽且每⼀次对称加密密钥都是实时⽣成的，实现前向保密。但因为 DH 算法的计算效率问题，后⾯出现了 ECDHE 密钥协商算法，我们现在⼤多数⽹站使⽤的正是 ECDHE 密钥协商算法。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;HTTPS&quot;&gt;&lt;a href=&quot;#HTTPS&quot; class=&quot;headerlink&quot; title=&quot;HTTPS&quot;&gt;&lt;/a&gt;HTTPS&lt;/h2&gt;&lt;p&gt;HTTP 由于是明⽂传输，所以安全上存在以下三个⻛险：&lt;/p&gt;
&lt;p&gt;窃听⻛险，⽐如通信链路上可以获取通信内容，⽤户号容易没。&lt;/p&gt;
&lt;p&gt;篡改⻛险，⽐如强制植⼊垃圾⼴告，视觉污染，⽤户眼容易瞎。&lt;/p&gt;
&lt;p&gt;冒充⻛险，⽐如冒充淘宝⽹站，⽤户钱容易没。&lt;/p&gt;</summary>
    
    
    
    
    <category term="网络" scheme="https://cwww3.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Nginx</title>
    <link href="https://cwww3.github.io/2021/11/27/Nginx/"/>
    <id>https://cwww3.github.io/2021/11/27/Nginx/</id>
    <published>2021-11-27T10:00:07.000Z</published>
    <updated>2021-11-27T12:02:32.533Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h3 id="二进制安装"><a href="#二进制安装" class="headerlink" title="二进制安装"></a>二进制安装</h3><p><a href="http://nginx.org/en/download.html">安装地址</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压nginx压缩包并进入nginx-1.20.2</span></span><br><span class="line">tar -xf nginx-1.20.2.tar.gz &amp;&amp; cd nginx-1.20.2</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装所需软件</span></span><br><span class="line">yum install -y pcre pcre-devel  #支持nginx的正则</span><br><span class="line">yum install -y openssl openssl-devel     #加密认证</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行./configure 配置环境 生成Makefile文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> prefix指定安装的路径</span></span><br><span class="line">./configure --user=nginx --group=nginx --prefix=/etc/nginx/ --with-http_stub_status_module --with-http_ssl_module --with-pcre</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译并且安装</span> </span><br><span class="line">make&amp;&amp;make install</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置PATH路径</span> </span><br><span class="line">export PAHT=$PATH:/etc/nginx/sbin</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="Nginx命令"><a href="#Nginx命令" class="headerlink" title="Nginx命令"></a>Nginx命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示nginx的版本号和编译信息</span></span><br><span class="line">nginx -V </span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查默认配置文件 /etc/nginx/conf/nginx.conf</span></span><br><span class="line">nginx -t</span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查指定配置文件</span></span><br><span class="line">nginx -t -c xxx.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新加载配置文件</span></span><br><span class="line">nginx -s reload</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭</span></span><br><span class="line">nginx -s quit</span><br></pre></td></tr></table></figure><h3 id="添加到Systemd中管理"><a href="#添加到Systemd中管理" class="headerlink" title="添加到Systemd中管理"></a>添加到Systemd中管理</h3><ul><li>Systemctl 介绍</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看版本</span></span><br><span class="line">systemctl --version </span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有可用单元（服务）</span></span><br><span class="line">systemctl list-unit-files</span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有运行中的单元</span></span><br><span class="line">systemctl list-units</span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有失败的单元</span></span><br><span class="line">systemctl --failed</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看自启动的软件</span></span><br><span class="line">systemctl list-unit-files | grep enable</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改了配置文件后，重载配置文件</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看nginx是否开机启动</span></span><br><span class="line">systemctl is-enabled nginx.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看nginx状态</span></span><br><span class="line">systemctl status nginx.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动nginx单元</span></span><br><span class="line">systemctl start nginx.service，</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启nginx单元</span></span><br><span class="line">systemctl restart nginx.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止nginx单元</span></span><br><span class="line">systemctl stop nginx.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重载nginx配置</span></span><br><span class="line">systemctl reload nginx.service，</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置开机自启动。</span></span><br><span class="line">systemctl enable nginx.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭开机自启动</span></span><br><span class="line">systemctl disable nginx.service</span><br></pre></td></tr></table></figure><ul><li>将nginx加入管理</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在系统服务目录里创建nginx.service文件</span></span><br><span class="line">vim /usr/lib/systemd/system/nginx.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 写入</span></span><br><span class="line">[Unit] # 服务的说明</span><br><span class="line">Description=nginx # 描述服务</span><br><span class="line">After=network.target # 描述服务类别</span><br><span class="line"></span><br><span class="line">[Service] # 服务运行参数的设置</span><br><span class="line">Type=forking # 后台运行的形式</span><br><span class="line"><span class="meta">#</span><span class="bash"> [Service]的启动、重启、停止命令全部要求使用绝对路径</span></span><br><span class="line">ExecStart=/etc/nginx/sbin/nginx # 服务的具体运行命令</span><br><span class="line">ExecReload=/etc/nginx/sbin/nginx -s reload # 重启命令</span><br><span class="line">ExecStop=/etc/nginx/sbin/nginx -s quit # 停止命令</span><br><span class="line">PrivateTmp=true # PrivateTmp=True表示给服务分配独立的临时空间</span><br><span class="line"></span><br><span class="line">[Install] # [Install]运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加载配置</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动nginx</span></span><br><span class="line">systemctl start nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开机自启动nginx</span></span><br><span class="line">systemctl enable nginx</span><br></pre></td></tr></table></figure><h3 id="添加Nginx模块"><a href="#添加Nginx模块" class="headerlink" title="添加Nginx模块"></a>添加Nginx模块</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建并进入目录</span></span><br><span class="line">madir -p /data/software &amp;&amp; cd /data/software</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载</span></span><br><span class="line">git clone git@github.com:arut/nginx-rtmp-module.git</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 nginx编译信息</span></span><br><span class="line">nginx -V </span><br><span class="line"></span><br><span class="line">nginx version: nginx/1.20.2</span><br><span class="line">built by gcc 8.5.0 20210514 (Red Hat 8.5.0-4) (GCC)</span><br><span class="line">built with OpenSSL 1.1.1k  FIPS 25 Mar 2021</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --user=nginx --group=nginx --prefix=/etc/nginx/ --with-http_stub_status_module --with-http_ssl_module --with-pcre</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止nginx</span></span><br><span class="line">systemctl stop nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入nginx安装目录</span></span><br><span class="line">cd /usr/local/src/nginx-1.20.2</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行 通过 --add-module添加刚才git下载的模块</span></span><br><span class="line">./configure --user=nginx --group=nginx --prefix=/etc/nginx/ --with-http_stub_status_module --with-http_ssl_module --with-pcre --add-module=/data/software/nginx-rtmp-module</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行make</span></span><br><span class="line">make       # 不需要执行make install不然会覆盖</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 替换nginx二进制文件</span></span><br><span class="line">cp /etc/nginx/sbin/nginx /etc/nginx/sbin/nginx.bak</span><br><span class="line">rm /etc/nginx/sbin/nginx</span><br><span class="line">cp ./objs/nginx /etc/nginx/sbin/nginx</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行nginx -V 查看配置</span></span><br><span class="line">nginx version: nginx/1.20.2</span><br><span class="line">built by gcc 8.5.0 20210514 (Red Hat 8.5.0-4) (GCC)</span><br><span class="line">built with OpenSSL 1.1.1k  FIPS 25 Mar 2021</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --user=nginx --group=nginx --prefix=/etc/nginx/ --with-http_stub_status_module --with-http_ssl_module --with-pcre --add-module=/data/software/nginx-rtmp-module</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Nginx&quot;&gt;&lt;a href=&quot;#Nginx&quot; class=&quot;headerlink&quot; title=&quot;Nginx&quot;&gt;&lt;/a&gt;Nginx&lt;/h2&gt;&lt;h3 id=&quot;二进制安装&quot;&gt;&lt;a href=&quot;#二进制安装&quot; class=&quot;headerlink&quot; title=&quot;二进制安装&quot;&gt;&lt;/a&gt;二进制安装&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://nginx.org/en/download.html&quot;&gt;安装地址&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 解压nginx压缩包并进入nginx-1.20.2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tar -xf nginx-1.20.2.tar.gz &amp;amp;&amp;amp; cd nginx-1.20.2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 安装所需软件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum install -y pcre pcre-devel  #支持nginx的正则&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum install -y openssl openssl-devel     #加密认证&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 执行./configure 配置环境 生成Makefile文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; prefix指定安装的路径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;./configure --user=nginx --group=nginx --prefix=/etc/nginx/ --with-http_stub_status_module --with-http_ssl_module --with-pcre&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 编译并且安装&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;make&amp;amp;&amp;amp;make install&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 配置PATH路径&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export PAHT=$PATH:/etc/nginx/sbin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Nginx" scheme="https://cwww3.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>HTTP</title>
    <link href="https://cwww3.github.io/2021/11/27/HTTP/"/>
    <id>https://cwww3.github.io/2021/11/27/HTTP/</id>
    <published>2021-11-27T04:03:04.000Z</published>
    <updated>2022-09-03T18:36:37.819Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP （HyperText Transfer Protocol）超文本传输协议</p><p><strong>HTTP</strong> 是⼀个在计算机世界⾥专⻔在「两点」之间「传输」⽂字、图⽚、⾳频、视频等「超⽂本」数据的「约定和规范」。</p><span id="more"></span><h3 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h3><ul><li>1xx</li></ul><p>1xx 类状态码属于提示信息，是协议处理中的⼀种中间状态，实际⽤到的⽐较少。</p><ul><li>2xx</li></ul><p>2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。</p><p>「<strong>200 OK</strong>」是最常⻅的成功状态码，表示⼀切正常。如果是⾮ HEAD 请求，服务器返回的响应头都会有 body 数据。</p><p>「<strong>204 No Content</strong>」也是常⻅的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。「<strong>206 Partial Content</strong>」是应⽤于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，⽽是其中的⼀部分，也是服务器处理成功的状态。</p><ul><li>3xx</li></ul><p>3xx 类状态码表示客户端请求的资源发送了变动，需要客户端⽤新的 URL 重新发送请求获取资源，也就是重定向。</p><p>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改⽤新的 URL 再次访问。</p><p>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问。</p><p>301 和 302 都会在响应头⾥使⽤字段 Location ，指明后续要跳转的 URL，浏览器会⾃动重定向新的 URL。</p><p>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲⽂件，也称缓存重定向，⽤于缓存控制。</p><ul><li>4xx</li></ul><p>4xx 类状态码表示客户端发送的报⽂有误，服务器⽆法处理，也就是错误码的含义。</p><p>「<strong>400 Bad Request</strong>」表示客户端请求的报⽂有错误，但只是个笼统的错误。</p><p>「<strong>401 Unauthorized</strong>」表示服务器需要客户端提供认证信息。</p><p>「<strong>403 Forbidden</strong>」表示服务器禁⽌访问资源，并不是客户端的请求出错。</p><p>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以⽆法提供给客户端。</p><ul><li><em>5xx</em></li></ul><p>5xx 类状态码表示客户端请求报⽂正确，但是服务器处理时内部发⽣了错误，属于服务器端的错误码。</p><p>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通⽤的错误码，服务器发⽣了什么错误，我们并不知道。</p><p>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思。</p><p>「<strong>502 Bad Gateway</strong>」通常是<strong>服务器作为⽹关或代理时</strong>返回的错误码，表示服务器⾃身⼯作正常，访问后端服务器发⽣了错误。</p><p>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时⽆法响应服务器，类似“⽹络服务正忙，请稍后重试”的意思。</p><h3 id="HTTP-常⻅字段"><a href="#HTTP-常⻅字段" class="headerlink" title="HTTP 常⻅字段"></a>HTTP 常⻅字段</h3><ul><li>HOST</li></ul><p>客户端发送请求时，⽤来指定服务器的域名。</p><ul><li><em>Content-Length</em></li></ul><p>服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据⻓度。</p><ul><li><em>Connection</em></li></ul><p>Connection 字段最常⽤于客户端要求服务器使⽤ TCP 持久连接，以便其他请求复⽤。</p><p>HTTP/1.1 版本的默认连接都是持久连接，但为了兼容⽼版本的 HTTP，需要指定 Connection ⾸部字段的值为 Keep-Alive 。</p><ul><li>Accept / <em>Content-Type</em></li></ul><p>客户端请求的时候，可以使⽤ Accept 字段声明⾃⼰可以接受哪些数据格式。</p><p>Content-Type 字段⽤于服务器回应时，告诉客户端，本次数据是什么格式。</p><ul><li>Accept-Encoding / Content-Encoding</li></ul><p>Content-Encoding 字段说明数据的压缩⽅法。表示服务器返回的数据使⽤了什么压缩格式</p><p>客户端在请求时，⽤ Accept-Encoding 字段说明⾃⼰可以接受哪些压缩⽅法。</p><h3 id="HTTP-特性"><a href="#HTTP-特性" class="headerlink" title="HTTP 特性"></a><strong>HTTP</strong> 特性</h3><ul><li>简单</li></ul><p>HTTP 基本的报⽂格式就是 header + body ，头部信息也是 key-value 简单⽂本的形式，易于理解，降低了学习和使⽤的⻔槛。</p><ul><li>灵活和易于扩展</li></ul><p>HTTP 协议⾥的各类请求⽅法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发⼈员⾃定义和扩充。</p><ul><li>无状态</li></ul><p>⽆状态的好处，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存⽤来对外提供服务。</p><p>⽆状态的坏处，既然服务器没有记忆能⼒，它在完成有关联性的操作时会⾮常麻烦。例如登录-&gt;添加购物⻋-&gt;下单-&gt;结算-&gt;⽀付，这系列操作都要知道⽤户的身份才⾏。但服务器不知道这些请求是有关联的，每次都要问⼀遍身份信息。</p><p>对于⽆状态的问题，解法⽅案有很多种，其中⽐较简单的⽅式⽤ <strong>Cookie</strong> 技术。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/pic/image-20211127124400027.png" alt="image-20211127124400027" style="zoom:33%;" /><ul><li>明⽂传输</li></ul><p>明⽂意味着在传输过程中的信息，是可⽅便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接⾁眼查看，为我们调试⼯作带了极⼤的便利性。</p><ul><li>不安全</li></ul><p>通信使⽤明⽂（不加密），内容可能会被窃听。不验证通信⽅的身份，因此有可能遭遇伪装。⽆法证明报⽂的完整性，所以有可能已遭篡改。可以通过引⼊ SSL/TLS 层，使得在安全上达到了极致。</p><h3 id="HTTP-性能"><a href="#HTTP-性能" class="headerlink" title="HTTP 性能"></a>HTTP 性能</h3><p>HTTP 协议是基于 <strong>TCP/IP</strong>，并且使⽤了「请求 <strong>-</strong> 应答」的通信模式，所以性能的关键就在这两点⾥。</p><ul><li>长连接</li></ul><p>早期 HTTP/1.0 性能上的⼀个很⼤的问题，那就是每发起⼀个请求，都要新建⼀次 TCP 连接（三次握⼿），⽽且是串⾏请求，做了⽆谓的 TCP 连接建⽴和断开，增加了通信开销。为了解决上述 TCP 连接问题，HTTP/1.1 提出了⻓连接的通信⽅式，也叫持久连接。这种⽅式的好处在于减少了 TCP 连接的重复建⽴和断开所造成的额外开销，减轻了服务器端的负载。持久连接的特点是，只要任意⼀端没有明确提出断开连接，则保持 TCP 连接状态。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211127111558513.png" alt="image-20211127111558513" style="zoom:33%;" /><ul><li>管道传输</li></ul><p>可在同⼀个 TCP 连接⾥⾯，客户端可以发起多个请求，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以减少整体的响应时间。但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是前⾯的回应特别慢，后⾯就会有许多请求排队等着。这称为「队头堵塞」。</p><h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><h4 id="避免发送-重复的HTTP-请求"><a href="#避免发送-重复的HTTP-请求" class="headerlink" title="避免发送 重复的HTTP 请求"></a>避免发送 重复的<strong>HTTP</strong> 请求</h4><p>通过<strong>缓存技术</strong>，对于⼀些具有重复性的 HTTP 请求，⽐如每次请求得到的数据都⼀样的，我们可以把这对「请求-响应」的数据都缓存在本地，那么下次就直接读取本地的数据，不必在通过⽹络获取服务器的响应了。</p><p>客户端会把第⼀次请求以及响应的数据保存在本地磁盘上，其中将请求的 URL 作为 key，⽽响应作为 value，两者形成映射关系。这样当后续发起相同的请求时，就可以先在本地磁盘上通过 key 查到对应的 value，也就是响应，如果找到了，就直接从本地读取该响应。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211127113034457.png" alt="image-20211127113034457" style="zoom:33%;" /><p>万⼀缓存的响应不是最新的，⽽客户端并不知情，<strong>那么该怎么办呢</strong>？</p><p>服务器在发送 HTTP 响应时，会估算⼀个过期的时间，并把这个信息放到响应头部中，这样客户端在查看响应头部的信息时，⼀旦发现缓存的响应是过期的，则就会重新发送⽹络请求。</p><p>如果客户端从第⼀次请求得到的响应头部中发现该响应过期了，客户端重新发送请求，假设服务器上的资源并没有变更，还是⽼样⼦，那么服务器的响应应该带上这个资源吗？很显然不带的话，可以提⾼ HTTP 协议的性能，<strong>那具体如何做到呢</strong>？</p><p>只需要客户端在重新发送请求时，在请求的 Etag 头部带上第⼀次请求的响应头部中的摘要，这个摘要是唯⼀标识响应的资源，当服务器收到请求后，会将本地资源的摘要与请求中的摘要做个⽐较。如果不同，那么说明客户端的缓存已经没有价值，服务器在响应中带上最新的资源。如果相同，说明客户端的缓存还是可以继续使⽤的，那么服务器仅返回不含有包体的 304 Not Modified 304 Not Modified 响应，告诉客户端仍然有效，这样就可以减少响应资源在⽹络中传输的延时。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/pic/image-20211127124511250.png" alt="image-20211127124511250" style="zoom:25%;" /><h4 id="减少-HTTP-请求次数"><a href="#减少-HTTP-请求次数" class="headerlink" title="减少 HTTP 请求次数"></a>减少 <strong>HTTP</strong> 请求次数</h4><ul><li>减少重定向请求次数</li></ul><p>服务器上的⼀个资源可能由于迁移、维护等原因从 url1 移⾄ url2 后，⽽客户端不知情，它还是继续请求 url1，这时服务器不能粗暴地返回错误，⽽是通过 302 响应码和 Location 头部，告诉客户端该资源已经迁移⾄ url2 了，于是客户端需要再发送 url2 请求以获得服务器的资源。</p><p>如果重定向请求越多，那么客户端就要多次发起 HTTP 请求，每⼀次的 HTTP 请求都得经过⽹络，这⽆疑会越降低⽹络性能。</p><p>另外，服务端这⼀⽅往往不只有⼀台服务器，⽐如源服务器上⼀级是代理服务器，然后代理服务器才与客户端通信，这时客户端重定向就会导致客户端与代理服务器之间需要 2 次消息传递。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211127114016498.png" alt="image-20211127114016498" style="zoom:33%;" /><p>如果重定向的⼯作交由代理服务器完成，就能减少 <strong>HTTP</strong> 请求次数了</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211127114045230.png" alt="image-20211127114045230" style="zoom: 33%;" /><p>⽽且当代理服务器知晓了重定向规则后，可以进⼀步减少消息传递次数</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211127114147959.png" alt="image-20211127114147959" style="zoom:33%;" /><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211127114329172.png" alt="image-20211127114329172" style="zoom:33%;" /><p>其中， 301 和 308 响应码是告诉客户端可以将重定向响应缓存到本地磁盘，之后客户端就⾃动⽤ url2 替代 url1 访问服务器的资源。</p><ul><li>合并请求</li></ul><p>如果把多个访问⼩⽂件的请求合并成⼀个⼤的请求，虽然传输的总资源还是⼀样，但是减少请求，也就意味着减少了重复发送的 <strong>HTTP</strong> 头部。</p><p>另外由于 HTTP/1.1 是请求响应模型，如果第⼀个发送的请求，未收到对应的响应，那么后续的请求就不会发送，于是为了防⽌单个请求的阻塞，所以⼀般浏览器会同时发起 5-6 个请求，每⼀个请求都是不同的 TCP 连接，那么如果合并了请求，也就会减少 <strong>TCP</strong> 连接的数量，因⽽省去了 <strong>TCP</strong> 握⼿和慢启动过程耗费的时间。</p><p>有的⽹⻚会含有很多⼩图⽚、⼩图标，有多少个⼩图⽚，客户端就要发起多少次请求。那么对于这些⼩图⽚，我们可以考虑使⽤ CSS Image Sprites 技术把它们合成⼀个⼤图⽚，这样浏览器就可以⽤⼀次请求获得⼀个⼤图⽚，然后再根据 CSS 数据把⼤图⽚切割成多张⼩图⽚。</p><p>除了将⼩图⽚合并成⼤图⽚的⽅式，还有服务端使⽤ webpack 等打包⼯具将 js、css 等资源合并打包成⼤⽂件，也是能达到类似的效果。</p><p>还可以将图⽚的⼆进制数据⽤ base64 编码后，以 URL 的形式潜⼊到 HTML ⽂件，跟随 HTML ⽂件⼀并发送.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">image</span></span></span><br><span class="line"><span class="tag"><span class="attr">src</span>=<span class="string">&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPoAAAFKCAIAAAC7M9WrAAAACXBIWXMAA</span></span></span><br><span class="line"><span class="string"><span class="tag">... /&gt;</span></span></span><br></pre></td></tr></table></figure><p>但是这样的合并请求会带来新的问题，当⼤资源中的某⼀个⼩资源发⽣变化后，客户端必须重新下载整个完整的⼤资源⽂件，这显然带来了额外的⽹络消耗。</p><ul><li>延迟发送请求</li></ul><p>请求⽹⻚的时候，没必要把全部资源都获取到，⽽是只获取当前⽤户所看到的⻚⾯资源，当⽤户向下滑动⻚⾯的时候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果。</p><h4 id="减少-HTTP-响应的数据⼤⼩"><a href="#减少-HTTP-响应的数据⼤⼩" class="headerlink" title="减少 HTTP 响应的数据⼤⼩"></a>减少 <strong>HTTP</strong> 响应的数据⼤⼩</h4><p>对于 HTTP 的请求和响应，通常 HTTP 的响应的数据⼤⼩会⽐较⼤，也就是服务器返回的资源会⽐较⼤。</p><p>于是，我们可以考虑对响应的资源进⾏压缩，这样就可以减少响应的数据⼤⼩，从⽽提⾼⽹络传输的效率。压缩的⽅式⼀般分为 2 种:</p><ul><li>⽆损压缩</li></ul><p>⽆损压缩是指资源经过压缩后，信息不被破坏，还能完全恢复到压缩前的原样，适合⽤在⽂本⽂件、程序可执⾏⽂件、程序源代码。</p><p>⾸先，我们针对代码的语法规则进⾏压缩，因为通常代码⽂件都有很多换⾏符或者空格，这些是为了帮助程序员更好的阅读，但是机器执⾏时并不要这些符，把这些多余的符号给去除掉。</p><p>接下来，就是⽆损压缩了，需要对原始资源建⽴统计模型，利⽤这个统计模型，将常出现的数据⽤较短的⼆进制⽐特序列表示，将不常出现的数据⽤较⻓的⼆进制⽐特序列表示，⽣成⼆进制⽐特序列⼀般是「霍夫曼编码」算法。</p><p>gzip 就是⽐较常⻅的⽆损压缩。客户端⽀持的压缩算法，会在 HTTP 请求中通过头部中的 Accept-Encoding 字段。</p><p>gzip 的压缩效率相⽐ Google 推出的 Brotli 算法还是差点意思，所以如果可以，服务器应该选择压缩效率更⾼的 br 压缩算法。</p><ul><li>有损压缩</li></ul><p>与⽆损压缩相对的就是有损压缩，经过此⽅法压缩，解压的数据会与原始数据不同但是⾮常接近。</p><p>有损压缩主要将次要的数据舍弃，牺牲⼀些质 ᰁ 来减少数据 ᰁ、提⾼压缩⽐，这种⽅法经常⽤于压缩多媒体数据，⽐如⾳频、视频、图⽚。</p><p>可以通过 HTTP 请求头部中的 Accept 字段⾥的「 q 质量因⼦」，告诉服务器期望的资源质量</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>audio/*; q=0.2, audio/basic</span><br></pre></td></tr></table></figure><p>关于图⽚的压缩，⽬前压缩⽐较⾼的是 Google 推出的 <strong>WebP</strong> 格式，相同质量的图片下，WebP 格式的图⽚⼤⼩都⽐ Png 格式的图⽚⼩。</p><p>关于⾳视频的压缩，⾳视频主要是动态的，每个帧都有时序的关系，通常时间连续的帧之间的变化是很⼩的。</p><p>⽐如，⼀个在看书的视频，画⾯通常只有⼈物的⼿和书桌上的书是会有变化的，⽽其他地⽅通常都是静态的，于是只需要在⼀个静态的关键帧，使⽤<strong>增量数据</strong>来表达后续的帧，这样便减少了很多数据，提⾼了⽹络传输的性能。对于视频常⻅的编码格式有 H264、H265 等，⾳频常⻅的编码格式有 AAC、AC3。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h2&gt;&lt;p&gt;HTTP （HyperText Transfer Protocol）超文本传输协议&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP&lt;/strong&gt; 是⼀个在计算机世界⾥专⻔在「两点」之间「传输」⽂字、图⽚、⾳频、视频等「超⽂本」数据的「约定和规范」。&lt;/p&gt;</summary>
    
    
    
    
    <category term="网络" scheme="https://cwww3.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>IO</title>
    <link href="https://cwww3.github.io/2021/11/18/IO/"/>
    <id>https://cwww3.github.io/2021/11/18/IO/</id>
    <published>2021-11-18T03:22:05.000Z</published>
    <updated>2021-11-18T03:22:39.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><ul><li><p>可以进行I/O操作的内核对象</p></li><li><p>文件、管道、套接字等都是流</p></li><li><p>流的入口：文件描述符(fd)</p><span id="more"></span><h3 id="I-O操作"><a href="#I-O操作" class="headerlink" title="I/O操作"></a>I/O操作</h3></li><li><p>对流的读写操作称为I/O操作</p></li></ul><h3 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h3><ul><li>同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。</li><li>异步就是发一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时可以处理其他的请求，被调用者通常依靠事件、回调等机制来通知调用者其返回结果。</li></ul><h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><ul><li>阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。不占用CPU资源。</li><li>非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他的事情。占用CPU资源(轮询)</li></ul><h3 id="同步异步与阻塞非阻塞"><a href="#同步异步与阻塞非阻塞" class="headerlink" title="同步异步与阻塞非阻塞"></a>同步异步与阻塞非阻塞</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 老张烧开水的故事</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 老张爱喝茶，废话不说，煮开水。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同步阻塞</span></span><br><span class="line">老张把水壶放到火上，立等水开。</span><br><span class="line">老张觉得自己有点傻</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同步非阻塞</span></span><br><span class="line">老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。</span><br><span class="line">老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~的噪音。</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 异步阻塞</span></span><br><span class="line">老张把响水壶放到火上，立等水开。</span><br><span class="line">老张觉得这样傻等意义不大</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 异步非阻塞</span></span><br><span class="line">老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。</span><br><span class="line">老张觉得自己聪明了。</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 所谓同步异步，只是对于水壶而言</span></span><br><span class="line">普通水壶：同步；响水壶：异步。</span><br><span class="line">虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了，这是普通水壶所不能及的。</span><br><span class="line">同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 所谓阻塞非阻塞，仅仅对于老张而言</span></span><br><span class="line">立等的老张：阻塞；看电视的老张：非阻塞。</span><br><span class="line">虽然情况3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="阻塞IO-Blocking-IO"><a href="#阻塞IO-Blocking-IO" class="headerlink" title="阻塞IO - Blocking IO"></a>阻塞IO - Blocking IO</h3><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211118105721114.png" alt="image-20211118105721114" style="zoom:33%;" /><ul><li>一请求一应答</li><li>通常由一个独立的 <code>Acceptor</code> 线程负责监听客户端的连接。我们一般通过在 <code>while(true)</code> 循环中服务端会调用 <code>accept()</code> 方法等待客户端连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待当前连接的客户端的操作执行完成，不过可以<strong>通过多线程来支持多个客户端的连接</strong></li></ul><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211118103446987.png" alt="image-20211118103446987" style="zoom: 33%;" /><h3 id="伪异步-I-O"><a href="#伪异步-I-O" class="headerlink" title="伪异步 I/O"></a>伪异步 I/O</h3><p>当客户端并发访问量增加后<strong>阻塞IO模型</strong>会出随着并发访问量增加会导致线程数急剧膨胀可能会导致线程堆栈溢出、创建新线程失败等问题，最终导致进程宕机或者僵死，不能对外提供服务。</p><p>线程是宝贵的资源。线程的创建和销毁成本很高，线程本身占用较大内存，线程的切换成本也很高，容易造成锯齿状的系统负载。</p><ul><li>解决方案</li></ul><p>后端通过一个线程池来处理多个客户端的请求接入，设置线程的最大值，防止由于海量并发接入导致线程耗尽。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211118105303658.png" alt="image-20211118105303658" style="zoom:33%;" /><h3 id="非阻塞IO-NoneBlocking-IO"><a href="#非阻塞IO-NoneBlocking-IO" class="headerlink" title="非阻塞IO - NoneBlocking IO"></a>非阻塞IO - NoneBlocking IO</h3><p>当用户线程发起一个 IO 操作后，并不需要等待，而是马上就得到一个结果。如果结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 IO 操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。</p><p>在非阻塞IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211118110037961.png" alt="image-20211118110037961" style="zoom:33%;" /><ul><li>非阻塞式主要体现在用户进程发起recvfrom系统调用的时候,这个时候系统内核还没有接收到数据报,直接返回错误给用户进程,告诉“当前还没有数据报可达,晚点再来”</li><li>用户进程接收到信息,但是用户进程不知道什么时候数据报可达,于是就开始不断轮询(polling)向系统内核发起recvfrom的系统调用“询问数据来了没”,如果没有则继续返回错误</li><li>用户进程轮询发起recvfrom系统调用直至数据报可达,这个时候需要等待系统内核复制数据报到用户进程的缓冲区,复制完成之后将返回成功提示</li></ul><h3 id="IO多路复用-IO-multiplexing"><a href="#IO多路复用-IO-multiplexing" class="headerlink" title="IO多路复用 - IO multiplexing"></a>IO多路复用 - IO multiplexing</h3><p>所谓 I/O 多路复用机制，就是说通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。这种机制的使用需要 <code>select</code> 、 <code>poll</code> 、 <code>epoll</code> 来配合。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211118110236775.png" alt="image-20211118110236775" style="zoom:33%;" /><p>在多路复用IO模型中，会有一个内核线程不断地去轮询多个 socket 的状态，只有当真正读写事件发送时，才真正调用实际的IO读写操作。<strong>因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有真正有读写事件进行时，才会使用IO资源，所以它大大减少来资源占用</strong>。</p><ul><li>IO复用模式是使用select或者poll函数向系统内核发起调用，阻塞在这两个系统函数调用，而不是真正阻塞于实际的IO操作(recvfrom调用才是实际阻塞IO操作的系统调用)</li><li>阻塞于select函数的调用,等待数据报套接字变为可读状态</li><li>当select套接字返回可读状态的时候,就可以发起recvfrom调用把数据报复制到用户空间的缓冲区</li></ul><h3 id="信号驱动IO-signal-driven-IO"><a href="#信号驱动IO-signal-driven-IO" class="headerlink" title="信号驱动IO - signal driven IO"></a>信号驱动IO - signal driven IO</h3><p>在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。这个一般用于UDP中，对TCP套接字几乎没用，原因是该信号产生得过于频繁，并且该信号的出现并没有告诉我们发生了什么请求。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211118110908521.png" alt="image-20211118110908521" style="zoom:33%;" /><h3 id="异步IO-asynchronous-IO"><a href="#异步IO-asynchronous-IO" class="headerlink" title="异步IO - asynchronous IO"></a>异步IO - asynchronous IO</h3><p>前面四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是从内核拷贝数据到用户态的过程都会让用户线程阻塞。</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211118110819248.png" alt="image-20211118110819248" style="zoom:33%;" /><ul><li>由POSIX规范定义，告知系统内核启动某个操作，并让内核在整个操作包含数据等待以及数据复制过程的完成之后通知用户进程数据已经准备完成，可以进行读取数据；</li><li>与上述的信号IO模型区分在于异步是通知我们何时IO操作完成,而信号IO是通知我们何时可以启动一个IO操作</li></ul><h3 id="IO模型对比"><a href="#IO模型对比" class="headerlink" title="IO模型对比"></a>IO模型对比</h3><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211118111021556.png" alt="image-20211118111021556" style="zoom:33%;" /><h2 id="处理多I-O请求"><a href="#处理多I-O请求" class="headerlink" title="处理多I/O请求"></a>处理多I/O请求</h2><p><strong>阻塞+多进程/多线程</strong></p><p><strong>非阻塞+轮询</strong></p><p><strong>多路复用</strong></p><ul><li>select  最多监听1024个 且不会通知具体哪个流接收到数据  需要遍历全部流，进行处理。  平台无关性。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span>() <span class="comment">//阻塞</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, in := ins &#123;</span><br><span class="line">        <span class="keyword">if</span> has &#123;</span><br><span class="line">            <span class="comment">// 处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， <strong>但是它没有最大连接数的限制</strong>，原因是它是基于链表来存储的.</p></li><li><p>epoll  监听的数量与操作系统能打开的文件数相同，且返回收到数据的流。不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。Linux操作系统的方法。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    ins = epoll() <span class="comment">//阻塞 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, in := ins &#123;</span><br><span class="line">          <span class="comment">// 处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211118111811931.png" alt="image-20211118111811931" style="zoom:33%;" /></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;I-O&quot;&gt;&lt;a href=&quot;#I-O&quot; class=&quot;headerlink&quot; title=&quot;I/O&quot;&gt;&lt;/a&gt;I/O&lt;/h2&gt;&lt;h3 id=&quot;流&quot;&gt;&lt;a href=&quot;#流&quot; class=&quot;headerlink&quot; title=&quot;流&quot;&gt;&lt;/a&gt;流&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可以进行I/O操作的内核对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文件、管道、套接字等都是流&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;流的入口：文件描述符(fd)&lt;/p&gt;</summary>
    
    
    
    
    <category term="IO" scheme="https://cwww3.github.io/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Dockerfile</title>
    <link href="https://cwww3.github.io/2021/11/05/docker-file/"/>
    <id>https://cwww3.github.io/2021/11/05/docker-file/</id>
    <published>2021-11-05T03:13:55.000Z</published>
    <updated>2021-11-05T03:14:43.393Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><ul><li>RUN</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="bash">    aufs-tools \</span></span><br><span class="line"><span class="bash">    automake \</span></span><br><span class="line"><span class="bash">    build-essential \</span></span><br><span class="line"><span class="bash">    curl \</span></span><br><span class="line"><span class="bash">    dpkg-sig \</span></span><br><span class="line"><span class="bash">    libcap-dev \</span></span><br><span class="line"><span class="bash">    libsqlite3-dev \</span></span><br><span class="line"><span class="bash">    mercurial \</span></span><br><span class="line"><span class="bash">    reprepro \</span></span><br><span class="line"><span class="bash">    ruby1.9.1 \</span></span><br><span class="line"><span class="bash">    ruby1.9.1-dev \</span></span><br><span class="line"><span class="bash">    s3cmd=1.1.* \</span></span><br><span class="line"><span class="bash"> &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure><span id="more"></span><ul><li>CMD</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多数情况下，CMD 都需要一个交互式的 shell (bash, Python, perl 等)，</span></span><br><span class="line"><span class="comment"># 例如 CMD [&quot;perl&quot;, &quot;-de0&quot;]，或者 CMD [&quot;PHP&quot;, &quot;-a&quot;]。</span></span><br><span class="line"><span class="comment"># 使用这种形式意味着，当你执行类似docker run -it python时，你会进入一个准备好的 shell 中。</span></span><br></pre></td></tr></table></figure><ul><li>ENV</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了方便新程序运行，你可以使用ENV来为容器中安装的程序更新 PATH 环境变量。</span></span><br><span class="line"><span class="comment"># 例如使用ENV PATH /usr/local/nginx/bin:$PATH来确保CMD [&quot;nginx&quot;]能正确运行。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PG_MAJOR <span class="number">9.3</span></span><br><span class="line"><span class="keyword">ENV</span> PG_VERSION <span class="number">9.3</span>.<span class="number">4</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl -SL http://example.com/postgres-<span class="variable">$PG_VERSION</span>.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …ENV PATH /usr/<span class="built_in">local</span>/postgres-<span class="variable">$PG_MAJOR</span>/bin:<span class="variable">$PATH</span></span></span><br></pre></td></tr></table></figure><ul><li>ADD COPY</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一般优先使用 COPY。因为它比 ADD 更透明。</span></span><br><span class="line"><span class="comment"># ADD的最佳用例是将本地 tar 文件自动提取到镜像中</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> rootfs.tar.xz</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /usr/src/things \</span></span><br><span class="line"><span class="bash">    &amp;&amp; curl -SL http://example.com/big.tar.xz \</span></span><br><span class="line"><span class="bash">    | tar -xJC /usr/src/things \</span></span><br><span class="line"><span class="bash">    &amp;&amp; make -C /usr/src/things all</span></span><br></pre></td></tr></table></figure><ul><li>ENTRYPOINT</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最佳用处是设置镜像的主命令,允许将镜像当成命令本身来运行,用 CMD 提供默认选项</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;s3cmd&quot;</span>] </span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;--help&quot;</span>]</span></span><br><span class="line"></span><br><span class="line">$docker <span class="keyword">run</span><span class="bash"> s3cmd</span></span><br><span class="line">$docker <span class="keyword">run</span><span class="bash"> s3cmd ls s3://mybucket</span></span><br></pre></td></tr></table></figure><ul><li>VOLUMN</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># VOLUME指令用于暴露任何数据库存储文件，配置文件，或容器创建的文件和目录。强烈建议使用 VOLUME来管理镜像中的可变部分和用户可以改变的部分。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>USER</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果某个服务不需要特权执行，建议使用 USER 指令切换到非 root 用户。</span></span><br><span class="line"><span class="comment"># 如果要依赖确定的 UID/GID，你应该显示的指定一个 UID/GID</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres </span></span><br></pre></td></tr></table></figure><ul><li>WORKDIR</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了清晰性和可靠性，你应该总是在WORKDIR中使用绝对路径 替代类似于 RUN cd </span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Dockerfile&quot;&gt;&lt;a href=&quot;#Dockerfile&quot; class=&quot;headerlink&quot; title=&quot;Dockerfile&quot;&gt;&lt;/a&gt;Dockerfile&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;RUN&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight dockerfile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;RUN&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; apt-get update &amp;amp;&amp;amp; apt-get install -y \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    aufs-tools \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    automake \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    build-essential \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    curl \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    dpkg-sig \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    libcap-dev \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    libsqlite3-dev \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    mercurial \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    reprepro \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    ruby1.9.1 \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    ruby1.9.1-dev \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt;    s3cmd=1.1.* \&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;bash&quot;&gt; &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Docker" scheme="https://cwww3.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB</title>
    <link href="https://cwww3.github.io/2021/10/13/mongodb/"/>
    <id>https://cwww3.github.io/2021/10/13/mongodb/</id>
    <published>2021-10-13T07:21:08.000Z</published>
    <updated>2021-10-26T05:48:18.490Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>MongoDB 是一个面向文档存储的数据库</p><table><thead><tr><th>SQL术语/概念</th><th>MongoDB术语/概念</th><th>解释/说明</th></tr></thead><tbody><tr><td>database</td><td>database</td><td>数据库</td></tr><tr><td>table</td><td>collection</td><td>数据库表/集合</td></tr><tr><td>row</td><td>document</td><td>数据记录行/文档</td></tr><tr><td>column</td><td>field</td><td>数据字段/域</td></tr><tr><td>index</td><td>index</td><td>索引</td></tr><tr><td>table joins</td><td></td><td>表连接,MongoDB不支持</td></tr><tr><td>primary key</td><td>primary key</td><td>主键,MongoDB自动将_id字段设置为主键</td></tr></tbody></table><span id="more"></span><p><a href="https://www.mongodb.com/download-center#community">下载地址</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动 --dbpath指定数据存放位置</span></span><br><span class="line">./mongod --dbpath=/path  </span><br><span class="line">./mongo 连接MongoDB服务</span><br></pre></td></tr></table></figure><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示已有数据库</span></span><br><span class="line">show dbs </span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到指定数据库(没有则创建)</span></span><br><span class="line">use dbName</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前所在数据库</span></span><br><span class="line">db </span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除当前数据库</span></span><br><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合就是 MongoDB 文档组。集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出当前db的集合</span></span><br><span class="line">show collections;</span><br><span class="line">show tables;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建集合 name集合名 options可选参数(capped大小是否固定 size设置大小，字节数  max指定文档最大数量)</span></span><br><span class="line">db.createCollection(name, options)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 例子</span></span><br><span class="line">db.createCollection(&quot;col&quot;)</span><br><span class="line">db.createCollection(&quot;col&quot;, &#123; capped : true, autoIndexId : true, size : 6142800, max : 10000 &#125; )</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除集合</span></span><br><span class="line">db.col.drop()</span><br></pre></td></tr></table></figure><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>文档是一组键值(key-value)对(即 BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。</p><p>需要注意的是：</p><ol><li>文档中的键/值对是有序的。</li><li>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。</li><li>MongoDB区分类型和大小写。</li><li>MongoDB的文档不能有重复的键。</li><li>文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 插入文档</span></span><br><span class="line">db.COLLECTION_NAME.insert(document) # 主键已存在则报错</span><br><span class="line">db.COLLECTION_NAME.insertOne(document) # 主键已存在则更新</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例子  如果col集合不在该数据库中， MongoDB 会自动创建该集合并插入文档</span></span><br><span class="line">db.col.insert(&#123;title: &#x27;MongoDB&#x27;, </span><br><span class="line">    description: &#x27;MongoDB 是一个 Nosql 数据库&#x27;,</span><br><span class="line">    tags: [&#x27;mongodb&#x27;, &#x27;database&#x27;, &#x27;NoSQL&#x27;],</span><br><span class="line">    likes: 100</span><br><span class="line">&#125;)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找</span></span><br><span class="line">db.col.find()</span><br><span class="line">db.col.findOne() # 返回一条</span><br><span class="line">db.col.find().pretty() # 正确可读性</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新 将title为MongoDB的文档改为MongoDB 教程 (只会更新一条)</span></span><br><span class="line">db.col.update(&#123;&#x27;title&#x27;:&#x27;MongoDB&#x27;&#125;,&#123;$set:&#123;&#x27;title&#x27;:&#x27;MongoDB 教程&#x27;&#125;&#125;)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以上语句只会修改第一条发现的文档，如果你要修改多条相同的文档，则需要设置 multi 参数为 <span class="literal">true</span>。</span></span><br><span class="line">db.col.update(&#123;&#x27;title&#x27;:&#x27;MongoDB&#x27;&#125;,&#123;$set:&#123;&#x27;title&#x27;:&#x27;MongoDB 教程&#x27;&#125;,&#123;multi:true&#125;&#125;)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除 title为MongoDB 教程的文档</span></span><br><span class="line">db.col.remove(&#123;&#x27;title&#x27;:&#x27;MongoDB 教程&#x27;&#125;)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除一条</span></span><br><span class="line">db.col.remove(&#123;&#x27;title&#x27;:&#x27;MongoDB 教程&#x27;&#125;,1)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 全删</span></span><br><span class="line">db.col.remove(&#123;&#125;)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择指定字段</span></span><br><span class="line">db.col.find(&#123;&#125;,&#123;title:1&#125;) # 展示_id,title字段(_id默认展示)</span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line">db.col.find(&#123;&#125;,&#123;_id:0,title:1&#125;) # 只展示title字段</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 条件查询</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 等于--&#123;&lt;key&gt;:&lt;value&gt;&#125; 小于--&#123;&lt;key&gt;:&#123;<span class="variable">$lt</span>:&lt;value&gt;&#125;&#125;  小于或等于--lte ，大于--gt 大于或等于--gte  不等于--ne</span></span><br><span class="line">db.col.find(&#123;&quot;likes&quot;:&#123;$lt:50&#125;&#125;).pretty()</span><br><span class="line"><span class="meta">#</span><span class="bash"> AND &#123;key1:value1, key2:value2&#125;</span></span><br><span class="line">db.col.find(&#123;&quot;likes&quot;:50, &quot;title&quot;:&quot;MongoDB 教程&quot;&#125;)</span><br><span class="line"><span class="meta">#</span><span class="bash"> OR</span></span><br><span class="line">db.col.find(</span><br><span class="line">   &#123;</span><br><span class="line">      $or: [</span><br><span class="line">         &#123;key1: value1&#125;, &#123;key2:value2&#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br><span class="line"><span class="meta">#</span><span class="bash"> AND + OR</span></span><br><span class="line">db.col.find(&#123;&quot;likes&quot;: &#123;$gt:50&#125;, $or: [&#123;&quot;by&quot;: &quot;cwww&quot;&#125;,&#123;&quot;title&quot;: &quot;MongoDB 教程&quot;&#125;]&#125;)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">limit</span></span></span><br><span class="line">db.col.find().limit(2)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sort</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 其中 1 为升序排列，而 -1 是用于降序排列</span></span><br><span class="line">db.col.find().sort(&#123;&quot;likes&quot;:-1&#125;)</span><br></pre></td></tr></table></figure><ul><li>MongoDB 索引</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建索引</span></span><br><span class="line">db.col.createIndex(&#123;&quot;title&quot;:1&#125;)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建复合索引</span></span><br><span class="line">db.col.createIndex(&#123;&quot;title&quot;:1,&quot;description&quot;:-1&#125;)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看集合索引</span></span><br><span class="line">db.col.getIndexes()</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看集合索引大小</span></span><br><span class="line">db.col.totalIndexSize()</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除集合所有索引</span></span><br><span class="line">db.col.dropIndexes()</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除集合指定索引</span></span><br><span class="line">db.col.dropIndex(&quot;title&quot;)</span><br></pre></td></tr></table></figure><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>mongodb访问默认是用当前访问的库作为验证，若要验证通过可以通过两种方法。</p><p>1、在连接串上指定验证库，方法就是在连接串上加上authSource=admin，一般使用admin来做验证库</p><p>2、为当前的库添加对应的账户、密码和角色，以满足默认验证库为访问库的情况。</p><h3 id="Go操作MongoDB"><a href="#Go操作MongoDB" class="headerlink" title="Go操作MongoDB"></a>Go操作MongoDB</h3><p><a href="https://github.com/mongodb/mongo-go-driver/">地址</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get go.mongodb.org/mongo-driver/mongo</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;go.mongodb.org/mongo-driver/bson&quot;</span></span><br><span class="line"><span class="string">&quot;go.mongodb.org/mongo-driver/mongo&quot;</span></span><br><span class="line"><span class="string">&quot;go.mongodb.org/mongo-driver/mongo/options&quot;</span></span><br><span class="line"><span class="string">&quot;go.mongodb.org/mongo-driver/mongo/readpref&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 连接MongoDB服务</span></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">10</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line">client, err := mongo.Connect(ctx, options.Client().ApplyURI(<span class="string">&quot;mongodb://localhost:27017&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">err = client.Ping(ctx, readpref.Primary())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序退出前断开连接</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err = client.Disconnect(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取collection对象</span></span><br><span class="line">collection := client.Database(<span class="string">&quot;demo&quot;</span>).Collection(<span class="string">&quot;col&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一条文档</span></span><br><span class="line">res, err := collection.InsertOne(context.Background(), bson.D&#123;&#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;pi&quot;</span>&#125;, &#123;<span class="string">&quot;value&quot;</span>, <span class="number">3.14159</span>&#125;&#125;)</span><br><span class="line">id := res.InsertedID</span><br><span class="line">fmt.Println(id)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询</span></span><br><span class="line">cur, err := collection.Find(ctx, bson.D&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; log.Fatal(err) &#125;</span><br><span class="line"><span class="keyword">defer</span> cur.Close(ctx)</span><br><span class="line"><span class="keyword">for</span> cur.Next(ctx) &#123;</span><br><span class="line"><span class="keyword">var</span> result bson.D</span><br><span class="line">err := cur.Decode(&amp;result)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; log.Fatal(err) &#125;</span><br><span class="line">fmt.Println(result)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := cur.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;MongoDB&quot;&gt;&lt;a href=&quot;#MongoDB&quot; class=&quot;headerlink&quot; title=&quot;MongoDB&quot;&gt;&lt;/a&gt;MongoDB&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;MongoDB 是一个面向文档存储的数据库&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;SQL术语/概念&lt;/th&gt;
&lt;th&gt;MongoDB术语/概念&lt;/th&gt;
&lt;th&gt;解释/说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;database&lt;/td&gt;
&lt;td&gt;database&lt;/td&gt;
&lt;td&gt;数据库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;table&lt;/td&gt;
&lt;td&gt;collection&lt;/td&gt;
&lt;td&gt;数据库表/集合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;row&lt;/td&gt;
&lt;td&gt;document&lt;/td&gt;
&lt;td&gt;数据记录行/文档&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;column&lt;/td&gt;
&lt;td&gt;field&lt;/td&gt;
&lt;td&gt;数据字段/域&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;index&lt;/td&gt;
&lt;td&gt;index&lt;/td&gt;
&lt;td&gt;索引&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;table joins&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;表连接,MongoDB不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;primary key&lt;/td&gt;
&lt;td&gt;primary key&lt;/td&gt;
&lt;td&gt;主键,MongoDB自动将_id字段设置为主键&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    
    <category term="MongoDB" scheme="https://cwww3.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>go-kit</title>
    <link href="https://cwww3.github.io/2021/10/09/go-kit/"/>
    <id>https://cwww3.github.io/2021/10/09/go-kit/</id>
    <published>2021-10-09T08:20:17.000Z</published>
    <updated>2021-10-11T03:49:46.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="go-kit"><a href="#go-kit" class="headerlink" title="go-kit"></a>go-kit</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>go-kit 分为三层：Transport层、Endpoint层、Service层。</p><p>Transport层：负责与传输协议HTTP、GRPC、THRIFT等相关的逻辑处理。</p><p>Endpoint层： 负责request、response格式的转换，以及提供公用拦截器</p><p>Service层： 专注于业务逻辑</p><span id="more"></span><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 目录结构</span></span><br><span class="line"></span><br><span class="line">go-kit-demo</span><br><span class="line">├── endpoint</span><br><span class="line">│   └── endpoint.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">├── service</span><br><span class="line">│   └── service.go</span><br><span class="line">└── transport</span><br><span class="line">    └── transport.go</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>endpoint.go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> endpoint</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/go-kit/kit/endpoint&quot;</span></span><br><span class="line"><span class="string">&quot;go-kit-demo/service&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义请求响应格式</span></span><br><span class="line"><span class="keyword">type</span> HelloRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">Reply <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHelloEndpoint</span><span class="params">(s service.IService)</span> <span class="title">endpoint</span>.<span class="title">Endpoint</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, request <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(response <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">r,ok := request.(HelloRequest)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> HelloResponse&#123;&#125;,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> HelloResponse&#123;Reply: s.Hello(r.Name)&#125;,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>service.go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务类</span></span><br><span class="line"><span class="keyword">type</span> IService <span class="keyword">interface</span> &#123;</span><br><span class="line">Hello(name <span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Service <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Service)</span><span class="title">Hello</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;name:%v&quot;</span>,name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>transport.go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> transport</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line">localEndpoint <span class="string">&quot;go-kit-demo/endpoint&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责与传输协议相关的逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloDecodeRequest</span><span class="params">(ctx context.Context,request *http.Request)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;,error)</span></span> &#123;</span><br><span class="line">name := request.URL.Query().Get(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">&quot;参数为空&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> localEndpoint.HelloRequest&#123;Name: name&#125;,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloEncodeResponse</span><span class="params">(ctx context.Context,w http.ResponseWriter,response <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">w.Header().Set(<span class="string">&quot;Content-type&quot;</span>,<span class="string">&quot;application/json;charset=utf-8&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> json.NewEncoder(w).Encode(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li> main.go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">httpTransport <span class="string">&quot;github.com/go-kit/kit/transport/http&quot;</span></span><br><span class="line">localEndpoint <span class="string">&quot;go-kit-demo/endpoint&quot;</span></span><br><span class="line"><span class="string">&quot;go-kit-demo/service&quot;</span></span><br><span class="line"><span class="string">&quot;go-kit-demo/transport&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 业务接口服务</span></span><br><span class="line">s := service.Service&#123;&#125;</span><br><span class="line">    <span class="comment">// 创建业务服务</span></span><br><span class="line">helloEndpoint := localEndpoint.NewHelloEndpoint(s)</span><br><span class="line">    <span class="comment">// 使用 kit 创建 handler</span></span><br><span class="line">    <span class="comment">// 传入 业务服务 以及 定义的 加密解密方法</span></span><br><span class="line">helloServer := httpTransport.NewServer(helloEndpoint,transport.HelloDecodeRequest,transport.HelloEncodeResponse)</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:9090&quot;</span>,helloServer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211009161848307.png"  /><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211009161918628.png" alt="image-20211009161918628" /><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 目录结构</span></span><br><span class="line">go-kit-demo</span><br><span class="line">├── endpoint</span><br><span class="line">│   └── endpoint.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">├── middleware</span><br><span class="line">│   └── logMiddleware.go</span><br><span class="line">├── service</span><br><span class="line">│   └── service.go</span><br><span class="line">└── transport</span><br><span class="line">    └── transport.go</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>logMiddleware.go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> middleware</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/go-kit/kit/log&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/go-kit/kit/endpoint&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个中间件类型</span></span><br><span class="line"><span class="keyword">type</span> Middleware <span class="function"><span class="keyword">func</span><span class="params">(endpoint.Endpoint)</span> <span class="title">endpoint</span>.<span class="title">Endpoint</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志中间件 在开始和结束打印日志</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LogMiddleware</span><span class="params">(logger log.Logger)</span> <span class="title">Middleware</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(next endpoint.Endpoint)</span> <span class="title">endpoint</span>.<span class="title">Endpoint</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, request <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">logger.Log(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;call start&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> logger.Log(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;call end&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> next(ctx, request)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>main.go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/go-kit/kit/log&quot;</span></span><br><span class="line">httpTransport <span class="string">&quot;github.com/go-kit/kit/transport/http&quot;</span></span><br><span class="line">localEndpoint <span class="string">&quot;go-kit-demo/endpoint&quot;</span></span><br><span class="line"><span class="string">&quot;go-kit-demo/middleware&quot;</span></span><br><span class="line"><span class="string">&quot;go-kit-demo/service&quot;</span></span><br><span class="line"><span class="string">&quot;go-kit-demo/transport&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 业务接口服务</span></span><br><span class="line">s := service.Service&#123;&#125;</span><br><span class="line"><span class="comment">// 创建业务服务</span></span><br><span class="line">helloEndpoint := localEndpoint.NewHelloEndpoint(s)</span><br><span class="line"><span class="comment">// 添加了log中间件的服务</span></span><br><span class="line">logger := log.NewLogfmtLogger(os.Stderr)</span><br><span class="line">helloEndpoint = middleware.LogMiddleware(logger)(helloEndpoint)</span><br><span class="line"><span class="comment">// 使用 kit 创建 handler</span></span><br><span class="line"><span class="comment">// 传入 业务服务 以及 定义的 加密解密方法</span></span><br><span class="line">helloServer := httpTransport.NewServer(helloEndpoint, transport.HelloDecodeRequest, transport.HelloEncodeResponse)</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:9090&quot;</span>, helloServer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20211009163859928.png" alt="image-20211009163859928"></p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><a href="https://github.com/cwww3/git-kit-demo">项目源码</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;go-kit&quot;&gt;&lt;a href=&quot;#go-kit&quot; class=&quot;headerlink&quot; title=&quot;go-kit&quot;&gt;&lt;/a&gt;go-kit&lt;/h2&gt;&lt;h3 id=&quot;入门&quot;&gt;&lt;a href=&quot;#入门&quot; class=&quot;headerlink&quot; title=&quot;入门&quot;&gt;&lt;/a&gt;入门&lt;/h3&gt;&lt;p&gt;go-kit 分为三层：Transport层、Endpoint层、Service层。&lt;/p&gt;
&lt;p&gt;Transport层：负责与传输协议HTTP、GRPC、THRIFT等相关的逻辑处理。&lt;/p&gt;
&lt;p&gt;Endpoint层： 负责request、response格式的转换，以及提供公用拦截器&lt;/p&gt;
&lt;p&gt;Service层： 专注于业务逻辑&lt;/p&gt;</summary>
    
    
    
    
    <category term="微服务" scheme="https://cwww3.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件</title>
    <link href="https://cwww3.github.io/2021/09/26/linux-file/"/>
    <id>https://cwww3.github.io/2021/09/26/linux-file/</id>
    <published>2021-09-26T07:23:17.000Z</published>
    <updated>2021-09-26T07:25:53.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="FD文件描述符"><a href="#FD文件描述符" class="headerlink" title="FD文件描述符"></a>FD文件描述符</h3><p>Linux 系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I/O操作的系统调用都会通过文件描述符。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">用户级限制 查看当前进程的最大fd数</span></span><br><span class="line">ulimit -n </span><br><span class="line"><span class="meta">#</span><span class="bash">系统级限制</span></span><br><span class="line">sysctl -a</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="文件描述符表"><a href="#文件描述符表" class="headerlink" title="文件描述符表"></a>文件描述符表</h3><p>Linux系统中的每个进程会在其进程控制块（PCB）内维护属于自己的文件描述符表（file descriptor table）。表中每个条目包含两个域：一是控制该描述符的标记域（flags），二是指向系统级别的打开文件表中对应条目的指针。</p><h3 id="打开文件表-amp-句柄"><a href="#打开文件表-amp-句柄" class="headerlink" title="打开文件表&amp;句柄"></a>打开文件表&amp;句柄</h3><p>内核会维护系统内所有打开的文件及其相关的元信息，该结构称为打开文件表（open file table）。表中每个条目包含以下域：</p><ul><li>文件的偏移量。read()/write()/seek()函数都会修改该值；</li><li>打开文件时的状态和权限标记。通过open()函数的参数传入；</li><li>文件的访问模式（只读、只写、读+写等）。通过open()函数的参数传入；</li><li>指向其对应的inode对象的指针。</li></ul><p>各条目称为打开文件句柄（open file handle）。<strong>文件描述符是进程级别的，文件句柄是系统级别的</strong>，不能混用。它们在不同级别表示已打开的文件。文件描述符与文件句柄直接关联，文件句柄与inode直接关联。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lsof</span><br><span class="line"><span class="meta">#</span><span class="bash">在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Lists open files and the corresponding processes.</span></span><br></pre></td></tr></table></figure><h3 id="INODE"><a href="#INODE" class="headerlink" title="INODE"></a>INODE</h3><p>文件储存在硬盘上，硬盘的最小存储单位叫做扇区（Sector）。每个扇区储存512字节。</p><p>操作系统读取硬盘的时候，是一次性连续读取多个扇区，即一次性读取一个块（block）。这种由多个扇区组成的块，是文件存取的最小单位。块的大小，最常见的是4KB，即连续八个 sector组成一个 block。</p><p>文件数据都储存在块中，还需要一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，即索引节点。</p><p>每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看文件inode信息</span></span><br><span class="line">stat example.txt</span><br></pre></td></tr></table></figure><p>inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看每个硬盘分区的inode总数和已使用的数量</span></span><br><span class="line">df -i</span><br></pre></td></tr></table></figure><h3 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h3><p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210926112812282.png" alt="image-20210926112812282"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;文件&quot;&gt;&lt;a href=&quot;#文件&quot; class=&quot;headerlink&quot; title=&quot;文件&quot;&gt;&lt;/a&gt;文件&lt;/h2&gt;&lt;h3 id=&quot;FD文件描述符&quot;&gt;&lt;a href=&quot;#FD文件描述符&quot; class=&quot;headerlink&quot; title=&quot;FD文件描述符&quot;&gt;&lt;/a&gt;FD文件描述符&lt;/h3&gt;&lt;p&gt;Linux 系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I/O操作的系统调用都会通过文件描述符。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;用户级限制 查看当前进程的最大fd数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ulimit -n &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt;系统级限制&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sysctl -a&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://cwww3.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>prometheus</title>
    <link href="https://cwww3.github.io/2021/09/18/prometheus/"/>
    <id>https://cwww3.github.io/2021/09/18/prometheus/</id>
    <published>2021-09-18T07:47:23.000Z</published>
    <updated>2021-09-18T07:47:53.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">go get github.com/prometheus/client_golang/prometheus</span><br><span class="line">go get github.com/prometheus/client_golang/prometheus/promauto</span><br><span class="line">go get github.com/prometheus/client_golang/prometheus/promhttp</span><br></pre></td></tr></table></figure><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;github.com/prometheus/client_golang/prometheus/promhttp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        http.Handle(<span class="string">&quot;/metrics&quot;</span>, promhttp.Handler())</span><br><span class="line">        http.ListenAndServe(<span class="string">&quot;:2112&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行</span></span><br><span class="line">go run main.go</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 访问</span></span><br><span class="line">curl http://localhost:2112/metrics</span><br></pre></td></tr></table></figure><p>上述示例展示如何使用 Prometheus Golang 库来暴露应用的指标数据，但暴露的监控指标数据为文本类型，需要搭建维护额外的 Prometheus 服务来抓取指标，还需要额外的 Grafana 来对数据进行可视化展示。</p><h2 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h2><h4 id="Prometheus下载"><a href="#Prometheus下载" class="headerlink" title="Prometheus下载"></a>Prometheus下载</h4><p><a href="https://prometheus.io/download/">下载地址</a></p><p>解压后当前目录会包含默认的Prometheus配置文件promethes.yml</p><p>启动完成后，可以通过<a href="http://localhost:9090访问Prometheus的UI界面">http://localhost:9090访问Prometheus的UI界面</a></p><h4 id="Node-Exporter下载"><a href="#Node-Exporter下载" class="headerlink" title="Node Exporter下载"></a>Node Exporter下载</h4><p>在Prometheus的架构设计中，Prometheus Server并不直接服务监控特定的目标，其主要任务负责数据的收集，存储并且对外提供数据查询支持。因此为了能够能够监控到某些东西，如主机的CPU使用率，我们需要使用到Exporter。Prometheus周期性的从Exporter暴露的HTTP服务地址（通常是/metrics）拉取监控样本数据。</p><p>从上面的描述中可以看出Exporter可以是一个相对开放的概念，其可以是一个独立运行的程序独立于监控目标以外，也可以是直接内置在监控目标中。只要能够向Prometheus提供标准格式的监控样本数据即可。</p><p>这里为了能够采集到主机的运行指标如CPU, 内存，磁盘等信息。我们可以使用<a href="https://github.com/prometheus/node_exporter">Node Exporter</a>。</p><p>Node Exporter同样采用Golang编写，并且不存在任何的第三方依赖，只需要下载，解压即可运行。可以从<a href="https://prometheus.io/download/%E8%8E%B7%E5%8F%96%E6%9C%80%E6%96%B0%E7%9A%84node">https://prometheus.io/download/获取最新的node</a> exporter版本的二进制包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压启动后访问 http://localhost:9100</span></span><br></pre></td></tr></table></figure><h4 id="从Node-Exporter收集监控数据"><a href="#从Node-Exporter收集监控数据" class="headerlink" title="从Node Exporter收集监控数据"></a>从Node Exporter收集监控数据</h4><p>为了能够让Prometheus Server能够从当前node exporter获取到监控数据，这里需要修改Prometheus配置文件。编辑prometheus.yml并在scrape_configs节点下添加以下内容:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;prometheus&#x27;</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;localhost:9090&#x27;</span>]</span><br><span class="line">  <span class="comment"># 采集node exporter监控数据</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;node&#x27;</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;localhost:9100&#x27;</span>]</span><br></pre></td></tr></table></figure><p>重新启动Prometheus Server。访问<a href="http://localhost:9090/">http://localhost:9090</a>，进入到Prometheus Server。如果输入<code>up</code>并且点击执行按钮以后，可以看到如下结果：</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210916094823568.png" alt="image-20210916094823568" style="zoom:50%;" /><h4 id="Prometheus-UI"><a href="#Prometheus-UI" class="headerlink" title="Prometheus UI"></a>Prometheus UI</h4><p>Prometheus UI是Prometheus内置的一个可视化管理界面，通过Prometheus UI用户能够轻松的了解Prometheus当前的配置，监控任务运行状态等。 通过<code>Graph</code>面板，用户还能直接使用<code>PromQL</code>实时查询监控数据</p><h4 id="PromQL"><a href="#PromQL" class="headerlink" title="PromQL"></a>PromQL</h4><p>PromQL是Prometheus自定义的一套强大的数据查询语言，除了使用监控指标作为查询关键字以为，还内置了大量的函数，帮助用户进一步对时序数据进行处理。</p><h2 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h2><p>Grafana 是一个监控仪表系统，它可以大大帮助你简化监控的复杂度，你只需要提供你需要监控的数据，它就可以帮你生成各种可视化仪表。同时它还有报警功能，可以在系统出现问题时通知你。</p><h4 id="Docker安装运行"><a href="#Docker安装运行" class="headerlink" title="Docker安装运行"></a>Docker安装运行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3000:3000 grafana/grafana</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 访问 http://localhost:3000  </span><br><span class="line">2. 登录 账号密码默认admin。</span><br><span class="line">3. 在数据源中添加prometheus类型。 数据源URL为http://localhost:9090</span><br><span class="line">4. 新建dashboard进行数据分析</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Go&quot;&gt;&lt;a href=&quot;#Go&quot; class=&quot;headerlink&quot; title=&quot;Go&quot;&gt;&lt;/a&gt;Go&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 安装&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;go get github.com/prometheus/client_golang/prometheus&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;go get github.com/prometheus/client_golang/prometheus/promauto&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;go get github.com/prometheus/client_golang/prometheus/promhttp&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="运维" scheme="https://cwww3.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>GoQuestion</title>
    <link href="https://cwww3.github.io/2021/09/06/GoQuestion/"/>
    <id>https://cwww3.github.io/2021/09/06/GoQuestion/</id>
    <published>2021-09-06T02:33:51.000Z</published>
    <updated>2021-09-24T01:23:42.233Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Question1"><a href="#Question1" class="headerlink" title="Question1"></a>Question1</h2><h3 id="time-After-内存泄漏代码"><a href="#time-After-内存泄漏代码" class="headerlink" title="time.After 内存泄漏代码"></a>time.After 内存泄漏代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    )</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            i++</span><br><span class="line">            ch &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> x := &lt;- ch:</span><br><span class="line">            <span class="built_in">println</span>(x)</span><br><span class="line">        <span class="keyword">case</span> &lt;- time.After(<span class="number">3</span> * time.Minute):</span><br><span class="line">            <span class="built_in">println</span>(time.Now().Unix())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>在for循环每次select的时候，都会实例化一个一个新的定时器。该定时器在3分钟后，才会被激活，但是激活后已经跟select无引用关系，被gc给清理掉。</p><p>换句话说，被遗弃的time.After定时任务还是在时间堆里面，定时任务未到期之前，是不会被gc清理的。</p><h3 id="原理验证"><a href="#原理验证" class="headerlink" title="原理验证"></a>原理验证</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    )</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> ms runtime.MemStats</span><br><span class="line">    runtime.ReadMemStats(&amp;ms)</span><br><span class="line">    fmt.Println(<span class="string">&quot;before, have&quot;</span>, runtime.NumGoroutine(), <span class="string">&quot;goroutines,&quot;</span>, ms.Alloc, <span class="string">&quot;bytes allocated&quot;</span>, ms.HeapObjects, <span class="string">&quot;heap object&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;</span><br><span class="line">        time.After(<span class="number">3</span> * time.Minute)</span><br><span class="line">    &#125;</span><br><span class="line">    runtime.GC()</span><br><span class="line">    runtime.ReadMemStats(&amp;ms)</span><br><span class="line">    fmt.Println(<span class="string">&quot;after, have&quot;</span>, runtime.NumGoroutine(), <span class="string">&quot;goroutines,&quot;</span>, ms.Alloc, <span class="string">&quot;bytes allocated&quot;</span>, ms.HeapObjects, <span class="string">&quot;heap object&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">    runtime.GC()</span><br><span class="line">    runtime.ReadMemStats(&amp;ms)</span><br><span class="line">    fmt.Println(<span class="string">&quot;after 10sec, have&quot;</span>, runtime.NumGoroutine(), <span class="string">&quot;goroutines,&quot;</span>, ms.Alloc, <span class="string">&quot;bytes allocated&quot;</span>, ms.HeapObjects, <span class="string">&quot;heap object&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Minute)</span><br><span class="line">    runtime.GC()</span><br><span class="line">    runtime.ReadMemStats(&amp;ms)</span><br><span class="line">    fmt.Println(<span class="string">&quot;after 3min, have&quot;</span>, runtime.NumGoroutine(), <span class="string">&quot;goroutines,&quot;</span>, ms.Alloc, <span class="string">&quot;bytes allocated&quot;</span>, ms.HeapObjects, <span class="string">&quot;heap object&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证结果如下图所示：</p><img src="https://raw.githubusercontent.com/cwww3/picture/master/img/image-20210906101432013.png" alt="image-20210906101432013" style="zoom:50%;" /><p>从图中可以看出，实例中循环跑完后，创建了3000172个对象，由于每个time定时器设置的为3分钟，在3分钟后，可以看到对象都被GC回收，只剩174个对象，从而验证了，time.After定时器在定时任务到达之前，会一直存在于时间堆中，不会释放资源，直到定时任务时间到达后才会释放资源。</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>综上，在go代码中，在for循环里<strong>不要使用</strong>select + time.After的组合，可以使用time.NewTimer替代</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    )</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            ch &lt;- <span class="number">100</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"> </span><br><span class="line">    idleDuration := <span class="number">3</span> * time.Minute</span><br><span class="line">    idleDelay := time.NewTimer(idleDuration)</span><br><span class="line">    <span class="keyword">defer</span> idleDelay.Stop()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        idleDelay.Reset(idleDuration)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> x := &lt;- ch:</span><br><span class="line">                <span class="built_in">println</span>(x)</span><br><span class="line">            <span class="keyword">case</span> &lt;-idleDelay.C:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Question2"><a href="#Question2" class="headerlink" title="Question2"></a>Question2</h2><h3 id="作用域和短声明"><a href="#作用域和短声明" class="headerlink" title="作用域和短声明"></a>作用域和短声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">fmt.Println(&amp;a)</span><br><span class="line"><span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">a,_ := get()</span><br><span class="line">fmt.Println(&amp;a)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出a的地址不同</span></span><br></pre></td></tr></table></figure><h3 id="原因分析-1"><a href="#原因分析-1" class="headerlink" title="原因分析"></a>原因分析</h3><p><strong>不同作用域</strong>下<strong>同名</strong>变量使用<strong>短声明</strong>赋值时会产生新的变量进行覆盖</p><p><strong>同一作用域</strong>下<strong>同名</strong>变量使用<strong>短声明</strong>赋值时不会产生新的变量，而是对同一个变量进行赋值</p><h3 id="问题解决-1"><a href="#问题解决-1" class="headerlink" title="问题解决"></a>问题解决</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">fmt.Println(&amp;a)</span><br><span class="line"><span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="comment">// 使用临时变量接收，再通过=赋值</span></span><br><span class="line">      tmp,_ := get()</span><br><span class="line">a = tmp</span><br><span class="line">fmt.Println(&amp;a)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Question1&quot;&gt;&lt;a href=&quot;#Question1&quot; class=&quot;headerlink&quot; title=&quot;Question1&quot;&gt;&lt;/a&gt;Question1&lt;/h2&gt;&lt;h3 id=&quot;time-After-内存泄漏代码&quot;&gt;&lt;a href=&quot;#time-After-内存泄漏代码&quot; class=&quot;headerlink&quot; title=&quot;time.After 内存泄漏代码&quot;&gt;&lt;/a&gt;time.After 内存泄漏代码&lt;/h3&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&amp;quot;time&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ch := &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            i++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ch &amp;lt;- i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; x := &amp;lt;- ch:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;println&lt;/span&gt;(x)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &amp;lt;- time.After(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; * time.Minute):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;println&lt;/span&gt;(time.Now().Unix())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Go Question" scheme="https://cwww3.github.io/tags/Go-Question/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://cwww3.github.io/2021/09/02/linux-command/"/>
    <id>https://cwww3.github.io/2021/09/02/linux-command/</id>
    <published>2021-09-02T03:12:40.000Z</published>
    <updated>2021-11-18T06:51:29.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><ul><li>find</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 只在当前目录下搜索 符合条件的文件</span></span><br><span class="line">find . -maxdepth 1 -name 表达式</span><br><span class="line">-type f/d 指定类型</span><br><span class="line">-perm xxx 指定权限</span><br><span class="line">-a 与</span><br><span class="line">-o 或</span><br><span class="line">! -not 非</span><br></pre></td></tr></table></figure><span id="more"></span><ul><li>xargs</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> xargs命令的作用，是将标准输入转为命令行参数。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> 不接受标准输入作为参数 只能直接在命令行输入参数 无法用管道命令传递参数 不会有输出</span> </span><br><span class="line">echo &quot;hello world&quot; | echo </span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出 hello world</span></span><br><span class="line">echo &quot;hello world&quot; | xargs echo</span><br></pre></td></tr></table></figure><ul><li>grep</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 当前目录下查找内容</span></span><br><span class="line">grep -r &quot;要查找的内容&quot; .</span><br></pre></td></tr></table></figure><ul><li>tee</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不退出vim保存没权限的文件</span></span><br><span class="line">:w !sudo tee %</span><br><span class="line"><span class="comment"># w 保存文件内容</span></span><br><span class="line"><span class="comment"># !sudo 使用sudo权限 </span></span><br><span class="line"><span class="comment"># tee 将w输出的内容重定向到%</span></span><br><span class="line"><span class="comment"># % 当前文件</span></span><br></pre></td></tr></table></figure><ul><li>sed</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 替换文件内容</span></span><br><span class="line">sed -i suffix <span class="string">&quot;s/原字符串/替换字符串/g&quot;</span> filename</span><br><span class="line"><span class="comment"># suffix 对修改文件进行备份，名字为原名加后缀 （osx系统必须指定，可以输入&quot;&quot;表示不备份）</span></span><br><span class="line"><span class="comment"># s 表示替换</span></span><br><span class="line"><span class="comment"># g 表示全部替换</span></span><br><span class="line"><span class="comment"># -i 修改文件  -e 将修改后的内容输出到标准输出，不修改文件</span></span><br></pre></td></tr></table></figure><ul><li>重定向</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Linux重定向是指修改原来默认的一些东西，对原来系统命令的默认执行方式进行改变</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Linux默认输入是键盘，输出是显示器。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">STDIN 0 键盘输入 STDOUT 1 输出信息到提示符窗口 STDERR 2 输出错误信息到提示符窗口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认的 &lt; 重定向输入操作符是 0，而默认的 &gt; 重定向输出操作符是 1。键入 &lt; 或 &gt; 操作符之后，必须指定数据的读写位置，可以是文件名或其他现有的句柄。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 要指定重定向到现有句柄，请使用与 &amp; 字符，后面接要重定向的句柄号。如：2&gt;&amp;1</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="comment">#将命令输出写入文件或设备，而不是命令提示符或句柄</span></span></span><br><span class="line"> </span><br><span class="line">&lt; #从文件而不是从键盘或句柄读入命令输入</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt; <span class="comment">#将命令输出添加到文件末尾而不删除文件中已有的信息</span></span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&amp; <span class="comment">#将一个句柄的输出写入到另一个句柄的输入中</span></span></span><br><span class="line"> </span><br><span class="line">&lt;&amp; #从一个句柄读取输入并将其写入到另一个句柄输出中</span><br><span class="line"> </span><br><span class="line">| #从一个命令中读取输出并将其写入另一个命令的输入中;也称为管道操作符</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例：</span></span><br><span class="line">mysh &gt; mylog.txt 2&gt;&amp;1</span><br><span class="line"><span class="meta">#</span><span class="bash"> &gt; mylog.txt意思是将标准输出重定向到mylog.txt，等价于mysh 1&gt; mylog.txt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2 &gt;&amp; 1 意思是将错误输出重定向到句柄1标准输出;综合起来就是mysh命令执行过程中产生的标准输出和错误输出都会被重定向到mylog.txt中;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 某些时候我们可能并不希望记录什么标准输出或者是错误输出，那可以用</span></span><br><span class="line">mysh &gt;/dev/null 2&gt;/dev/null;</span><br></pre></td></tr></table></figure><ul><li>进程替代(Process substitution)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">进程替代是进程间通信的一种方式。在 Linux 上使用进程替代的时候，系统会创建一个临时的文件描述符，然后将用以替代的进程的输出和这个文件描述符关联起来，这个可以通过以下命令来验证:</span><br><span class="line">执行 echo &lt;(date)</span><br><span class="line">输出 /dev/fd/11</span><br><span class="line">fd就是文件描述父的缩写，但你去/dev/fd/下面找这个文件描述符，却会发现找不到，那是因为这个文件描述符是临时的，在传给&quot;echo&quot;命令后就被释放了。</span><br><span class="line">此外，进程替代并不能和文件完全等价，这一点要切记。进程替代所建立的&quot;对象&quot;，是不能进行写入和随机读取操作的。</span><br><span class="line"></span><br><span class="line">例子</span><br><span class="line">需求: 运行mysh并指定一个配置文件(配置文件没有权限直接修改，但是需要在配置文件中添加foo=bar)</span><br><span class="line">mysh -config=&lt;(cat /path/config &lt;(print &quot;foo=bar&quot;))</span><br></pre></td></tr></table></figure><ul><li>kill</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kill -l #查看信号</span><br><span class="line">kill PID #默认 -15 TERM</span><br><span class="line">kill -9 PID # 强制杀死程序 KILL</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一般情况下，优先使用SIGTERM信号。这是因为当程序收到了SIGTERM信号之后，会做一些程序的清理操作，或者说是优雅的关闭。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果传入<span class="built_in">kill</span> -9 也就是SIGKILL，那么应用程序将无法捕捉这个信号，从而导致程序强制被关闭，有可能会照成一些异常情况，比如数据还没有保存，数据传输还没有结束等等。</span></span><br></pre></td></tr></table></figure><ul><li>lsof</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsof -i :port # 查看端口占用</span><br><span class="line">lsof -p 5656  # 查看进程ID</span><br></pre></td></tr></table></figure><ul><li>if</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">if [ command ]; then</span><br><span class="line">     符合该条件执行的语句</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ command ];then</span><br><span class="line">     符合该条件执行的语句</span><br><span class="line">elif [ command ];then</span><br><span class="line">     符合该条件执行的语句</span><br><span class="line">else</span><br><span class="line">     符合该条件执行的语句</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 常用参数：</span></span><br><span class="line">[ -a FILE ] 如果 FILE 存在则为真。</span><br><span class="line">[ -d FILE ] 如果 FILE 存在且是一个目录则返回为真。</span><br><span class="line">[ -e FILE ] 如果 指定的文件或目录存在时返回为真。</span><br><span class="line">[ -f FILE ] 如果 FILE 存在且是一个普通文件则返回为真。</span><br><span class="line">[ -r FILE ] 如果 FILE 存在且是可读的则返回为真。</span><br><span class="line">[ -w FILE ] 如果 FILE 存在且是可写的则返回为真。（一个目录为了它的内容被访问必然是可执行的）</span><br><span class="line">[ -x FILE ] 如果 FILE 存在且是可执行的则返回为真。</span><br><span class="line"></span><br><span class="line">[ -z STRING ] 如果STRING的长度为零则返回为真，即空是真</span><br><span class="line">[ -n STRING ] 如果STRING的长度非零则返回为真，即非空是真</span><br><span class="line">[ STRING1 ]　 如果字符串不为空则返回为真,与-n类似</span><br><span class="line">[ STRING1 == STRING2 ] 如果两个字符串相同则返回为真</span><br><span class="line">[ STRING1 != STRING2 ] 如果字符串不相同则返回为真</span><br><span class="line">[ STRING1 &lt; STRING2 ] 如果 “STRING1”字典排序在“STRING2”前面则返回为真。</span><br><span class="line">[ STRING1 &gt; STRING2 ] 如果 “STRING1”字典排序在“STRING2”后面则返回为真。</span><br><span class="line"></span><br><span class="line">[ INT1 -eq INT2 ] INT1和INT2两数相等返回为真 ,=</span><br><span class="line">[ INT1 -ne INT2 ] INT1和INT2两数不等返回为真 ,&lt;&gt;</span><br><span class="line">[ INT1 -gt INT2 ] INT1大于INT2返回为真 ,&gt;</span><br><span class="line">[ INT1 -ge INT2 ] INT1大于等于INT2返回为真,&gt;=</span><br><span class="line">[ INT1 -lt INT2 ] INT1小于INT2返回为真 ,&lt;</span><br><span class="line">[ INT1 -le INT2 ] INT1小于等于INT2返回为真,&lt;=</span><br><span class="line"></span><br><span class="line">[ ! EXPR ] 逻辑非，如果 EXPR 是false则返回为真。</span><br><span class="line">[ EXPR1 -a EXPR2 ] 逻辑与，如果 EXPR1 and EXPR2 全真则返回为真。</span><br><span class="line">[ EXPR1 -o EXPR2 ] 逻辑或，如果 EXPR1 或者 EXPR2 为真则返回为真。</span><br><span class="line">[ ] || [ ] 用OR来合并两个条件</span><br><span class="line">[ ] &amp;&amp; [ ] 用AND来合并两个条件</span><br><span class="line"></span><br><span class="line">IF高级特性：</span><br><span class="line">双圆括号(( ))：表示数学表达式</span><br><span class="line">双方括号[[ ]]：表示高级字符串处理函数</span><br><span class="line"></span><br><span class="line">[ $a != 1 || $b = 2 ]是不允许的 要用[ $a != 1 ] || [ $b = 2 ]</span><br><span class="line">而双括号就可以解决这个问题 [[ $a != 1 || $b = 2 ]]</span><br><span class="line"></span><br><span class="line">[ &quot;$a&quot; -lt &quot;$b&quot; ]，也可以改成双括号的形式((&quot;$a&quot; &lt; &quot;$b&quot;))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Linux常用命令&quot;&gt;&lt;a href=&quot;#Linux常用命令&quot; class=&quot;headerlink&quot; title=&quot;Linux常用命令&quot;&gt;&lt;/a&gt;Linux常用命令&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;find&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 只在当前目录下搜索 符合条件的文件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;find . -maxdepth 1 -name 表达式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-type f/d 指定类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-perm xxx 指定权限&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-a 与&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-o 或&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;! -not 非&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="https://cwww3.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
